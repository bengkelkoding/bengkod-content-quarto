[
  {
    "objectID": "studi_kasus_1.html",
    "href": "studi_kasus_1.html",
    "title": "11  Studi Kasus 1",
    "section": "",
    "text": "12 Studi Kasus 1 : Program Pengelola Data Karyawan\nStudi kasus kali ini juga tersedia dalam bentuk video yang bisa di tonton pada tautan berikut.\nKali ini kita akan belajar bahasa pemrograman Dart. Bahasa pemrograman yang akan digunakan di framework Flutter.\nFlutter merupakan framework yang digunakan untuk membuat aplikasi mobile multiplatform baik android maupun IOS.\nMateri yang akan dipelajari pada tutorial ini ada beberapa materi, meliputi:\nSebelum memulai tutorial, terdapat beberapa hal yang perlu diperhatikan dan dipahami terlebih dahulu,"
  },
  {
    "objectID": "studi_kasus_1.html#tujuan-pembelajaran-dart",
    "href": "studi_kasus_1.html#tujuan-pembelajaran-dart",
    "title": "11  Studi Kasus 1",
    "section": "13.1 Tujuan Pembelajaran Dart",
    "text": "13.1 Tujuan Pembelajaran Dart\nHarapan setelah menyelesaikan studi kasus ini, teman-teman akan lebih mudah memahamai syntax yang digunakan pada flutter ketika membuat aplikasi untuk pemrograman mobile baik android maupun IOS."
  },
  {
    "objectID": "studi_kasus_1.html#create-project",
    "href": "studi_kasus_1.html#create-project",
    "title": "11  Studi Kasus 1",
    "section": "14.1 Create Project",
    "text": "14.1 Create Project\nDari create project terlebih dahulu, sebenarnya kalau kita memulai pemrograman dart, tidak harus membuat project, kita bisa membuat text file dan kita save dengan format dart, misalkan latihan.dart, kita save dan buat fungsi main dan jalankan.\n\n\n\n\n\n\nRekomendasi\n\n\n\nDirekomendasikan saat memulai pemrograman dart, baik itu dart saja atau menggunakan flutter, kita mulai dari membuat project, karena nantinya bisa memudahkan untuk memasukkan depedency library-library tambahan yang dibutuhkan untuk pemrograman dart.\n\n\nCara membuat project, menggunakan terminal atau command prompt, dengan mengetik perintah dart create namaproject.\n\n\n\nTampilan Command Prompt\n\n\natau kalau kita menggunakan Visual Studio Code, bisa menggunakan shortcut Ctrl+Shift+P, pilih new dart project, kita menggunakan console application, kita pilih folder atau direktori tempat kita membuat projectnya, kemudian ketik nama project dart kita. Kalau kita menggunakan new dart project / create dart, kita akan mendapatkan beberapa direktori dan file, yang penting dalam direktori kita adalah pubspec.yaml, untuk menambahan dependency yang dibutuhkan.\n\n\n\npubspec.yaml\n\n\n\n\n\n\n\n\nTips\n\n\n\nDasar pemrograman Dart mirip dengan pemrograman yang lain dalam penerapan variabel, kondisi, iterasi, dan sebagainya."
  },
  {
    "objectID": "studi_kasus_1.html#program-dart",
    "href": "studi_kasus_1.html#program-dart",
    "title": "11  Studi Kasus 1",
    "section": "14.2 Program Dart",
    "text": "14.2 Program Dart\nKita akan membuat program dart.\n\nTambahkan variabel nilai = 90\nSelanjutnya, buat kondisi if nilai &gt; 80 maka tambahkan print lulus dan else maka tambahkan print tidak lulus. Jalankan dan debugging akan mengeluarkan hasil lulus karena variabel nilai yang sudah kita buat bernilai 90 dan kondisi nilai &gt; 80 terpenuhi maka akan mengeluarkan output lulus.\n\nvoid main() { \n  int nilai = 90; \n  if (nilai &gt; 80) { \n    print('Lulus'); \n  } else { \n    print('Tidak Lulus'); \n  } \n} \n\n\n\nOutput Program Latihan 1\n\n\nUntuk bagian perulangan, sama dengan bahasa pemrograman lain. Bisa menggunakan for, while, do while.\nvoid main() { \n  int nilai = 90; \n  if (nilai &gt; 80) { \n    print('Lulus'); \n  } else { \n    print('Tidak Lulus'); \n  } \n\n  for (int i = 0; i &lt; 10; i++) { \n    print(\"cetakan ke ${i + 1}\"); \n  } \n}\n\n\n\nOutput Program Latihan 2"
  },
  {
    "objectID": "studi_kasus_1.html#konsep-object-oriented-programming-oop",
    "href": "studi_kasus_1.html#konsep-object-oriented-programming-oop",
    "title": "11  Studi Kasus 1",
    "section": "14.3 Konsep Object Oriented Programming (OOP)",
    "text": "14.3 Konsep Object Oriented Programming (OOP)\n\n14.3.1 Membuat Class Karyawan\n\nMasuk ke konsep OOP, langkah pertama adalah membuat class baru yang disebut Karyawan. Untuk melakukannya, kita perlu membuat file baru dengan nama karyawan.dart.\n\n\n\n\nFile karyawan.dart\n\n\nDalam class Karyawan, kita akan menentukan beberapa atribut.\nPertama, kita memiliki atribut npp dan nama yang harus memiliki nilai (not nullable), sehingga kita harus memberikan nilai awal. Jika kita ingin menambahkan atribut yang bisa bernilai null, kita perlu menambahkan tanda ? setelah tipe data atribut tersebut. Misalnya, jika kita ingin menambahkan atribut alamat yang bisa bernilai null, maka kita akan mendefinisikannya sebagai String alamat?. Dengan cara ini, atribut alamat memiliki sifat nullable atau boleh bernilai null. Konsep ini yang mungkin tidak ada pada bahasa pemrograman seperti C++ ataupun Java yaitu Not Nullable dan Nullable\nclass Karyawan {\n  String npp; //not nullable\n  String nama;\n  String? alamat; //nullable\n}\n\nTambahkan string thnMasuk dan int _gaji.\n\nAtribut yang kita buat sudah ada semua. Kalau kita sudah install dart plugin, setiap kita save akan otomatis melakukan reformating sesuai dengan ketentuan rekomendasi formating dart.\nclass Karyawan {\n  String npp = \"\"; //not nullable\n  String nama = \"\";\n  String? alamat; //nullable\n  int thnMasuk;\n  int _gaji;\n}\n\nBiar npp dan nama tidak eror, kita berikan default value pada constructor.\n\n\n\n\n\n\n\nTips\n\n\n\nMirip dengan java, membuat constructor pada dart, kita membuat method yang namanya sama persis dengan nama class.\n\n\nBuat constructor Karyawan kemudian kita masukkan this.npp, this.nama, alamat tidak kita masukkan karena sifatnya nullable jadi nanti kita isi lewat atribut assesment.\nTambahkan {} named parameter pada thnMasuk dibuat opsional dengan memberikan default value. Masih ada eror karena ada atribut _gaji yang seharusnya diisikan karena not nullable, kita juga bisa memberikan default value dengan angka 2900000.\nclass Karyawan {\n  String npp; //not nullable\n  String nama;\n  String? alamat; //nullable\n  int thnMasuk;\n  int _gaji = 2900000;\n\n  Karyawan(this.npp, this.nama, {this.thnMasuk = 2015}); //constructor\n}\nKita sudah punya class tidak ada eror. Ada atribut, ada method, dan atribut yang not nullable sudah kita buat.\n\nSelanjutnya, tambahkan method.\n\nBuat method presensi. Lita menggunakan tipe data yang beda, menggunakan tipe data DateTime yang merupakan tipe data objek bawaan dari dart, kita beri dengan nama jamMasuk. Tambahkan kondisi jika jamMasuk.hour &gt; 8, maka kita menganggap terlambat.\n\n\n\n\n\n\nTips\n\n\n\nKita gunakan string interpolation, mirip seperti C++/python, kita awali dengan $ dan memberikan nama variabel.\n\n\nvoid presensi(DateTime jamMasuk) {\n    if (jamMasuk.hour &gt; 8) {\n      print(\"$nama Datang terlambat\");\n    } else {\n      print(\"$nama datang tepat waktu\");\n    }\n  }\n\nTambahkan method deskripsi tipe data String dengan nama deksripsi, tambahkan String teks.\n\n\n\n\n\n\n\nTips\n\n\n\nMirip seperti python, kalau kita mau menggunakan multiline string, kita bisa memberikan tanda petik 3 kali nanti tutup dengan petik 3 kali juga.\n\n\nString deskripsi() {\n    String teks = \"\"\"===================\n    \"\"\";\n    return teks;\n  }\n\nIsi tulisan di String teks yang akan ditampilkan nanti dengan menggunakan string interpolation untuk memanggil npp, nama, _gaji. Kita tidak melakukan print terhadap deskripsi, tapi kita melakukan return terhadap teks.\n\nString deskripsi() {\n    String teks = \"\"\"===================\n    NPP: $npp\n    Nama: $nama\n    Gaji:$_gaji\n    \"\"\";\n    return teks;\n  }\n\n\n\n\n\n\nTips\n\n\n\nUntuk menggunakan getter dan setter dalam Dart, Anda dapat membuat metode tambahan dengan cara yang sedikit berbeda dari pendekatan OOP Java. Dalam Dart, getter dan setter memiliki fitur unik, di mana pemanggilannya tampak seolah-olah Anda mengakses atribut, bukan memanggil metode.\n\n\n\nBuat getter dengan nama tunjangan. Untuk membuat getter tunjangan dalam Dart, Anda hanya perlu menuliskan int get tunjangan tanpa menggunakan tanda kurung (). Di Dart, ketika Anda memanggil tunjangan, itu seolah-olah Anda mengakses variabel atau atribut, bukan memanggil fungsi atau metode. Selain itu, Anda dapat menambahkan kondisi: jika tahun kerja kurang dari 5, maka tunjangan sebesar 500000, dan jika lebih dari 5 tahun, maka tunjangan sebesar 1000000.\n\nint get tunjangan {\n    if ((2023 - thnMasuk) &lt; 5) {\n      return 50000;\n    } else {\n      return 100000;\n    }\n  }\n\n\n\n\n\n\nTips\n\n\n\nKita tidak perlu menggunakan kondisi seperti pada umumnya, kita bisa menggunakan kondisi yang lebih simpel sesuai dengan kodingan yang tersedia. Kita bisa menggunakan arrow function tanpa menggunakan {} dan lebih simpel dari yang sebelumnya.\n\n\nint get tunjangan =&gt; ((2023 - thnMasuk) &lt; 5) ? 50000 : 100000;\nJadi sudah cukup banyak fitur dart yang kita manfaatkan. Ada not nullable dan nullable, ada optional named parameter, ada string interpolation, ada setter dan arrow function.\n\nKita membuat getter untuk gaji dengan nama int get gaji yang menggunakan arrow function yang berisi gaji + tunjangan. Disini kita menggunakan tunjangan, memanggil variabel dengan getter\n\nint get gaji =&gt; (_gaji + tunjangan);\n\nBuat setter dengan nama void set gaji dan tidak menggunakan arrow function.\n\nKalau kita set gaji dibawah nilai yang sudah ada, maka akan otomatis default ke nilai yang sebelumnya yaitu 2900000.\nBuat kondisi: gaji dibawah UMR, kita buat constanta di luar class dengan nama constanta UMR dengan nilai 290000, dan di atribut gaji di dalam class Karyawan, kita ubah nilai dari atribut gaji dengan variabel const UMR.\nconst UMR = 2900000;\n\nabstract class Karyawan {\n  String npp; //not nullable\n  String nama;\n  String? alamat; //nullable\n  int thnMasuk;\n  int _gaji = 2900000;\n}\n\nKita update kondisi pada set gaji. Jika gaji kurang dari UMR, maka kita set menggunakan this.gaji = UMR dan tidak boleh dibawah UMR. Ada tanda biru diperingatkan, seperti java, merefer ke atribut dan atributnya tidak ada nama variabel yang sama, kita tidak harus menggunakan this, langsung tanpa menggunakan this, tetapi kalau ada nama variabel yang sama maka bisa menggunakan this supaya tidak bertabrakan dengan variabel lain. Tambahkan variabel di void set gaji, yaitu int gaji, dan masukkan pada kondisi else _gaji = gaji. Setter tidak perlu return jadi void bisa dihapus.\n\nset gaji(int gaji) {\n    if (gaji &lt; UMR) {\n      _gaji = UMR;\n      print(\"Gaji tidak boleh dibawah UMR\");\n    } else {\n      _gaji = gaji;\n    }\n  }\n\n\n\n\n\n\nTips\n\n\n\nConstructor pada dart sedikit berbeda dengan constructor yang terdapat di Java. Kalau di java constructor ada parameter bisa menggunakan this.nama=nama, kalau di dart parameter langsung merujuk pada atribut jadi bisa lebih singkat.\n\n\nKaryawan(this.npp, this.nama, {this.thnMasuk = 2015}); //constructor"
  },
  {
    "objectID": "studi_kasus_1.html#pemanggilan-class-karyawan-di-fungsi-main",
    "href": "studi_kasus_1.html#pemanggilan-class-karyawan-di-fungsi-main",
    "title": "11  Studi Kasus 1",
    "section": "14.4 Pemanggilan Class Karyawan di Fungsi Main",
    "text": "14.4 Pemanggilan Class Karyawan di Fungsi Main\nSelanjutnya, kita akan memanggil class Karyawan di fungsi main.\n\nPindah ke halaman main, panggil class Karyawan, langsung auto complete dan auto import karyawan.dart, kemudian masukkan parameter yang wajib pada class karyawan yaitu npp dan nama, set parameter thnMasuk juga, dan jika parameter tidak di set, maka akan otomatis mengambil nilai default.\n\nimport 'karyawan.dart';\n\nvoid main(List&lt;String&gt; arguments) {\n  Karyawan staff1 = Karyawan(\"A123\", \"Lars Bak\");\n  Karyawan staff2 = Karyawan(\"B123\", \"Kasper Lund\", thnMasuk: 2016);\n  Karyawan staff3 = Karyawan(\"C123\", \"Denis Ritchie\", thnMasuk: 2020);\n}\n\nKita panggil method yang sudah kita buat, yaitu method presensi, dengan cara pemanggilannya adalah staff1.presensi, cara membuat tipe data Datetime adalah DateTime(now) tetapi kita akan membuat spesifikasi jam dan tanggal maka tambahkan parse dengan format string yyyy-mm-dd 00:00:00.\n\nstaff1.presensi(DateTime.parse('2023-08-08 07:00:00'));\nstaff2.presensi(DateTime.parse('2023-08-08 09:01:01'));\nstaff3.presensi(DateTime.parse('2023-08-08 08:30:00'));\n\nPanggil method yang lain, yaitu set gaji dengan pemanggilan staff2.gaji dan isi nilai sesuai dengan keinginan kita.\n\n\n\n\n\n\n\nTips\n\n\n\nMeskipun setternya method, kita posisikan sebagai setter kita gunakan seolah kita memanggil atribut.\n\n\n  staff2.gaji = 50000;\n  staff3.gaji = 500000;\n\nKemudian kita panggil method deskripsi untuk menampilkan deskripsi dari masing-masing staf.\n\nprint(staff1.deskripsi());\nprint(staff2.deskripsi());\nprint(staff3.deskripsi());\n\nTambahkan kondisi pada method deskripsi. Jika kondisi alamat tidak null maka alamat=$alamat, sehingga jika kita tambahkan method alamat, maka staf yang menuliskan alamat akan keluar output alamatnya dan jika tidak menuliskan alamat maka tidak akan muncul alamat pada output.\n\nString deskripsi() {\n    String teks = \"\"\"===================\n    NPP: $npp\n    Nama: $nama\n    Gaji:$_gaji\n    \"\"\";\n    if (alamat != null) {\n      teks += \"Alamat: $alamat\";\n    }\n    return teks;\n  }\nOutput atau hasil dari program yang telah dibuat di atas adalah sebagai berikut:\n\n\n\nOutput Program OOP"
  },
  {
    "objectID": "studi_kasus_1.html#refactor-class-karyawan-menjadi-super-class-dan-sub-class",
    "href": "studi_kasus_1.html#refactor-class-karyawan-menjadi-super-class-dan-sub-class",
    "title": "11  Studi Kasus 1",
    "section": "14.5 Refactor Class Karyawan Menjadi Super Class dan Sub Class",
    "text": "14.5 Refactor Class Karyawan Menjadi Super Class dan Sub Class\n\nBuat class baru dengan nama class Pejabat, jadi class Pejabat ini adalah bagian dari class Karyawan tetapi yang memiliki jabatan. Karena class pejabat akan banyak kesamaan dengan karyawan. Kita akan melakukan extends.\n\nclass Pejabat extends Karyawan {}\n\nKita membuat refactor, class karyawan jadi super class, dan yang bawahnya menjadi sub class, kita membuat 2 subclass yaitu class stafBiasa extends Karyawan, dan class pejabat extends Karyawan.\n\nclass StafBiasa extends Karyawan {} // subclass\n\nclass Pejabat extends Karyawan {} // subclass\n\n\n\n\n\n\nTips\n\n\n\nAda beberapa method yang sifatnya berbeda dan harus didefinisikan secara berbeda, ada yang sama, ada juga yang berbeda misal presensi antar staf biasa dan pejabat berbeda, kita bedakan presensi masuk staf biasa dan pejabat.\n\n\n\nBuat class Karyawan menjadi class abstract\n\nabstract class Karyawan { \n  String npp; //not nullable\n  String nama;\n  String? alamat; //nullable\n  int thnMasuk;\n  int _gaji = 2900000;\n}\n\nDan kita membuat presensi menjadi abstract method.\n\n\n\n\n\n\n\nTips\n\n\n\nkalau di java kita membuat abstarct method kita harus menambahkan abstract di depan. Jika di dart, kita cukup menhapus kondisi dan kita ganti dengan ; dan otomatis menjadi abstract method.\n\n\nvoid presensi(DateTime jamMasuk);\n\n\n\n\n\n\nTips\n\n\n\nTunjangan StafBiasa dengan Pejabat berbeda, tunjangan pada StafBiasa berdasarkan tahun masuk, sedangkan tunjangan pada Pejabat berdasarkan jabatan, kita buat tunjangan sebagai abstract class.\n\n\nClass Karyawan akan menjadi superclass, Class StafBiasa akan menjadi sub class, dan Class Pejabat akan menjadi sub class.\nSuperclass\nabstract class Karyawan {...} //superclass\nSubclass\nclass StafBiasa extends Karyawan {...} //subclass\nclass Pejabat extends Karyawan {...} //subclass\n\n\n\n\n\n\nTips\n\n\n\nMethod abstract: method presensi, dan method get tunjangan. Kedua ini akan menjadi method abstract, yang artinya method abstact ini harus di implementasikan di extends classnya yaitu di class stafbiasa dan staff pejabat.\n\n\n\nKita lihat pada sub class akan terdapat eror karena kita harus mengimplementasikan 2 method abstract, kita bisa klik tombol kuning sebelah kiri dan kita pilih create 2 missing override dan otomatis akan muncul dua method abstract.\n\n\n\n\nQuick Fix 1\n\n\nSyntax akan menjadi seperti ini:\nclass StafBiasa extends Karyawan {\n  @override\n  void presensi(DateTime jamMasuk) {\n    // TODO: implement presensi\n  }\n\n  @override\n  // TODO: implement tunjangan\n  int get tunjangan =&gt; throw UnimplementedError();\n}\n\nDan kita harus mengimplementasikan constructornya juga, pilih Create constructor to call super.\n\nSyntax akan menjadi seperti ini:\n\n\n\nQuick Fix 2\n\n\nclass StafBiasa extends Karyawan {\n  StafBiasa(super.npp, super.nama);\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    // TODO: implement presensi\n  }\n\n  @override\n  // TODO: implement tunjangan\n  int get tunjangan =&gt; throw UnimplementedError();\n}\n\nDi dalam constructor hanya ada npp dan nama, kita tambahkan named parameter thnMasuk ke dalam constructor di sub class,\n\nclass StafBiasa extends Karyawan {\n  StafBiasa(super.npp, super.nama, {thnMasuk = 2015});\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    // TODO: implement presensi\n  }\n\n  @override\n  // TODO: implement tunjangan\n  int get tunjangan =&gt; throw UnimplementedError();\n}\n\nTambahkan kondisi pada method presensi yang sudah dibuat ke dalam abstract method.\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    if (jamMasuk.hour &gt; 8) {\n      print(\"$nama Datang terlambat\");\n    } else {\n      print(\"$nama datang tepat waktu\");\n    }\n  }\n\nTunjangan kita buat arrow function di abstract method tunjangan.\n\n  @override\n    // TODO: implement tunjangan\n    int get tunjangan =&gt; ((2023 - thnMasuk) &lt; 5) ? 50000 : 100000;\n\n\n\n\n\n\nTips\n\n\n\nMenunjukkan kedua method ini override dari class Karyawan. Sebenarnya bebas menggunakan override atau tidak, tetapi itu untuk menunjukkan bahwa class tersebut menggunakan method override dari class karyawan.\n\n\nSyntax dari class StafBiasa akan menjadi seperti ini:\nclass StafBiasa extends Karyawan {\n  StafBiasa(super.npp, super.nama, {thnMasuk = 2015});\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    if (jamMasuk.hour &gt; 8) {\n      print(\"$nama Datang terlambat\");\n    } else {\n      print(\"$nama datang tepat waktu\");\n    }\n  }\n\n  @override\n  // TODO: implement tunjangan\n  int get tunjangan =&gt; ((2023 - thnMasuk) &lt; 5) ? 50000 : 100000;\n}\n\nPastikan codingan benar dan tidak error. Buka karyawan.dart dan ganti abstract Karyawan menjadi StafBiasa.\n\n\n\n\n\n\n\nTips\n\n\n\nKaryawan yang di depan tidak perlu diganti menjadi StafBiasa karena kita tidak memanggil method atau atribut khusus yang hanya ada di StafBiasa. Cukup menggunakan Karyawan saja, karena dia merupakan superclass, hampir sama dengan aturan di java seperti inheritance dan polymorphisme.\n\n\nvoid main(List&lt;String&gt; arguments) {\n  Karyawan staff1 = StafBiasa(\"A123\", \"Lars Bak\");\n  Karyawan staff2 = StafBiasa(\"B123\", \"Kasper Lund\", thnMasuk: 2016);\n  Karyawan staff3 = StafBiasa(\"C123\", \"Denis Ritchie\", thnMasuk: 2020);\n\n  //...\n}\n\nSetelah itu kita jalankan kembali program yang sudah kita modifikasi.\n\n\n\n\n\n\n\nTips\n\n\n\nJika hasilnya tetap sama dengan sebelumnya, maka sudah benar. Jika kita melakukan refactor, seharusnya secara logic dalam pemanggilannya akan tetap sama, hanya strukturnya yang berbeda. Beberapa implementasi method sudah kita taruh di atas, sehingga codingan pada class StafBiasa akan relatif lebih sedikit."
  },
  {
    "objectID": "studi_kasus_1.html#buat-class-pejabat",
    "href": "studi_kasus_1.html#buat-class-pejabat",
    "title": "11  Studi Kasus 1",
    "section": "14.6 Buat Class Pejabat",
    "text": "14.6 Buat Class Pejabat\n\nSekarang kita buat class baru yaitu Pejabat extends dari class Karyawan. Akan terjadi error, karena kita belum implement 2 method dan constructor barunya. Lalu, tambahkan lagi constructor yang kurang yaitu call super.\n\nclass Pejabat extends Karyawan {\n  Pejabat(super.npp, super.nama);\n  @override\n  void presensi(DateTime jamMasuk) {\n    // TODO: implement presensi\n  }\n\n  @override\n  // TODO: implement tunjangan\n  int get tunjangan =&gt; throw UnimplementedError();\n}\n\nAgar class pejabat terlihat perbedaan, tambahkan variabel TipeJabatan yang bertipe data enum. Isilah variable tersebut, misalnya {kabag, manajer, direktur}. Dengan tipe data enum, kita hanya bisa memasukkan 3 tipe jabatan, yaitu kabag, manajer, dan direktur.\n\nenum TipeJabatan {kabag, manajer, direktur};\n\nLalu, taruh TipeJabatan tadi ke dalam class Pejabat dan dalam super constructornya. Jika ingin mengubah thnMasuk, tinggal set menggunakan atribut setter.\n\n\n\n\n\n\n\nTips\n\n\n\nPenggunaan This khusus untuk variabel yang ada di dalam class pejabat, sedangkan super berarti yang diwarisi dari extendnya yaitu class Karyawan.\n\n\nclass Pejabat extends Karyawan {\n  TipeJabatan jabatan;\n\n  Pejabat(super.npp, super.nama, this.jabatan);\n\n  //...\n}\n\nSekarang kita implementasi 2 method. Untuk presensi yang ini ditujukan untuk boss, jadi untuk jamMasuk kita set lebih siang dibanding dengan StafBiasa. Untuk method tunjangan juga diimplementasikan berdasarkan jabatan, sehingga tidak bisa menggunakan arrow, karena akan lebih kompleks.\n\n@override\nvoid presensi(DateTime jamMasuk) {\n  if (jamMasuk.hour &gt; 10) {\n    print(\"$nama pada ${dateFormat.format(jamMasuk)} datang terlambat\");\n  } else {\n    print(\"$nama pada ${dateFormat.format(jamMasuk)} datang tepat waktu\");\n  }\n} \n\n@override\nint get tunjangan {\n  if (jabatan == TipeJabatan.kabag) {\n    return 1500000;\n  } else if (jabatan == TipeJabatan.manajer) {\n    return 2500000;\n  } else {\n    return 5000000;\n  }\n}\nKita telah mendefinisikan atribut baru yaitu jabatan. Kemudian kita juga telah override presensi dan tunjangan karena aturannya sudah beda dan mengimplementasinya dari abstract. Deskripsinya juga harusnya diubah.\n\nSekarang kita melakukan override terhadap deskripsi. Meskipun deskripsi ini bukan merupakan method abstract. Kali ini, kita akan memanggil method yang sudah ada daripada mendefinisikan method baru.\n\n@override\nString deskripsi(){\n  String teks = super.deskripsi();\n  teks += \"Jabatan : $jabatan\";\n  return teks;\n}"
  },
  {
    "objectID": "studi_kasus_1.html#list-of-karyawan",
    "href": "studi_kasus_1.html#list-of-karyawan",
    "title": "11  Studi Kasus 1",
    "section": "14.7 List of Karyawan",
    "text": "14.7 List of Karyawan\n\nJika kita menggunakan cara seperti ini, maka akan sangat repot jika jumlah stafnya sangat banyak. Kita bisa menggunakan list. List jika di Java seperti Array List. Sifatnya list ini tidak statis ukurannya dan dapat bertambah. Kita akan buat List&lt;Karyawan&gt; dan menggunakan add dari dataKaryawan.\n\nvoid main(List&lt;String&gt; arguments) {\n\n  List&lt;Karyawan&gt; dataKaryawan = [];\n  dataKaryawan.add(Pejabat(\"A123\", \"Lars Bak\", TipeJabatan.direktur));\n  dataKaryawan.add(Pejabat(\"B123\", \"Kasper Lund\", TipeJabatan.manajer));\n  dataKaryawan[1].thnMasuk = 2016;\n  dataKaryawan.add(StafBiasa(\"C123\", \"Denis Rithcie\", thnMasuk: 2020));\n\n  dataKaryawan[0].presensi(DateTime.parse('2023-08-08 07:00:00'));\n  dataKaryawan[1].presensi(DateTime.parse('2023-08-08 09:01:01'));\n  dataKaryawan[2].presensi(DateTime.parse('2023-08-08 08:30:00'));\n\n  dataKaryawan[1].gaji = 50000;\n  dataKaryawan[2].gaji = 500000;\n\n  dataKaryawan[0].alamat = \"Semarang, Indonesia\";\n\n  //...\n}\n\n\n\n\n\n\nTips\n\n\n\nJika di Java, ini merupakan kombinasi dari Array List dan Array biasa. Ini lebih simple jika kita menggunakan inheritance begitu yang kita jadikan List itu adalah Super classnya maka kita bisa memasukkan datanya baik itu Pejabat maupun StafBiasa.\n\n\n\nKarena isinya sama semua, kita bisa menggunakan For in jika di Dart atau sama dengan For each jika di Java.\n\nfor (var staff in dataKaryawan) {\n  print(staff.deskripsi());\n}\nSetelah itu, kita jalankan kembali program yang sudah kita update.\n\n\n\nOutput Program List of Karyawan\n\n\n\nTerlihat bug pada bagian jabatan. Jika kita menggunakan variabel sederhana, kita cukup menggunakan $ untuk pemanggilannya. Tetapi, jika variabelnya sudah kompleks seperti melibatkan pemanggilan atribut atau terdapat logika tambahan, maka String interpolationnya setelah $ kita masukkan ke dalam {}. Itu merupakan sebuah aturan jika menggunakan bahasa Dart.\n\nteks += \"\\n Jabatan : ${jabatan.name}\"; \n\nJadi, di class Karyawan ini kita telah menambahkan sub class untuk Pejabat, ada atribut tambahan dan override dari method yang sudah ada. Ini akan kita banyak lakukan nanti misalkan ketika melakukan sub class dari Stateless dan Statefull widget itu yang bisa kita override atau tambahkan atribut baru."
  },
  {
    "objectID": "studi_kasus_1.html#string-formatting",
    "href": "studi_kasus_1.html#string-formatting",
    "title": "11  Studi Kasus 1",
    "section": "14.8 String Formatting",
    "text": "14.8 String Formatting\n\nSebagai tambahan, kita akan merapikan bagian gajinya yaitu number formattingnya dan menambahkan tanggal kedatangan karyawan. Number formatting atau Get formatting bisa kita dapatkan dari library internationalization. Cara menambahkannya yaitu buka file pubspec.yaml dan tambahkan librarynya pada dependencies.\n\n\n\n\npubspec.yaml\n\n\nSetelah ditambahkan, Visual Studio Code akan segera mendownload library tersebut jika terhubung dengan koneksi internet. Maka, kita bisa import library internationalization pada karyawan.dart.\n\nSetelah itu, kita buat variabel baru untuk menyimpan number format dan date format pada karyawan.dart.\n\nvar numFormat = NumberFormat(\"#,000\");\nvar dateFormat = DateFormat('yyyy-MM-dd');\n\nSetelah memiliki variabel number format, kita bisa panggil ke dalam gaji.\n\nGaji:${numFormat.format(gaji)}\"\"\"; \n\nKemudian kita panggil date format pada method presensi yang ada pada class StafBiasa dan Pejabat.\n\nclass StafBiasa extends Karyawan {\n  StafBiasa(super.npp, super.nama, {thnMasuk = 2015});\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    if (jamMasuk.hour &gt; 8) {\n      print(\"$nama pada ${dateFormat.format(jamMasuk)} datang terlambat\");\n    } else {\n      print(\"$nama pada ${dateFormat.format(jamMasuk)} datang tepat waktu\");\n    }\n  }\n\n  //...\n}\nclass Pejabat extends Karyawan {\n  TipeJabatan jabatan;\n\n  Pejabat(super.npp, super.nama, this.jabatan);\n\n  @override\n  void presensi(DateTime jamMasuk) {\n    if (jamMasuk.hour &gt; 10) {\n      print(\"$nama pada ${dateFormat.format(jamMasuk)} datang terlambat\");\n    } else {\n      print(\"$nama pada ${dateFormat.format(jamMasuk)} datang tepat waktu\");\n    }\n  }\n\n  //...\n}\n\n\n\n\n\n\nTips\n\n\n\nSebenarnya bisa langsung memanggil date format hanya dengan variabel jamMasuk, tetapi date format defaultnya terdapat jam, menit, dan detik juga. Jika tidak ingin sepanjang itu, kita menggunakan date format yang ada pada library internationalization. Tampak tadi di awal, kita menggunakan create project with dart dan bukan new file dart. Karena jika langsung membuat file dart, akan susah import sebuah package dari luar."
  },
  {
    "objectID": "studi_kasus_1.html#list-of-map",
    "href": "studi_kasus_1.html#list-of-map",
    "title": "11  Studi Kasus 1",
    "section": "14.9 List of Map",
    "text": "14.9 List of Map\n\nSekarang, kita akan simulasi studi kasus menggunakan Map. Buatlah data dummy terlebih dahulu menggunakan Map.\n\nList&lt;Map&lt;String, dynamic&gt;&gt; dummyData() {\n  List&lt;Map&lt;String, dynamic&gt;&gt; data = [\n    {\n      \"npp\": \"A123\",\n      \"nama\": \"Lars Bak\",\n      \"thn_masuk\": 2017,\n      \"jabatan\": TipeJabatan.direktur,\n      \"alamat\": \"Semarang Indonesia\"\n    },\n    {\n      \"npp\": \"A345\",\n      \"nama\": \"Kasper Lund\",\n      \"thn_masuk\": 2018,\n      \"jabatan\": TipeJabatan.manajer,\n      \"alamat\": \"Semarang Indonesia\"\n    },\n    {\"npp\": \"B231\", \"nama\": \"Guido Van Rossum\", \"alamat\": \"California Amerika\"},\n    {\n      \"npp\": \"B355\",\n      \"nama\": \"Rasmus Lerdorf\",\n      \"thn_masuk\": 2015,\n      \"alamat\": \"Bandung Indonesia\"\n    },\n    {\n      \"npp\": \"B355\",\n      \"nama\": \"Dennis MacAlistair Ritchie\",\n      \"jabatan\": TipeJabatan.kabag,\n      \"alamat\": \"Semarang Indonesia\"\n    }\n  ];\n  return data;\n}\n\n\n\n\n\n\nTips\n\n\n\nKita menggunakan List of Map karena tipe data tersebut sering digunakan untuk mengambil data dari database atau restful service. Map itu seperti Dictionary jika pada Python, keynya berupa String dan valuenya dapat bermacam-macam. Pada kasus ini, kita definisikan valuenya menggunakan tipe data dynamic karena kita belum bisa menentukan tipe datanya. Sehingga, Dart akan menentukan tipe data yang paling cocok untuk digunakan jika kita menggunakan dynamic.\n\n\n\nSetelah itu, kita buat fungsi baru untuk GET data dummy yang telah dibuat tadi. Dan masukkan For each pada fungsi tersebut.\n\nList&lt;Karyawan&gt; genData(var listData) {\n  List&lt;Karyawan&gt; data = [];\n\n  for (var dtPegawai in listData) {\n    Karyawan pegawai;\n    if (dtPegawai.containsKey('jabatan')) {\n      pegawai =\n          Pejabat(dtPegawai['npp'], dtPegawai['nama'], dtPegawai['jabatan']);\n    } else {\n      pegawai = StafBiasa(dtPegawai['npp'], dtPegawai['nama']);\n    }\n\n    if (dtPegawai.containsKey('thn_masuk')) {\n      pegawai.thnMasuk = dtPegawai['thn_masuk'];\n    }\n\n    if (dtPegawai.containsKey('alamat')) {\n      pegawai.alamat = dtPegawai['alamat'];\n    }\n\n    data.add(pegawai);\n  }\n\n  return data;\n}\n\n\n\n\n\n\nTips\n\n\n\nJika kita sudah bisa menentukan tipe data, sebaiknya jangan menggunakan tipe data dynamic. Jika kita menggunakan dynamic compilernya akan berjalan lebih lama karena dia harus menyimpulkan tipe data yang terbaik untuk digunakan. Selain itu, kita akan kehilangan fitur auto complete yang ada di editor.\n\n\n\nJika sudah, hapus dataKaryawan yang lama pada fungsi main dan panggil fungsi baru yaitu genData di dalam fungsi main dan mengaambil dummy data.\n\nvoid main(List&lt;String&gt; arguments) {\n  List&lt;Karyawan&gt; dataKaryawan = genData(dummyData());\n\n  //...\n}\n\nSetelah itu, kita jalankan kembali program yang sudah kita update.\n\n\n\n\nOutput Program Studi Kasus 1"
  },
  {
    "objectID": "konsep.html",
    "href": "konsep.html",
    "title": "Konsep",
    "section": "",
    "text": "Konsep\nLearning path :\n\nPengenalan Flutter\nDasar Pemrograman Dart\nAntarmuka Pengguna\nRouting dan Navigasi\nPengujian dan Debugging\nAkses Data Lokal\nAkses Data melalui API\nIntegrasi Dengan BAas\nLayanan Berbasis Lokasi\nPengamanan Aplikasi"
  },
  {
    "objectID": "1_intro_flutter.html#apa-itu-flutter",
    "href": "1_intro_flutter.html#apa-itu-flutter",
    "title": "1  Pengenalan Flutter",
    "section": "1.1 Apa itu Flutter?",
    "text": "1.1 Apa itu Flutter?\nFlutter adalah sebuah SDK (Software Development Kit) open source yang dikembangkan oleh Google. Tujuan utamanya adalah untuk memudahkan pembuatan aplikasi yang dapat berjalan di berbagai platform, atau yang biasa disebut sebagai multi-platform. Dengan Flutter, pengembang dapat membangun aplikasi untuk sistem operasi Android, iOS, Web, Windows, Linux, dan MacOS dengan menggunakan kode yang sama, tanpa perlu menulis ulang kode secara terpisah. Selain itu, Flutter juga dapat digunakan baik sebagai bagian dari aplikasi native yang sudah ada maupun sebagai dasar pembangunan aplikasi baru."
  },
  {
    "objectID": "1_intro_flutter.html#kelebihan-dan-kekurangan-flutter",
    "href": "1_intro_flutter.html#kelebihan-dan-kekurangan-flutter",
    "title": "1  Pengenalan Flutter",
    "section": "1.2 Kelebihan dan kekurangan Flutter",
    "text": "1.2 Kelebihan dan kekurangan Flutter\n\n1.2.1 kelebihan dari Flutter\n\nFlutter memungkinkan pembuatan aplikasi dengan desain yang indah dan kreatif. Framework ini memberikan kebebasan dalam mengatur desain aplikasi tanpa banyak batasan. Dengan kemampuannya untuk mengontrol setiap piksel di layar, Flutter memudahkan pembuatan animasi yang menarik. Selain itu, Flutter menyediakan beragam komponen material design yang dapat digunakan dengan baik pada platform Android, iOS, dan web.\nFlutter memiliki kinerja yang sangat cepat. Flutter menggunakan mesin grafis bernama Skia-2D, yang juga digunakan oleh Chrome dan Android. Selain itu, kode Flutter ditulis dalam bahasa Dart, yang memungkinkan kompilasi ke kode native 32-bit dan 64-bit ARM untuk iOS dan Android. Dengan demikian, aplikasi Flutter dapat berjalan dengan kinerja tinggi dan responsif.\nFlutter sangat produktif dalam pengembangan aplikasi. Fitur hot-reload yang dimilikinya memungkinkan pengembang untuk melihat perubahan kode secara langsung dan secara real-time. Dengan hot-reload, perubahan yang dilakukan pada kode dapat segera diterapkan pada perangkat tanpa perlu menunggu proses restart dan tanpa kehilangan state aplikasi.\nFlutter adalah proyek open source yang bersifat terbuka. Dengan lisensi BSD, Flutter mendorong partisipasi dari komunitas pengembang di seluruh dunia. Banyak kontributor telah berkontribusi dalam pengembangan Flutter, dan ada banyak plugin yang telah dibuat oleh para pengembang.\n\n\n\n1.2.2 Kekurangan dari Flutter\n\nFlutter masih baru dibandingkan dengan beberapa framework lainnya. Ini berarti bahwa dokumentasi dan sumber daya yang tersedia mungkin belum sebanyak yang tersedia untuk framework yang lebih mapan.\nUkuran file aplikasi Flutter lebih besar dibandingkan dengan aplikasi yang dibangun menggunakan teknologi lain. Ini dapat menjadi masalah dalam situasi di mana ukuran file menjadi perhatian utama, seperti dalam pengembangan aplikasi dengan batasan ruang penyimpanan atau kecepatan internet yang terbatas.\nDukungan untuk beberapa fitur platform mungkin masih terbatas atau belum sepenuhnya matang dalam Flutter. Meskipun Flutter berusaha untuk menyediakan pengalaman yang seragam di berbagai platform, ada kemungkinan bahwa beberapa fitur khusus platform tertentu mungkin tidak sepenuhnya didukung atau membutuhkan upaya lebih dalam implementasinya."
  },
  {
    "objectID": "1_intro_flutter.html#instalasi-flutter-dan-android-studio",
    "href": "1_intro_flutter.html#instalasi-flutter-dan-android-studio",
    "title": "1  Pengenalan Flutter",
    "section": "1.3 Instalasi Flutter dan Android Studio",
    "text": "1.3 Instalasi Flutter dan Android Studio\n\n1.3.1 Instalasi Android Studio\n\nDownload android studio, dapat melalui link berikut\n\n\n\n\nWeb download android studio\n\n\n\n\n\nDownload android studio\n\n\n\n\n\nDownload android studio\n\n\n\n\nInstal android studio, buka file android studio yang telah didownload\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\nSetup wizard android studio, buka android studio yang telah diinstal\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\nAndroid studio berhasil diinstal\n\n\n\n\n1.3.2 Instalasi Flutter\n\nDownload flutter sesuai OS perangkat yang digunakan, dapat melalui link berikut\n\n\n\n\nWeb download flutter\n\n\n\n\n\nWeb download flutter windows\n\n\n\n\n\nDownload flutter\n\n\n\n\nEkstrak file flutter yang telah diunduh, letakkan di lokasi instalasi yang diinginkan, misal di folder (“C:/Src/flutter”)\n\n\n\n\nFolder setup flutter\n\n\n\n\nUpdate path\n\n\nCari “env” di search bar windows, pilih “Edit the system environment variables”\n\n\n\n\nMencari menu system environment variables\n\n\n\n\npilih “environment variables”\n\n\n\n\nMembuka system properties\n\n\n\n\npilih “path” pada “user variables …”\n\n\n\n\nMembuka environment variables\n\n\n\n\nTambahkan alamat folder bin flutter (C:/Src/flutter/bin) pada Path\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\nJika belum ada “Path” pada “user variables”, bisa menambahkan sendiri disertai alamat folder bin flutter (C:/Src/flutter/bin).\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\n\nMenambahkan flutter folder path\n\n\n\n\nCek instalasi flutter\n\n\nBuka terminal, ketik “flutter doctor”, jalankan.\n\n\n\n\nMencari terminal pada menu start\n\n\n\n\n\nMenjalankan flutter doctor\n\n\n\n\nPada hasil ditemukan 2 masalah, atasi masalah sesuai dengan panduan masing-masing masalah (masalah “visual studio …” tidak wajib diatasi)\n\n\n\n\nCek instalasi flutter doctor issue\n\n\n* Cara mengatasi “cmdline-tools component is missing”\n\n\nSetelah masalah diatasi, jalankan “flutter doctor” untuk cek apakah masalah sudah teratasi.\n\n\n\n\nMenjalankan flutter doctor\n\n\n\n\nSet up Android emulator\n\n\nBuka android studio, pilih “titik tiga (:)”, pilih”Virtual Device Manager”\n\n\n\n\nAndroid studio halaman awal\n\n\n\n\nPilih “Create device”\n\n\n\n\nMembuat virtual device pada android studio\n\n\n\n\nPilih perangkat yang diinginkan\n\n\n\n\nMemilih hardware untuk virtual device\n\n\n\n\nPilih system image yang diinginkan\n\n\n\n\nMemilih system image untuk virtual device\n\n\n\n\nPada “emulated performance”, pilih “Hardware-GLES 2.0” untuk mengizinkan hardware acceleration, lalu Finish\n\n\n\n\nMemilih hardwate-GLES untuk virtual device\n\n\n\n\nMenyetujui lisensi android, buka terminal, ketikkan “flutter doctor —android-licenses”, lalu enter\n\n\n\n\nMenyetujui android licenses dengan flutter doctor\n\n\n\n\nJalankan “flutter doctor” pada terminal\n\n\n\n\nMenjalankan flutter doctor\n\n\n\nFlutter berhasil diinstal\n\n\n\n\n1.3.3 Instalasi VSCode\n\nDownload VSCode sesuai dengan OS perangkat yang digunakan, dapat melalui link berikut,\n\n\n\n\nDownload VSCode\n\n\n\n\n\nDownload VSCode\n\n\n\n\nInstal VSCode, buka file VSCode yang telah didownload\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\nVSCode berhasil diinstal\n\n\n\n\n1.3.4 Konfigurasi flutter dan dart di android studio (Windows atau Linux)\n\nBuka android studio, buka salah satu project, pilih “File”, pilih “setting”\n\n\n\n\nMembuka setting android studio\n\n\n\n\nPilih “Plugins”, pilih “Marketplace”, cari “flutter”, lalu install, lalu apply\n\n\n\n\nintall flutter plugin pada android studio\n\n\n\nRestart android studio\n\n\n\n\n1.3.5 Konfigurasi flutter dan dart di VS Code\n\nInstall VSCode jika belum ada\nInstal plugin flutter dan dart\n\n\nBuka VS Code, pilih “view”, pilih”Command Palette”\n\n\n\n\nMembuka command palette pada vs code\n\n\n\nKetik “Install”, pilih “Extensions: Install Extensions”\n\n\n\n\nMemilih menu install extension\n\n\n\nPilih “extensions” → cari “flutter” → lalu instal (otomatis menginstal plugin dart juga)\n\n\n\n\nintall flutter extension pada vscode\n\n\n\n\nValidasi konfigurasi\n\n\nPilih “view” → “command palette”\n\n\n\n\nMembuka command palette\n\n\n\nKetik “flutter” → pilih “Flutter: Run Flutter Doctor”\n\n\n\n\nMenjalankan flutter doctor pada vs code\n\n\n\nTinjau panel output untuk melihat masalah\n\n\n\n\nMeninjau output dari flutter doctor pada vs code\n\n\n\nJika sudah tidaka ada masalah, Environment flutter sudah siap digunakan"
  },
  {
    "objectID": "2_dasar_dart.html#apa-itu-dart",
    "href": "2_dasar_dart.html#apa-itu-dart",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.1 Apa itu Dart?",
    "text": "2.1 Apa itu Dart?\nDart merupakan bahasa pemrograman yang open source yang dikembangkan oleh Google dengan tujuan untuk membuat aplikasi multiplatform seperti mobile, desktop, dan web. Tujuan awal pembuatan Dart adalah untuk menggantikan JavaScript yang dinilai memiliki banyak kelemahan."
  },
  {
    "objectID": "2_dasar_dart.html#menjalankan-dart",
    "href": "2_dasar_dart.html#menjalankan-dart",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.2 Menjalankan Dart",
    "text": "2.2 Menjalankan Dart\nPada Bab ini akan belajar pemrograman dasar menggunakan dart, untuk menjalankan dart bisa menggunakan cara berikut:\n\n2.2.1 Menggunakan VSCode\n\nBuka VSCode\n\n\n\n\nBuka VSCode\n\n\n\nBuat/buka folder, pilih “File”, pilih “Open Folder”, pilih lokasi penyimpanan, pilih “Select Folder”\n\n\n\n\nBuat/Buka Folder\n\n\n\n\n\nPilih Folder\n\n\n\n\n\nFolder dibuka\n\n\n\nBuat file baru, klik simbol “New file”, ketik “[nama file].dart”, lalu enter\n\n\n\n\nBuat file dart baru\n\n\n\nKetik program dart\n\nvoid main() {\nprint('Hello, World\n  !');\n}\n\n\n\nKetik program dart\n\n\n\nJalankan program, klik “Run Code”, maka akan muncul hasilnya di output\n\n\n\n\nJalankan program\n\n\n\n\n\nHasil program\n\n\n\n\n\n2.2.2 Menggunakan DartPad\n\nBuka Dartpad, dapat melalui link berikut\n\n\n\n\nBuka DartPad\n\n\n\nKetik program dart\n\nvoid main() {\n  print('Hello, World\n    !');\n}\n\n\n\nKetik program dart\n\n\n\nJalankan program, klik “Run”, maka akan muncul hasilnya di console\n\n\n\n\nJalankan program"
  },
  {
    "objectID": "2_dasar_dart.html#tipe-data-dan-variabel",
    "href": "2_dasar_dart.html#tipe-data-dan-variabel",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.3 Tipe data dan Variabel",
    "text": "2.3 Tipe data dan Variabel\n\n2.3.1 Variabel\nDalam dart, variabel dapat dideklarasikan secara eksplisit maupun implisit.\n\n2.3.1.1 Deklarasi eksplisit\nDeklarasi secara eksplisit dilakukan dengan cara menambahkan tipe data di depan nama variabel.\nString greetings = 'Hello World!';  // String\nint myAge = 20;                     // integers\nbool isHuman = true;                // boolean\n\n\n2.3.1.2 Deklarasi implisit\nDeklarasi secara implisit dilakukan dengan cara menambahkan kata kunci var di depan nama variabel. Sebagai bahasa yang memiliki fitur type inference dart dapat menentukan tipe data otomatis dengan kata kunci var.\nvar greetings = 'Hello World!';     // String\nvar myAge = 20;                     // integers\nvar isHuman = true;                 // boolean\n\n\n\n2.3.2 Tipe data\nSebagai tambah berikut adalah tabel berbagai jenis tipe data yang dapat digunakan dalam bahasa pemrograman Dart beserta deskripsi dan contoh singkatnya:\n\n\n\n\n\n\n\n\nTipe\nDekripsi\nContoh\n\n\n\n\nint\nBilangan bulat\n5, 7, 8\n\n\ndouble\nBilangan desimal\n3.14, 1.23\n\n\nnum\nBilangan bulat dan bilangan desimal\n5, 3.14, -99.00\n\n\nbool\nBoolean\ntrue, false\n\n\nString\nTeks yang terdiri dari 0 atau beberapa karakter\n“udinus”, ““,”G”\n\n\nList\nDaftar nilai\n[1, 2, 3], [‘a’, ‘b’, ‘c’]\n\n\nMap\nPasangan key-value\n{“x”: 4, “y”: 10}\n\n\ndynamic\nTipe data apa pun"
  },
  {
    "objectID": "2_dasar_dart.html#control-flow-kondisi-dan-perulangan",
    "href": "2_dasar_dart.html#control-flow-kondisi-dan-perulangan",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.4 Control Flow (Kondisi dan Perulangan)",
    "text": "2.4 Control Flow (Kondisi dan Perulangan)\n\n2.4.1 Kondisi\nSaat membuat atau mengembangkan sebuah program, terdapat situasi di mana aliran eksekusi bercabang berdasarkan kondisi tertentu. Dalam bahasa Dart, terdapat tiga kata kunci yang dapat digunakan untuk mengakomodasi dan menguji kondisi tersebut, yaitu if, if-else, dan switch.\n\n2.4.1.1 If\nStruktur\n// if\n\nif (kondisi) {\n    // Tindakan jika kondisi benar\n} \nContoh penggunaan\nvoid main(){\n  int x = 10;\n\n  if (x &lt; 20) {\n    print('Nilai x kurang dari 20');\n  }\n}\nOutput\n\n\n\nOutput If\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel x dengan nilai 10. Mengecek apakah nilai x kurang dari 20. Jika kondisi terpenuhi, program akan mencetak teks “Nilai x kurang dari 20”. Jika kondisi tidak terpenuhi, program akan melanjutkan eksekusi tanpa mencetak apa pun. Dengan demikian, program ini memberikan pesan “Nilai x kurang dari 20” hanya jika nilai x benar-benar kurang dari 20.\n\n\n\n\n2.4.1.2 If-Else\nStruktur\n// if-else\n\nif (kondisi) {\n    // Tindakan jika kondisi benar\n} else {\n    // Tindakan jika kondisi salah\n}\nContoh penggunaan\nvoid main(){\n  int x = 30;\n\n  if (x &lt; 20) {\n    print('Nilai x kurang dari 20');\n  } else {\n    print('Nilai x lebih besar atau sama dengan 20');\n  }\n}\nOutput\n\n\n\nOutput If-Else\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel x dengan nilai 30. Mengecek apakah nilai x kurang dari 20. Jika kondisi terpenuhi, program akan mencetak teks “Nilai x kurang dari 20”. Jika kondisi tidak terpenuhi, program akan mencetak teks “Nilai x lebih besar atau sama dengan 20”. Dengan demikian, program ini memberikan pesan berdasarkan nilai x. Jika nilai x kurang dari 20, maka program akan mencetak “Nilai x kurang dari 20”. Jika nilai x lebih besar atau sama dengan 20, maka program akan mencetak “Nilai x lebih besar atau sama dengan 20”.\n\n\n\n\n2.4.1.3 Switch\nStruktur\n// switch\n\nswitch (nilai) {\n    case 1:\n        // Tindakan jika nilai sama dengan 1\n        break;\n    case 2:\n        // Tindakan jika nilai sama dengan 2\n        break;\n    default:\n        // Tindakan jika nilai tidak sama dengan kasus di atas\n}\nContoh penggunaan\nvoid main(){\n  int nilai = 75;\n\n  switch (nilai) {\n    case 80:\n      print('Nilai A');\n      break;\n    case 70:\n      print('Nilai B');\n      break;\n    case 60:\n      print('Nilai C');\n      break;\n    default:\n      print('Nilai D atau E');\n      break;\n  }     \n}\nOutput\n\n\n\nOutput Switch\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel nilai dengan nilai 75. Menggunakan struktur switch untuk memilih pernyataan berdasarkan nilai nilai. Memeriksa nilai nilai terhadap beberapa kasus menggunakan pernyataan case. Jika nilai nilai sama dengan 80, program akan mencetak “Nilai A”. Jika nilai nilai sama dengan 70, program akan mencetak “Nilai B”. Jika nilai nilai sama dengan 60, program akan mencetak “Nilai C”. Jika nilai nilai tidak sama dengan kasus-kasus di atas, program akan menjalankan pernyataan default dan mencetak “Nilai D atau E”. Dengan demikian, program ini mencetak pesan berdasarkan nilai yang disimpan dalam variabel nilai.\n\n\n\n\n\n2.4.2 Perulangan\nSaat membuat atau mengembangkan sebuah program, terdapat situasi di mana program melakukan hal yang sama berkali-kali. Dart memiliki banyak opsi untuk melakukan perulangan kode, seperti for loop, while loop, do-while, dan for-each.\n\n2.4.2.1 For loop\nStruktur\nfor (var i = 0; i &lt; length; i++) {\n  // kode yang akan dieksekusi pada setiap iterasi\n}\nContoh penggunaan\nvoid main(){\n  for (var i = 1; i &lt;= 5; i++) {\n    print('Perulangan ke-$i');\n  }\n}\nOutput\n\n\n\nOutput For loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan for untuk menjalankan blok kode di dalamnya. Menentukan kondisi perulangan i &lt;= 5, yang berarti perulangan akan berlangsung selama i kurang dari atau sama dengan 5. Setiap iterasi perulangan, program akan mencetak teks “Perulangan ke-[nilai i]” ke output. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah setiap iterasi, nilai i akan bertambah 1 menggunakan operator ++. Setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi, perulangan akan berakhir. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah.\n\n\n\n\n2.4.2.2 While loop\nStruktur\nwhile (condition) {\n  // kode yang akan dieksekusi pada setiap iterasi\n}\nContoh penggunaan\nvoid main(){\n  var i = 1;\n\n  while (i &lt;= 5) {\n    print('Perulangan ke-$i');\n    i++;\n  }\n}\nOutput\n\n\n\nOutput While loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan while untuk menjalankan blok kode di dalamnya. Menentukan kondisi perulangan i &lt;= 5, yang berarti perulangan akan berlangsung selama i kurang dari atau sama dengan 5. Di setiap iterasi perulangan, program akan mencetak teks “Perulangan ke-[nilai i]” ke output. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah mencetak pesan, nilai i akan bertambah 1 menggunakan operator ++. Setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi, perulangan akan berakhir. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah.\n\n\n\n\n2.4.2.3 Do-While\nStruktur\ndo {\n  // kode yang akan dieksekusi pada setiap iterasi\n} while (condition);\nContoh penggunaan\nvoid main(){\n  var i = 1;\n\n  do {\n    print('Perulangan ke-$i');\n    i++;\n  } while (i &lt;= 5);\n}\nOutput\n\n\n\nOutput Do-While\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan do-while untuk menjalankan blok kode di dalamnya. Di dalam blok kode, program akan mencetak teks “Perulangan ke-[nilai i]” ke output menggunakan pernyataan print. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah mencetak pesan, nilai i akan bertambah 1 menggunakan operator ++. Setelah setiap iterasi, program akan mengevaluasi kondisi perulangan while (i &lt;= 5). Jika kondisi tersebut benar (true), perulangan akan berlanjut dan blok kode akan diulang. Perulangan akan berhenti setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah. Meskipun kondisi perulangan tidak terpenuhi pada iterasi ke-6, perulangan do-while memastikan bahwa setidaknya satu iterasi dilakukan sebelum mengevaluasi kondisi.\n\n\n\n\n2.4.2.4 For-each\nStruktur\nlist.forEach((element) {\n  // kode yang akan dieksekusi pada setiap elemen\n});\nContoh penggunaan\nvoid main(){\n  var fruits = ['apel', 'jeruk', 'mangga'];\n\n  fruits.forEach((fruit) {\n    print(fruit);\n  });\n}\nOutput\n\n\n\nOutput For-each\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel fruits sebagai sebuah list yang berisi beberapa elemen, yaitu ‘apel’, ‘jeruk’, dan ‘mangga’. Menggunakan metode forEach pada list fruits untuk melakukan iterasi pada setiap elemen dalam list. Di dalam blok kode forEach, program akan mencetak nilai setiap elemen ke output menggunakan pernyataan print. Setelah mencetak nilai elemen, program akan melanjutkan ke elemen selanjutnya hingga semua elemen dalam list fruits selesai diproses. Dengan demikian, program ini akan mencetak nilai setiap elemen dalam list fruits (‘apel’, ‘jeruk’, ‘mangga’), masing-masing pada baris yang terpisah."
  },
  {
    "objectID": "2_dasar_dart.html#pembuatan-fungsi",
    "href": "2_dasar_dart.html#pembuatan-fungsi",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.5 Pembuatan Fungsi",
    "text": "2.5 Pembuatan Fungsi\nFungsi dalam Dart digunakan untuk mengelompokkan dan mengorganisir blok kode yang dapat digunakan secara berulang. Fungsi tersebut dapat menerima parameter input, melakukan tindakan tertentu, dan mengembalikan nilai balik (return value) jika diperlukan. Berikut macam-macam fungsi beserta pendeklarasian dan pemanggilan sebuah fungsi dalam Dart:\n\n2.5.1 Fungsi Void / tanpa nilai pengembalian\nFungsi void tidak mengembalikan nilai apapun. Fungsi ini biasanya digunakan untuk melakukan tugas-tugas tertentu, seperti mencetak sesuatu ke konsol, atau mengubah nilai variabel global.\nStruktur\nvoid namaFungsi() {\n    // kode yang akan dieksekusi \n}\nnamaFungsi();\nContoh penggunaan\nvoid main(){\n  void printHello() {\n      print('Hello');\n  }\n  printHello();\n}\nOutput\n\n\n\nOutput Fungsi Void\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printHello() yang tidak memiliki parameter dan tidak mengembalikan nilai (void). Di dalam fungsi printHello(), program mencetak teks “Hello” ke output menggunakan pernyataan print. Setelah mendefinisikan fungsi printHello(), program memanggil fungsi tersebut dengan menggunakan pernyataan printHello(). Pemanggilan fungsi printHello() menjalankan kode di dalam fungsi dan mencetak teks “Hello” ke output. Dengan demikian, program ini mencetak pesan “Hello” ke output ketika fungsi printHello() dipanggil.\n\n\n\n\n2.5.2 Fungsi dengan nilai pengembalian\nFungsi dengan nilai pengembalian mengembalikan nilai tertentu setelah dieksekusi. Contoh tipe data pengembalian yang sering digunakan adalah int, double, String, atau bool.\nStruktur\nTipeNilaiBalik namaFungsi(TipeParameter parameter1, \n                          TipeParameter parameter2) {\n    return nilaiBalik;\n}\nnamaFungsi();\nContoh penggunaan\nvoid main(){\n  int tambah(int a, int b) {\n      return a + b;\n  }\n  print(tambah(1, 1));\n}\nOutput\n\n\n\nOutput Fungsi dengan nilai pengembalian\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama tambah yang mengambil dua parameter bertipe integer, a dan b, dan mengembalikan hasil penjumlahan dari kedua parameter tersebut. Di dalam fungsi tambah, program menggunakan pernyataan return untuk mengembalikan nilai hasil penjumlahan a + b. Setelah mendefinisikan fungsi tambah, program mencetak hasil pemanggilan fungsi tambah(1, 1) ke output menggunakan pernyataan print. Pemanggilan fungsi tambah(1, 1) mengambil argumen 1 dan 1, kemudian menjalankan kode di dalam fungsi tambah dan mengembalikan hasil penjumlahan 1 + 1. Hasil penjumlahan tersebut kemudian dicetak ke output menggunakan pernyataan print. Dengan demikian, program ini mencetak hasil penjumlahan dari angka 1 dan 1, yaitu 2, ke output.\n\n\n\n\n2.5.3 Fungsi dengan parameter opsional bernama\nFungsi dengan parameter opsional memungkinkan kita untuk memanggil fungsi tanpa harus memberikan nilai pada semua parameter.\nStruktur\nvoid namaFungsi(TipeParameter parameter1, {\n                TipeParameter parameter2 = NilaiParameter, \n                TipeParameter parameter3 = NilaiParameter}) {\n    //Kode yang akan dieksekusi\n}\nnamaFungsi(parameter1);\nnamaFungsi(parameter1, parameter2: NilaiParameter);\nnamaFungsi(parameter1, parameter3: NilaiParameter);\nnamaFungsi(parameter1, parameter2: NilaiParameter, \n          parameter3: NilaiParameter);\nContoh penggunaan\nvoid main(){\n  void printPerson(String name, {int age = 18, \n                                String address = 'Unknown'}) {\n      print('Name: $name');\n    if (age \n      != null) {\n      print('Age: $age');\n      }\n    if (address \n      != null) {\n      print('Address: $address');\n      }\n  }\n  printPerson('John Doe', age: 30, address: '123 Main St');\n  print(\"\");\n  printPerson('John Doe', address: '123 Main St');\n  print(\"\");\n  printPerson('Jane Doe', age: 25);\n  print(\"\");\n  printPerson('Mark Smith');\n}\nOutput\n\n\n\nOutput Fungsi dengan parameter opsional bernama\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printPerson yang mengambil tiga parameter, yaitu name (String), age (int), dan address (String). Parameter age dan address memiliki nilai default masing-masing 18 dan ‘Unknown’. Di dalam fungsi printPerson, program mencetak nilai name menggunakan pernyataan print(‘Name: $name’). Program juga memeriksa apakah nilai age tidak null. Jika tidak null, maka nilai age akan dicetak menggunakan pernyataan print(‘Age: $age’). Program juga memeriksa apakah nilai address tidak null. Jika tidak null, maka nilai address akan dicetak menggunakan pernyataan print(‘Address: $address’). Setelah mendefinisikan fungsi printPerson, program memanggil fungsi tersebut dengan berbagai argumen untuk menguji fungsionalitasnya. Pemanggilan fungsi printPerson pada baris 13 menghasilkan output: “Name: John Doe”, “Age: 30”, dan “Address: 123 Main St”. Pemanggilan fungsi printPerson pada baris 15 menghasilkan output: “Name: John Doe” dan “Address: 123 Main St”. Pemanggilan fungsi printPerson pada baris 17 menghasilkan output: “Name: Jane Doe” dan “Age: 25”. Pemanggilan fungsi printPerson pada baris 19 menghasilkan output: “Name: Mark Smith” dan “Age: 18” (dengan nilai default karena tidak ada nilai address yang diberikan). Dengan demikian, program ini mencetak informasi tentang seseorang, yaitu nama, usia, dan alamat, dengan memanfaatkan parameter opsional dan nilai default pada fungsi printPerson.\n\n\n\n\n2.5.4 Fungsi dengan parameter opsional dinamis\nFungsi dengan parameter opsional dinamis memungkinkan kita untuk memanggil fungsi dengan jumlah parameter yang berbeda-beda setiap kali dipanggil.\nStruktur\nvoid namaFungsi(TipeParameter parameter1, [\n                TipeParameter parameter2 = NilaiParameter, \n                TipeParameter parameter3 = NilaiParameter]) {\n    //Kode yang akan dieksekusi\n}\nnamaFungsi(parameter1);\nnamaFungsi(parameter1, parameter2);\nnamaFungsi(parameter1, parameter3);\nnamaFungsi(parameter1, parameter2, parameter3);\nContoh penggunaan\nvoid main(){\n  void printLocation(String city, [String country = 'Indonesia']) {\n      print('Location: $city');\n    if (country \n      != null) {\n          print('Country: $country');\n      }\n  }\n  printLocation('Jakarta');\n  print(\"\");\n  printLocation('New York', 'USA');\n}\nOutput\n\n\n\nOutput Fungsi dengan parameter opsional dinamis\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printLocation yang mengambil dua parameter, yaitu city (String) dan country (String). Parameter country memiliki nilai default ‘Indonesia’ jika tidak diberikan argumen saat pemanggilan fungsi. Di dalam fungsi printLocation, program mencetak nilai city menggunakan pernyataan print(‘Location: $city’). Program juga memeriksa apakah nilai country tidak null. Jika tidak null, maka nilai country akan dicetak menggunakan pernyataan print(‘Country: $country’). Setelah mendefinisikan fungsi printLocation, program memanggil fungsi tersebut dengan berbagai argumen untuk menguji fungsionalitasnya. Pemanggilan fungsi printLocation pada baris 10 hanya memberikan argumen city dengan nilai ‘Jakarta’. Output yang dihasilkan adalah: “Location: Jakarta” dan “Country: Indonesia” (dengan nilai default karena tidak ada argumen country yang diberikan). Pemanggilan fungsi printLocation pada baris 12 memberikan argumen city dengan nilai ‘New York’ dan argumen country dengan nilai ‘USA’. Output yang dihasilkan adalah: “Location: New York” dan “Country: USA”. Dengan demikian, program ini mencetak informasi tentang lokasi, yaitu kota dan negara (dengan nilai default ‘Indonesia’ jika negara tidak diberikan), dengan menggunakan parameter opsional dan nilai default pada fungsi printLocation.\n\n\n\n\n2.5.5 Fungsi anonim\nFungsi anonim adalah fungsi yang tidak memiliki nama dan biasanya digunakan sebagai argumen pada fungsi lain atau dalam ekspresi.\nContoh penggunaan\nvoid main(){\n  var numbers = [1, 2, 3, 4, 5];\n  numbers.forEach((number) =&gt; print(number * 2));\n}\nOutput\n\n\n\nOutput Fungsi anonim\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel numbers sebagai list yang berisi angka-angka. Menggunakan metode forEach pada list numbers untuk melakukan iterasi pada setiap elemen dalam list. Di setiap iterasi, program akan mencetak hasil perkalian elemen dengan 2 ke output menggunakan lambda function (number) =&gt; print(number * 2). Lambda function tersebut mengambil parameter number, dan mencetak hasil perkalian number dengan 2 ke output menggunakan pernyataan print. Setelah mencetak hasil perkalian untuk setiap elemen, iterasi berlanjut hingga semua elemen dalam list numbers selesai diproses. Dengan demikian, program ini akan mencetak hasil perkalian setiap elemen dalam list numbers dengan 2 ke output, masing-masing pada baris yang terpisah. Contohnya, jika numbers adalah [1, 2, 3, 4, 5], maka output yang dihasilkan adalah: 2 4 6 8 10"
  },
  {
    "objectID": "2_dasar_dart.html#class-dan-objek",
    "href": "2_dasar_dart.html#class-dan-objek",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.6 Class dan Objek",
    "text": "2.6 Class dan Objek\nSebagai sebuah bahasa pemrograman yang mendukung konsep OOP (Object-Oriented Programming), Dart menyediakan fitur untuk membuat class. Class dalam Dart berfungsi sebagai sebuah cetak biru (blueprint) untuk membuat objek. Di dalam class, kita dapat mendefinisikan sifat-sifat (attribute) dan perilaku-perilaku (behavior) yang akan dimiliki oleh objek yang akan kita buat.\nDalam Dart, attribute objek didefinisikan menggunakan variabel, sedangkan behavior objek seringkali direpresentasikan sebagai fungsi. Untuk mendeklarasikan sebuah class dalam Dart, kita menggunakan kata kunci class.\nBerikut ini adalah contoh pendeklarasian class, attribute, dan behavior dalam Dart:\nStruktur\nclass namaClass {   //Class\n    TipeAtribut namaAtribut;    //Attribute\n\n    TipeNilaiBalik namaFungsi() {}  //Behavior\n}\nContoh penggunaan\nclass Person {\n  String name = \"\";\n  int age = 0;\n\n  void sayHello() {\n    print('Hello, my name is $name and I am $age years old.');\n  }\n}\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nProperti name yang bertipe String dan diinisialisasi dengan nilai string kosong (““).\nProperti age yang bertipe int dan diinisialisasi dengan nilai 0.\nMetode sayHello() yang tidak mengambil parameter dan tidak mengembalikan nilai (void). Di dalam metode ini, program mencetak pesan “Hello, my name is [nilai name] and I am [nilai age] years old.” ke output. [nilai name] dan [nilai age] akan digantikan dengan nilai aktual dari properti name dan age.\nJadi, kelas Person digunakan untuk merepresentasikan entitas manusia dengan properti name dan age, serta memiliki metode sayHello() untuk mencetak pesan salam.\n\n\nSelanjutnya adalah cara membuat sebuah objek dari suatu class, mengakses atribut, dan menggunakan method:\nStruktur\nNamaClass namaObjek = NamaClass();\nnamaObjek.namaAtribut;\nnamaObjek.namaMethod();\nContoh penggunaan\nvoid main() {\n  Person person1 = new Person();\n  person1.name = 'John';\n  person1.age = 30;\n  person1.sayHello(); \n}\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMembuat instance dari kelas Person dengan menggunakan sintaks Person person1 = new Person();. Ini membuat objek baru dari kelas Person dan menetapkan referensinya ke variabel person1.\nMenggunakan operator titik (dot) untuk mengakses properti name dan age dari objek person1 dan mengatur nilainya. Di dalam program ini, properti name diatur menjadi ‘John’ dan properti age diatur menjadi 30.\nMemanggil metode sayHello() pada objek person1 menggunakan sintaks person1.sayHello(). Ini menjalankan kode di dalam metode sayHello() dari objek person1 dan mencetak pesan salam yang mencakup nilai properti name dan age.\nDengan demikian, program ini menciptakan objek person1 dari kelas Person, mengatur nilai properti name dan age pada objek tersebut, dan kemudian memanggil metode sayHello() untuk mencetak pesan salam dengan nama dan usia yang ditentukan. Dalam contoh ini, program akan mencetak “Hello, my name is John and I am 30 years old.” ke output.\n\n\nVersi lengkapnya\nclass Person {\n  String name = \"\";\n  int age = 0;\n\n  void sayHello() {\n    print('Hello, my name is $name and I am $age years old.');\n  }\n}\n\nvoid main() {\n  Person person1 = new Person();\n  person1.name = 'John';\n  person1.age = 30;\n  person1.sayHello(); \n}\nOutput\n\n\n\nOutput Class dan Objek\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Person dengan dua properti, yaitu name yang bertipe String dan diinisialisasi dengan string kosong (““) serta age yang bertipe int dan diinisialisasi dengan nilai 0. Kelas ini juga memiliki metode sayHello() yang mencetak pesan salam dengan menggunakan nilai properti name dan age.\nDi dalam fungsi main(), program membuat instance dari kelas Person dengan menggunakan sintaks Person person1 = new Person();. Objek baru dari kelas Person diciptakan dan disimpan dalam variabel person1.\nMenggunakan operator titik (dot) untuk mengakses properti name dan age dari objek person1 dan mengatur nilainya. Properti name diatur menjadi ‘John’ dan properti age diatur menjadi 30.\nMemanggil metode sayHello() pada objek person1 menggunakan sintaks person1.sayHello(). Metode sayHello() dijalankan dan mencetak pesan salam ke output dengan menggunakan nilai properti name dan age yang telah ditetapkan sebelumnya.\nDengan demikian, program ini menciptakan objek person1 dari kelas Person, mengatur nilai properti name dan age pada objek tersebut, dan kemudian memanggil metode sayHello() untuk mencetak pesan salam dengan nama dan usia yang ditentukan. Output yang dihasilkan adalah “Hello, my name is John and I am 30 years old.”"
  },
  {
    "objectID": "2_dasar_dart.html#pewarisan-dan-polimorfisme",
    "href": "2_dasar_dart.html#pewarisan-dan-polimorfisme",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.7 Pewarisan dan Polimorfisme",
    "text": "2.7 Pewarisan dan Polimorfisme\n\n2.7.1 Pewarisan\nPewarisan atau Inheritance adalah kemampuan suatu program untuk membuat kelas baru berdasarkan kelas yang sudah ada. Konsep inheritance dapat dibayangkan layaknya seorang anak mewarisi sifat dari orang tuanya. Di dalam OOP kelas yang menurunkan sifat disebut sebagai kelas induk (parent class/superclass) sementara kelas yang mewarisi kelas induknya disebut sebagai kelas anak (child class/subclass). Dalam dart pewarisan dapat dideklarasikan sebagai berikut:\nStruktur\nclass ParentClass {\n    void parentMethod() {}\n}\n\nclass ChildClass extends ParentClass {\n    void childMethod() {}\n}\n\nChildClass childObj = ChildClass();\nchildObj.parentMethod(); // Memanggil metode dari kelas induk\nchildObj.childMethod(); // Memanggil metode dari kelas anak\nContoh penggunaan\nclass Vehicle {\n  void start() {\n    print('Vehicle started');\n  }\n}\n\nclass Car extends Vehicle {\n  void drive() {\n    print('Car is being driven');\n  }\n}\n\nvoid main() {\n  var car = Car();\n  car.start();\n  car.drive();\n}\nOutput\n\n\n\nOutput Pewarisan\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Vehicle dengan metode start(). Metode ini mencetak pesan “Vehicle started” ke output.\nMendefinisikan kelas Car yang merupakan turunan dari kelas Vehicle menggunakan kata kunci extends. Kelas Car memiliki metode tambahan yaitu drive(), yang mencetak pesan “Car is being driven” ke output.\nDi dalam fungsi main(), program membuat instance dari kelas Car menggunakan sintaks var car = Car();. Objek baru dari kelas Car diciptakan dan disimpan dalam variabel car.\nMenggunakan operator titik (dot) untuk mengakses metode start() pada objek car menggunakan sintaks car.start(). Metode start() dari kelas Vehicle dijalankan dan mencetak pesan “Vehicle started” ke output.\nMenggunakan operator titik (dot) juga untuk mengakses metode drive() pada objek car menggunakan sintaks car.drive(). Metode drive() dari kelas Car dijalankan dan mencetak pesan “Car is being driven” ke output.\nDengan demikian, program ini menunjukkan penggunaan pewarisan (inheritance) dalam Dart, di mana kelas Car mewarisi metode start() dari kelas Vehicle dan memiliki metode tambahan drive(). Objek car dapat memanggil metode start() dan drive() untuk mencetak pesan yang sesuai ke output. Output yang dihasilkan adalah:\nVehicle started Car is being driven\n\n\n\n\n2.7.2 Polimorfisme\nPolimorfisme adalah konsep di mana suatu objek dapat muncul dalam berbagai bentuk atau tipe. Dalam konteks Dart, polimorfisme memungkinkan penggunaan objek dari kelas turunan sebagai objek dari kelas induknya, sehingga objek-objek tersebut dapat diperlakukan secara umum tanpa perlu mengetahui tipe spesifik dari objek.\nBerikut adalah contoh sederhana untuk pendeklarasian polimorfisme dalam Dart:\nStruktur\nclass Shape {\n    void draw() {}\n}\n\nclass Circle extends Shape {\n    @override\n    void draw() {}\n}\n\nclass Rectangle extends Shape {\n    @override\n    void draw() {}\n}\n\nList&lt;Shape&gt; shapes = [Circle(), Rectangle()];\n\nfor (var shape in shapes) {\n    shape.draw(); // Polimorfisme terjadi di sini\n}\nContoh penggunaan\nclass Hewan {\n  void makan() {\n    print('Hewan sedang makan');\n  }\n}\n\nclass Kucing extends Hewan {\n  @override\n  void makan() {\n    print('Kucing sedang makan ikan');\n  }\n}\n\nclass Anjing extends Hewan {\n  @override\n  void makan() {\n    print('Anjing sedang makan daging');\n  }\n}\n\nvoid main() {\n  Hewan hewan1 = new Kucing();\n  Hewan hewan2 = new Anjing();\n  \n  hewan1.makan(); // Output: Kucing sedang makan ikan\n  hewan2.makan(); // Output: Anjing sedang makan daging\n}\nOutput\n\n\n\nOutput Polimorfisme\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Hewan dengan metode makan(). Metode ini mencetak pesan “Hewan sedang makan” ke output.\nMendefinisikan kelas Kucing yang merupakan turunan dari kelas Hewan menggunakan kata kunci extends. Kelas Kucing menggunakan anotasi @override untuk menandakan bahwa metode makan() dalam kelas Kucing akan menggantikan (override) metode makan() yang ada di kelas Hewan. Metode makan() dalam kelas Kucing mencetak pesan “Kucing sedang makan ikan” ke output.\nMendefinisikan kelas Anjing yang juga merupakan turunan dari kelas Hewan. Seperti pada kelas Kucing, kelas Anjing menggunakan anotasi @override untuk menggantikan metode makan() di kelas Hewan. Metode makan() dalam kelas Anjing mencetak pesan “Anjing sedang makan daging” ke output.\nDi dalam fungsi main(), program membuat objek hewan1 dan hewan2 yang bertipe Hewan namun diinisialisasi sebagai objek Kucing dan Anjing secara berturut-turut.\nMenggunakan operator titik (dot) untuk memanggil metode makan() pada objek hewan1 dan hewan2. Karena metode makan() telah digantikan (override) dalam kelas Kucing dan Anjing, pemanggilan metode makan() pada objek hewan1 akan mencetak pesan “Kucing sedang makan ikan” ke output, sedangkan pemanggilan metode makan() pada objek hewan2 akan mencetak pesan “Anjing sedang makan daging” ke output.\nDengan demikian, program ini menunjukkan penggunaan overriding metode dalam Dart, di mana metode makan() dalam kelas Kucing dan Anjing menggantikan metode makan() yang ada dalam kelas Hewan. Output yang dihasilkan adalah:\nKucing sedang makan ikan Anjing sedang makan daging"
  },
  {
    "objectID": "2_dasar_dart.html#studi-kasus",
    "href": "2_dasar_dart.html#studi-kasus",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.8 Studi Kasus",
    "text": "2.8 Studi Kasus\n\nStudi Kasus 1: Pengelolaan Data Karyawan"
  },
  {
    "objectID": "3_user_interface.html#widget",
    "href": "3_user_interface.html#widget",
    "title": "3  Antarmuka Pengguna",
    "section": "3.1 Widget",
    "text": "3.1 Widget\nWidget pada Flutter merupakan elemen dasar dalam membangun antarmuka pengguna (UI). Dalam Flutter, hampir semua komponen yang berada di layar adalah widget, termasuk tombol, teks, gambar, kotak, daftar, dan sebagainya. Berikut merupakan widget yang umum digunakan dalam flutter :\n\n3.1.1 Scaffold\nWidget yang digunakan untuk membuat tampilan dasar aplikasi Flutter. Memiliki 3 bagian yaitu AppBar, Body, dan FloatingActionButton.\nScaffold(\n    appBar: AppBar(\n        title: const Text('First Screen'),\n        actions: [\n            IconButton(\n                icon: const Icon(\n                Icons.search,\n                color: Colors.white,\n                ),\n                onPressed: () {},\n            ),\n        ],\n        leading: IconButton(\n            icon: const Icon(\n                Icons.menu,\n                color: Colors.white,\n        ),\n            onPressed: () {},\n        ),\n    ),\n    body: const Center(\n        child: Text('Hello world!'),\n    ),\n    floatingActionButton: FloatingActionButton(\n        child: const Icon(Icons.add),\n        onPressed: () {},\n    ),\n);\n\n\n\nAppbar Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nappBar: AppBar(...): Ini adalah bagian yang mendefinisikan AppBar (bilah aplikasi) di atas tampilan utama. Di dalam AppBar, kita menentukan judul dengan menggunakan widget Text. Selain itu, ada juga dua tombol ikon yang ditempatkan di sebelah kanan dan kiri AppBar. Tombol ikon kanan menggunakan IconButton dengan ikon Icons.search, sedangkan tombol ikon kiri menggunakan IconButton dengan ikon Icons.menu.\nbody:... : Ini adalah bagian yang mendefinisikan konten utama dari tampilan aplikasi.\nfloatingActionButton: FloatingActionButton(...) : Ini adalah bagian yang mendefinisikan tombol aksi mengambang (floating action button) di sudut kanan bawah tampilan. Menggunakan widget FloatingActionButton dan menentukan ikon dengan Icon(Icons.add).\n\n\n\n\n\n3.1.2 Container\nWidget yang digunakan untuk melakukan styling, membuat sebuah shape (bentuk), dan layout pada widget child-nya.\nContainer(\n    alignment: Alignment.center,\n    width: 300,\n    height: 300,\n    color: Colors.blue,\n    padding: const EdgeInsets.all(10),\n    margin: const EdgeInsets.all(10),\n    child: const Text(\n    'Hello',\n    ),\n),\n\n\n\nContainer Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nalignment:...: Properti ini mengatur posisi atau penempatan konten di dalam container.\nwidth:..., height:...: Properti ini mengatur lebar (width) dan tinggi (height) dari container.\ncolor:...: Properti ini mengatur warna latar belakang dari container.\npadding:...: Properti ini mengatur ruang padding (jarak) di sekeliling konten di dalam container.\nmargin:...: Properti ini mengatur ruang margin (jarak) di sekeliling container itu sendiri.\nchild:...: Properti ini menyediakan konten yang akan ditampilkan di dalam container.\n\n\n\n\n\n3.1.3 Center\nWidget Center merupakan sebuah widget yang digunakan untuk membuat suatu widget berada pada posisi tengah.\nCenter(\n    // konten yang ingin diposisikan ketengah\n    child: const Text('Text berada di tengah'),\n),\n\n\n3.1.4 Safe Area\nWidget dalam Flutter yang digunakan untuk mengatur area konten yang “aman” atau bebas dari gangguan seperti bilah status (status bar) atau bilah navigasi (navigation bar) pada perangkat.\nSafeArea(\n    // konten yang ingin diposisi dibawah bilah navigasi\n    child: Scaffold(\n        body: Center(\n        child: Text('Konten utama aplikasi'),\n        ),\n    ),\n)\n\n\n\nSafe Area Details\n\n\n\n\n3.1.5 SizedBox\nWidget dalam Flutter yang digunakan untuk mengatur ukuran ruang kosong yang tetap dalam tata letak.\nSizedBox(\n    width: 200.0,\n    height: 100.0,\n)\n\n\n\nSizedBox Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nwidth:... - Properti ini mengatur lebar kotak yang akan dibuat.\nheight:... - Properti ini mengatur tinggi kotak yang akan dibuat.\n\n\n\n\n\n3.1.6 Text\nWidget dalam Flutter yang digunakan untuk menampilkan teks.\nText('Hello world!')\n\n\n3.1.7 Button\nWidget dalam Flutter yang digunakan untuk membuat elemen yang dapat diinteraksi oleh pengguna. Flutter menyediakan beberapa jenis button yang dapat digunakan, seperti ElevatedButton, TextButton, IconButton, FloatingActionButton, dan lainnya.\nElevatedButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    child: Text('Tombol'),\n),\nIconButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    icon: Icon(Icons.radio_button_checked),\n),\nTextButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    // text di dalam button\n    child: Text('Tombol'),\n),\nfloatingActionButton: FloatingActionButton(\n    onPressed: () {},\n    child: Text('Tombol'),\n),\n\n\n\nButton Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nElevatedButton: Ini adalah tombol dengan tampilan yang sedikit lebih “mengangkat” atau menonjol daripada tombol standar. Saat tombol ini ditekan, logika yang diberikan di dalam fungsi onPressed akan dijalankan. child merupakan properti yang digunakan untuk menambahkan konten teks ke dalam tombol.\nIconButton: Ini adalah tombol yang berisi sebuah ikon. Ikon tersebut diberikan melalui properti icon. Ketika tombol ini ditekan, logika di dalam fungsi onPressed akan dijalankan.\nTextButton: Ini adalah tombol dengan tampilan teks sederhana. Properti child digunakan untuk menentukan teks yang akan ditampilkan di dalam tombol. Saat tombol ini ditekan, logika di dalam fungsi onPressed akan dijalankan.\nFloatingActionButton: Ini adalah tombol tindakan yang mengambang (floating action button) yang umumnya digunakan untuk tindakan utama dalam aplikasi. Dalam contoh ini, tombol ini tidak memiliki logika yang ditentukan dalam fungsi onPressed. child digunakan untuk menambahkan teks “Tombol” ke dalam tombol tersebut."
  },
  {
    "objectID": "3_user_interface.html#layout",
    "href": "3_user_interface.html#layout",
    "title": "3  Antarmuka Pengguna",
    "section": "3.2 Layout",
    "text": "3.2 Layout\nLayout dalam Flutter mengacu pada tata letak atau susunan widget di antarmuka pengguna. Dalam Flutter, tata letak dapat diatur menggunakan berbagai widget dan komponen yang tersedia untuk mengatur posisi, ukuran, dan hubungan antara elemen-elemen dalam antarmuka. Berikut adalah beberapa contoh layout umum dalam Flutter:\n\n3.2.1 Column\nLayout ini mengatur widget secara vertikal, mulai dari atas ke bawah.\nColumn(\n    mainAxisAlignment: MainAxisAlignment.center,\n    crossAxisAlignment: CrossAxisAlignment.end,\n    children: const &lt;Widget&gt;[\n        Text('Sebuah Judul'),\n        Text('Lorem ipsum dolor sit amet'),\n    ],\n),\n\n\n\nColumn Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nmainAxisAlignment:... : Atribut ini digunakan untuk mengatur perataan utama (main axis alignment) dari widget-column.\ncrossAxisAlignment:... : Atribut ini digunakan untuk mengatur perataan lintang (cross axis alignment) dari widget-column.\nchildren: const &lt;Widget&gt;[...]: Ini adalah daftar widget yang akan ditampilkan di dalam column secara vertikal. Penggunaan const menandakan bahwa daftar widget ini merupakan konstanta yang tetap, dan tidak akan berubah selama runtime.\n\n\n\n\n\n3.2.2 Row\nLayout ini mengatur widget secara horizontal, mulai dari kiri ke kanan.\nRow(\n    mainAxisAlignment: MainAxisAlignment.start,\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: const &lt;Widget&gt;[\n        Icon(Icons.share),\n        Icon(Icons.thumb_up),\n        Icon(Icons.thumb_down),\n    ],\n)\n\n\n\nRow Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nmainAxisAlignment:... : menentukan posisi utama (main axis) dari elemen-elemen di dalam Row.\ncrossAxisAlignment:... : menentukan posisi silang (cross axis) dari elemen-elemen di dalam Row.\nchildren : merupakan properti yang berisi daftar elemen-elemen yang ingin ditampilkan dalam Row.\n&lt;Widget&gt;[...] menandakan bahwa tipe elemen yang ditampilkan dalam children adalah Widget.\nconst digunakan untuk mengindikasikan bahwa daftar elemen dalam children adalah konstan, artinya tidak akan berubah.\n\n\n\n\n\n3.2.3 ListView\nLayout ini mengatur widget-widget didalamnya dalam tampilan daftar item yang dapat di-scroll secara vertikal. Widget ini berguna untuk kumpulan data yang ingin ditampilkan dalam bentuk daftar, seperti daftar kontak, daftar pesan, atau daftar produk.\nListView(\n    children: [\n        // ....\n\n        Container(\n        color: Colors.amber,\n        width: double.infinity,\n        height: 100,\n        ),\n        Container(\n        color: Colors.blueAccent,\n        width: double.infinity,\n        height: 100,\n        ),\n        Container(\n        color: Colors.brown,\n        width: double.infinity,\n        height: 100,\n        ),\n        \n        // ...\n    ],\n)\n\n\n\nListview Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nProperti children adalah properti wajib pada ListView yang berisi daftar widget yang akan ditampilkan sebagai elemen dalam daftar.\n\n\n\n\n\n3.2.4 GridView\nLayout ini digunakan untuk menampilkan daftar item dalam bentuk grid. Grid ini dapat berisi item-item yang ditampilkan secara berbaris dan berkolom. Layout ini berguna ketika menampilkan data dalam tata letak grid yang teratur.\nGridView(\n    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: 2,\n        mainAxisSpacing: 10.0,\n        crossAxisSpacing: 10.0,\n    ),\n    children: &lt;Widget&gt;[\n        Container(color: Colors.red),\n        Container(color: Colors.green),\n        Container(color: Colors.blue),\n        Container(color: Colors.yellow),\n    ],\n)\n\n\n\nGridview Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\ngridDelegate: Properti ini mengatur tata letak dan konfigurasi grid. Pada kode di atas, digunakan SliverGridDelegateWithFixedCrossAxisCount yang merupakan salah satu implementasi dari SliverGridDelegate. crossAxisCount menentukan jumlah kolom dalam grid. mainAxisSpacing mengatur ruang antara item secara vertikal, sedangkan crossAxisSpacing mengatur ruang antara item secara horizontal.\nchildren: Properti ini berisi daftar widget yang akan ditampilkan dalam grid. Widget ini akan ditampilkan dalam bentuk grid sesuai dengan konfigurasi yang diberikan oleh gridDelegate.\n\n\n\n\n\n3.2.5 Expanded\nLayout ini digunakan untuk mengalokasikan ruang yang tersisa dalam tata letak yang fleksibel. Expanded memungkinkan widget untuk memperluas dan mengisi ruang yang tersedia sebanyak mungkin, sesuai dengan aturan penempatan dan proporsi yang ditentukan.\nRow(\n    children: [\n        Container(\n        color: Colors.red,\n        height: 100,\n        width: 100,\n        ),\n        Expanded(\n        child: Container(\n            color: Colors.blue,\n        ),\n        ),\n        Container(\n        color: Colors.green,\n        height: 100,\n        width: 100,\n        ),\n    ],\n)\n\n\n\nExpanded Details"
  },
  {
    "objectID": "3_user_interface.html#styling",
    "href": "3_user_interface.html#styling",
    "title": "3  Antarmuka Pengguna",
    "section": "3.3 Styling",
    "text": "3.3 Styling\nStyling dalam Flutter mengacu pada pengaturan penampilan visual dari widget. Dalam Flutter, berbagai properti gaya seperti warna, ukuran, jenis huruf, latar belakang, dan sebagainya dapat diatur untuk memodifikasi penampilan widget.\nBerikut adalah beberapa contoh penggunaan styling dalam Flutter:\n\n3.3.1 Pada Teks\nText(\n  'Hello, world!',\n  style: TextStyle(\n    color: Colors.blue,\n    fontSize: 20,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    letterSpacing: 2,\n    wordSpacing: 5,\n    background: Paint()..color = Colors.yellow,\n    decoration: TextDecoration.underline,\n    decorationColor: Colors.red,\n    decorationStyle: TextDecorationStyle.dashed,\n  ),\n)\n\n\n\nFont Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\ncolor:... : digunakan untuk mengatur warna teks.\nfontSize:... : digunakan untuk mengatur ukuran font teks.\nfontWeight:... : digunakan untuk mengatur ketebalan font teks.\nfontStyle:... : digunakan untuk mengatur gaya font teks.\nletterSpacing:... : digunakan untuk mengatur jarak antar huruf pada teks.\nwordSpacing:... : digunakan untuk mengatur jarak antar kata pada teks.\nbackground: Paint()..color = ... : digunakan untuk memberikan latar belakang pada teks.\ndecoration: TextDecoration.underline : digunakan untuk menambahkan garis bawah pada teks.\ndecorationColor:... : digunakan untuk mengatur warna garis bawah pada teks.\ndecorationStyle:... : digunakan untuk mengatur garis bawah pada teks.\n\n\n\n\n\n3.3.2 Pada Container\nContainer(\n  width: 200,\n  height: 200,\n  decoration: BoxDecoration(\n    color: Colors.blue,\n    borderRadius: BorderRadius.circular(10),\n    boxShadow: [\n      BoxShadow(\n        color: Colors.grey,\n        blurRadius: 10,\n        offset: Offset(5, 5),\n      ),\n    ],\n    gradient: LinearGradient(\n      begin: Alignment.topLeft,\n      end: Alignment.bottomRight,\n      colors: [Colors.blue, Colors.green],\n    ),\n  ),\n  padding: EdgeInsets.all(16),\n  margin: EdgeInsets.all(16),\n  alignment: Alignment.center,\n  child: Text(\n    'Hello, world!',\n    style: TextStyle(\n      color: Colors.white,\n      fontSize: 20,\n      fontWeight: FontWeight.bold,\n    ),\n  ),\n)\n\n\n\nContainer Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\nDalam BoxDecoration, terdapat beberapa properti yang digunakan untuk mengatur dekorasi pada Container, yaitu:\n\ncolor:...: digunakan untuk mengatur warna latar belakang Container.\nborderRadius:...: digunakan untuk mengatur radius border Container.\nboxShadow:...: digunakan untuk memberikan bayangan pada Container.\ngradient: LinearGradient(...): digunakan untuk mengatur warna gradient pada Container.\n\n\n\n\n\n3.3.3 Pada Elevated Button\nElevatedButton(\n  style: ButtonStyle(\n    backgroundColor: MaterialStateProperty.all&lt;Color&gt;(Colors.blue),\n    shape: MaterialStateProperty.all&lt;RoundedRectangleBorder&gt;(\n      RoundedRectangleBorder(\n        borderRadius: BorderRadius.circular(18.0),\n      ),\n    ),\n  ),\n  onPressed: () {\n    // lakukan sesuatu saat tombol ditekan\n  },\n  child: Text(\n    'Click me!',\n    style: TextStyle(\n      color: Colors.white,\n      fontSize: 20,\n      fontWeight: FontWeight.bold,\n    ),\n  ),\n)\n\n\n\nButton Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nstyle: ButtonStyle(): Properti ini digunakan untuk mengatur gaya (style) dari tombol. Di dalamnya, terdapat beberapa properti yang bisa dikonfigurasi.\nbackgroundColor: MaterialStateProperty.all&lt;Color&gt;(Colors.blue): Properti ini digunakan untuk mengatur warna latar belakang (background color) tombol.\nshape: MaterialStateProperty.all&lt;RoundedRectangleBorder&gt; (RoundedRectangleBorder(borderRadius: BorderRadius.circular(18.0))): Properti ini digunakan untuk mengatur bentuk (shape) tombol. Di contoh ini, sebuah RoundedRectangleBorder digunakan dengan jari-jari sudut sebesar 18.0.\nonPressed: () { ... }: Properti ini digunakan untuk menentukan aksi yang dilakukan saat tombol ditekan. Di dalam tanda kurung kurawal ({…}), Anda dapat menulis kode untuk menjalankan aksi tertentu."
  },
  {
    "objectID": "3_user_interface.html#handling-input",
    "href": "3_user_interface.html#handling-input",
    "title": "3  Antarmuka Pengguna",
    "section": "3.4 Handling Input",
    "text": "3.4 Handling Input\n\n3.4.1 GestureDetector\nGestureDetector adalah widget yang dapat digunakan untuk mendeteksi dan menangani berbagai jenis gestur pengguna. Widget ini dapat digunakan untuk menangkap ketukan, gesekan, geseran, dan gestur lainnya.\nGestureDetector(\n    onTap: () {\n       print('Tap!');\n    },\n    onDoubleTap: () {\n       print('Double tap!');\n    },\n    onLongPress: () {\n       print('Long tap!');\n    },\n    onSwipeUp: () {\n       print('Swipe Up!');\n    },\n    child: Container(\n    alignment: Alignment.center,\n    width: 200,\n    height: 200,\n    color: Colors.grey[300],\n    child: Text(\n        _message,\n        textAlign: TextAlign.center,\n        style: TextStyle(fontSize: 20),\n    ),\n    ),\n)\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nonTap: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan satu ketukan (tap) pada area yang diberikan.\nonDoubleTap: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan dua ketukan (double tap) pada area yang diberikan.\nonLongPress: Properti ini menentukan aksi yang akan dilakukan ketika pengguna menahan lama (long press) pada area yang diberikan.\nonSwipeUp: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan geseran ke atas (swipe up) pada area yang diberikan.\nchild: Properti ini digunakan untuk menentukan widget yang akan diletakkan di dalam GestureDetector.\n\n\n\n\n\n3.4.2 InkWell\nInkWell adalah widget yang memberikan umpan balik visual saat pengguna menyentuhnya. Ketika pengguna menyentuh InkWell, widget ini akan menampilkan animasi “splash” atau efek “ink”.\nInkWell(\n    onTap: () {\n       print('Tap!');\n    },\n    onLongPress: () {\n       print('Long tap!');\n    },\n    child: Container(\n    alignment: Alignment.center,\n    width: 200,\n    height: 200,\n    color: Colors.grey[300],\n    child: Text(\n        _message,\n        textAlign: TextAlign.center,\n        style: TextStyle(fontSize: 20),\n    ),\n    ),\n)\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nonTap: Properti ini adalah sebuah fungsi yang akan dieksekusi ketika pengguna mengetuk widget yang dibungkus oleh InkWell.\nonLongPress: Properti ini juga merupakan sebuah fungsi yang akan dieksekusi ketika pengguna menahan lama (long press) pada widget yang dibungkus oleh InkWell.\nchild: Properti ini adalah widget lain yang akan ditampilkan di dalam InkWell."
  },
  {
    "objectID": "4_routing_navigasi.html#widget-navigator",
    "href": "4_routing_navigasi.html#widget-navigator",
    "title": "4  Bekerja dengan Banyak Halaman",
    "section": "4.1 Widget Navigator",
    "text": "4.1 Widget Navigator\nFlutter menyediakan kelas Navigator yang bertanggung jawab untuk mengelola tumpukan tampilan. Setiap kali pengguna berpindah ke tampilan baru, Navigator menambahkannya ke tumpukan dan menampilkan tampilan tersebut di layar. Ketika pengguna menekan tombol “kembali” atau melakukan tindakan kembali lainnya, Navigator akan menghapus tampilan teratas dari tumpukan dan menampilkan tampilan sebelumnya.\nAda beberapa jenis navigator yang dapat digunakan dalam Flutter, di antaranya:\n\n4.1.1 MaterialPageRoute\nMaterialPageRoute: Ini adalah jenis navigator yang umum digunakan dalam aplikasi Flutter yang mengikuti desain material dari Flutter. MaterialPageRoute menampilkan transisi animasi bawaan saat tampilan baru ditampilkan atau ditutup.\n\n\n4.1.2 CupertinoPageRoute\nCupertinoPageRoute: Ini adalah jenis navigator yang mengikuti desain iOS dengan menggunakan transisi animasi khas iOS. Jika Anda ingin aplikasi Anda memiliki tampilan yang mirip dengan aplikasi iOS, Anda dapat menggunakan CupertinoPageRoute."
  },
  {
    "objectID": "4_routing_navigasi.html#navigasi-antar-halaman",
    "href": "4_routing_navigasi.html#navigasi-antar-halaman",
    "title": "4  Bekerja dengan Banyak Halaman",
    "section": "4.2 Navigasi Antar Halaman",
    "text": "4.2 Navigasi Antar Halaman\nAda beberapa metode navigasi yang umum digunakan dalam Flutter:\n\n4.2.1 push\npush: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru. Contoh kode navigator membawa pengguna dari halaman pertama ke halaman kedua.\nElevatedButton(\n    child: const Text('Go to Second Screen'),\n    onPressed: () {\n        Navigator.push(context,\n            MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),\n\n\n4.2.2 pop\npop: Metode ini menghapus rute saat ini dari tumpukan dan membawa pengguna kembali ke halaman sebelumnya. Contoh navigator menghapus halaman kedua dan membawa pengguna kembali ke halaman pertama.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pop(context);\n    },\n),\n\n\n4.2.3 pushReplacement\npushReplacement: Metode ini mengganti rute saat ini dengan rute baru. Ini berguna ketika Anda ingin mengganti halaman tetapi tidak ingin menjaga halaman sebelumnya di tumpukan. Contoh navigator menggantikan halaman saat ini dengan halaman baru.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pushReplacement(context, MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),"
  },
  {
    "objectID": "4_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "href": "4_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "title": "4  Bekerja dengan Banyak Halaman",
    "section": "4.3 Navigasi antar halaman dengan nama route",
    "text": "4.3 Navigasi antar halaman dengan nama route\nAda beberapa metode navigasi dengan nama route yang digunakan dalam Flutter:\n\n4.3.1 pushNamed\npushNamed: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.pushNamed() di dalam Flutter untuk melakukan navigasi dengan nama routes:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk melakukan navigasi ke halaman dengan nama route, gunakan method Navigator.pushNamed() dan berikan nama route yang ingin dituju:\nNavigator.pushNamed(context, '/detail');\n\n\n4.3.2 popAndPushNamed\npopAndPushNamed: Metode ini digunakan untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.popAndPushNamed() di dalam Flutter untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route, gunakan method Navigator.popAndPushNamed() dan berikan nama route yang ingin dituju:\nNavigator.popAndPushNamed(context, '/result');"
  },
  {
    "objectID": "4_routing_navigasi.html#berbagi-data-antar-halaman",
    "href": "4_routing_navigasi.html#berbagi-data-antar-halaman",
    "title": "4  Bekerja dengan Banyak Halaman",
    "section": "4.4 Berbagi Data Antar Halaman",
    "text": "4.4 Berbagi Data Antar Halaman\nDalam Flutter, terdapat beberapa cara untuk berbagi data antara halaman atau layar dalam aplikasi:\n\n4.4.1 Menggunakan Konstruktor\nMenggunakan Konstruktor: Mengirim data menggunakan konstruktor dilakukan dengan cara menginisialisasi data yang ingin dikirim pada konstruktor halaman yang ingin dituju.\n// Halaman Sumber\nNavigator.push(\n    context,\n    MaterialPageRoute(\n    builder: (context) =&gt; HalamanTujuan(\n        data: dataYangDibagikan,\n        ),\n    ),\n);\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    final String data;\n\n    HalamanTujuan({required this.data});\n\n    // ...\n}\n\n\n4.4.2 Menggunakan ModalRoute\nMenggunakan ModalRoute: Untuk mengambil data kembali dari halaman tujuan ke halaman sumber setelah halaman tujuan ditutup, dapat menggunakan ModalRoute dalam kombinasi dengan metode pop.\n// Halaman Sumber\nfinal data = await Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) =&gt; HalamanTujuan()),\n);\n// Proses data yang dikembalikan dari Halaman Tujuan\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    // ...\n    // Pada saat ingin mengirimkan data kembali ke halaman sumber\n    Navigator.pop(context, dataYangDikirimkanKembali);\n    // ...\n}\n\n\n4.4.3 Menggunakan State Management\nMenggunakan State Management: Jika data yang perlu dibagikan di seluruh aplikasi berjumlah banyak, dapat menggunakan paket state management seperti provider, riverpod, maupun bloc untuk mengelola state aplikasi secara global."
  },
  {
    "objectID": "4_routing_navigasi.html#state-management",
    "href": "4_routing_navigasi.html#state-management",
    "title": "4  Bekerja dengan Banyak Halaman",
    "section": "4.5 State Management",
    "text": "4.5 State Management\nSeperti yang sudah dijelaskan sebelumnya jika memiliki data yang banyak keberadaan state management menjadi diperlukan. Ada banyak jenis state management namun pada dasarnya mereka semua sama yaitu untuk membantu perpindahan data dalam flutter.\nPada modul ini state management yang akan digunakan merupakan flutter_riverpod. Flutter Riverpod merupakan pustaka dalam Flutter yang digunakan untuk manajemen state dan dependency injection. Riverpod didasarkan pada konsep “provider” dan memberikan solusi yang lebih sederhana dan fleksibel untuk manajemen state dibandingkan dengan paket Flutter lainnya seperti Provider atau GetX.\nUntuk menggunakan flutter_riverpod terlebih dahulu tambahkan pustakanya didalam pubspec.yaml lalu ketik perintah flutter pub get di terminal atau dengan menggunakan perintah flutter pub add flutter_riverpod. Lalu setelah itu deklarasikan scope dari provider dengan cara sebagai berikut :\nvoid main() {\n    runApp(const ProviderScope(child: MainApp()));\n}\nPaket flutter_provider menyediakan berbagai macam provider yang digunakan untuk manajemen state dan dependency injection dalam aplikasi Flutter. Berikut adalah provider-provider yang umum digunakan dalam flutter_provider:\n\nProvider: Provider ini digunakan untuk menyediakan objek tanpa adanya state yang dapat berubah. Berguna untuk menyediakan ketergantungan yang tidak memerlukan pembaruan atau perubahan state.\nStateProvider: Provider ini digunakan untuk menyediakan objek yang nilainya dapat dimodifikasi dari luar. Berguna dalam kondisi sederhana seperti melakukan fiter atau memberikan data yang bisa diakses dan diperbarui dari berbagai halaman.\nFutureProvider: Provider ini digunakan untuk mengelola hasil dari Future. Ini memungkinkan Anda untuk melakukan pemrosesan asinkron dan mengubah UI ketika future selesai atau mengalami perubahan.\nStateNotifierProvider: Provider ini merupakan provider khusus yang harus digunakan bersama dengan state notifier. State notifer merupakan sebuah kelas yang menyimpan satu tipe data untuk dan dapat diamati setiap aktvitasnya oleh StateNotifierProvider. Provider beserta kelas tersebut dapat digunakan untuk memanipulasi state tingkat lanjut, yang akan sulit direpresentasikan dengan provider yang lebih sederhana seperti [Provider] atau [FutureProvider]."
  },
  {
    "objectID": "5_pengujian_debugging.html#debugging-di-flutter",
    "href": "5_pengujian_debugging.html#debugging-di-flutter",
    "title": "5  Pengujian dan Debugging",
    "section": "5.1 Debugging di Flutter",
    "text": "5.1 Debugging di Flutter\nProses debugging dalam Flutter melibatkan pencarian dan perbaikan kesalahan atau bug yang ada dalam aplikasi. Ada beberapa metode yang dapat digunakan dalam proses debugging pada Flutter:\n\n5.1.1 Print\nMencetak pesan kesalahan pada terminal menggunakan pernyataan ‘print’: Saat aplikasi mengalami kegagalan atau kesalahan, pernyataan “print” dapat ditambahkan di berbagai bagian kode untuk mencetak nilai variabel atau pesan di konsol. Pencetakan pesan kesalahan ini dapat memberikan petunjuk tentang lokasi masalah, seperti baris kode yang menyebabkan kesalahan tersebut.\nContoh penggunaan pernyataan ‘print’:\nprint('Nilai dari variabel x: $x');\n\n\n5.1.2 Breakpoint\nBreakpoint: Breakpoint dapat ditempatkan dalam kode untuk memberhentikan eksekusi program sehingga nilai variabel, status aplikasi, dan alur eksekusi dapat diperiksa.\n\n\n5.1.3 Debugger\nMenjalankan Aplikasi dalam Mode Debug atau menggunakan debugger: Aplikasi dapat dijalankan dalam mode debug dengan membuka terminal dan menjalankan perintah “flutter run –debug”. Debugger adalah alat yang disediakan dalam Flutter yang memungkinkan untuk melihat kode secara rinci dan melakukan pemecahan masalah dengan lebih efisien. Debugger dapat membantu melacak nilai variabel, melihat tumpukan panggilan (stack trace), dan memperbaiki bug secara interaktif.\n\n\n5.1.4 Logging\nLogging: Logging merupakan proses pencatatan aktivitas di dalam aplikasi. Pernyataan logging dapat membantu dalam memahami alur eksekusi dan memeriksa nilai variabel.\nContoh penggunaan logging:\nimport 'package:logger/logger.dart';\n\nvar logger = Logger();\n\nlogger.d('Pesan debug');\nlogger.i('Pesan info');\nlogger.w('Pesan peringatan');\nlogger.e('Pesan error');\nlogger.f('Pesan fatal');\n\n\n5.1.5 Inspector Flutter\nInspector Flutter: Flutter menyediakan Inspector, yaitu alat visual yang membantu menganalisis widget dan properti dalam aplikasi. Inspector dapat membantu dalam memahami struktur widget dan melacak masalah dengan widget tertentu. Inspector dapat diaktifkan dengan menekan tombol “Toggle Inspector” pada toolbar dalam mode debug.\n\n\n5.1.6 Exception Handling\nException Handling: Exception Handling adalah cara untuk menangani kesalahan atau pengecualian yang terjadi selama eksekusi kode. Dengan menangani pengecualian, crash pada aplikasi dapat dihindari.\nContoh penggunaan Exception Handling:\ntry {\n  // beberapa kode yang dapat menimbulkan pengecualian\n} catch (e) {\n  // menangani pengecualian\n}\n\n\n5.1.7 Dokumentasi dan Komunitas\nMembaca Dokumentasi dan Menggunakan Komunitas: Dokumentasi resmi Flutter menyediakan informasi yang lengkap dan bermanfaat. Jika Anda mengalami kesulitan dalam proses debugging, Anda dapat merujuk pada dokumentasi Flutter yang dapat memberikan informasi yang berguna. Selain itu, komunitas pengembang Flutter juga merupakan sumber daya yang berharga, di mana Anda dapat mencari bantuan dan berdiskusi dengan pengembang lainnya."
  },
  {
    "objectID": "5_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "href": "5_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "title": "5  Pengujian dan Debugging",
    "section": "5.2 Menggunakan Unit Test untuk Uji Logika",
    "text": "5.2 Menggunakan Unit Test untuk Uji Logika\nUnit testing adalah proses pengujian perangkat lunak yang dilakukan pada tingkat terkecil, yaitu pada unit-unit kode yang independen dan dapat diuji secara terpisah. Dalam konteks Flutter, unit testing digunakan untuk menguji fungsi-fungsi individual dalam aplikasi Flutter. Tujuan dari unit testing adalah untuk memastikan bahwa setiap unit kode berfungsi sesuai dengan harapan, dan untuk menghindari bug atau kesalahan yang mungkin terjadi pada aplikasi.\nBerikut adalah langkah-langkah umum untuk melakukan unit testing pada Flutter:\nLangkah 1: Menyiapkan Proyek - Buat proyek Flutter baru atau buka proyek Flutter yang sudah ada. - Impor package “flutter_test” ke dependencies dalam file pubspec.yaml dan jalankan perintah ‘flutter pub get’ untuk menginstalnya.\nLangkah 2: Membuat File Test - Buat file baru dengan ekstensi .dart di dalam direktori test dengan nama yang diakhiri dengan “_test.dart” untuk menyimpan tes unit. - Impor paket flutter_test dan file yang ingin Anda uji, contohnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:nama_aplikasi/file_yang_di_uji.dart';\nLangkah 3: Menulis Tes Unit Buat test case dengan menambahkan fungsi yang menguji fungsi atau metode tertentu. Contoh:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/utils.dart';\n\nvoid main() {\n  test('Test add function', () {\n    expect(add(1, 2), equals(3));\n    expect(add(0, 0), equals(0));\n    expect(add(-1, 1), equals(0));\n  });\n\n  test('Test subtract function', () {\n    expect(subtract(3, 1), equals(2));\n    expect(subtract(0, 0), equals(0));\n    expect(subtract(-1, 1), equals(-2));\n  });\n}\nLangkah 4: Menjalankan Tes Unit - Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus unit testing."
  },
  {
    "objectID": "5_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "href": "5_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "title": "5  Pengujian dan Debugging",
    "section": "5.3 Menggunakan Widget Test untuk Uji Widget",
    "text": "5.3 Menggunakan Widget Test untuk Uji Widget\nWidget testing adalah metode pengujian yang digunakan untuk memastikan bahwa widget-widget dalam aplikasi Flutter berfungsi seperti yang diharapkan. Tujuan dari widget testing adalah untuk memastikan bahwa widget berfungsi dengan benar dan sesuai dengan harapan pada saat runtime.\nBerikut adalah langkah-langkah dasar dalam melakukan widget testing pada Flutter:\n\nMenyiapkan Dependensi: Pastikan bahwa dependensi yang diperlukan dalam file pubspec.yaml proyek Flutter sudah tersedia. Jika belum ada, dependensi dapat ditambahkan sebagai berikut:\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\nMembuat File Test: Buat file test baru dengan ekstensi .dart dan nama yang diakhiri dengan “_test.dart” di direktori “test” pada proyek Flutter dalam direktori test proyek. Misalnya, widget_test.dart.\nMengimpor Paket dan Widget yang Dibutuhkan: Dalam file widget_test.dart, impor paket-paket dan widget-widget yang akan diuji. Misalnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter/material.dart';\nimport 'package:my_app/my_widget.dart';\nMenulis Test Case: Buat test case dengan menambahkan fungsi yang menguji widget tertentu. Contoh:\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('Test MyButton widget', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    final button = find.byType(MyButton);\n    expect(button, findsOneWidget);\n\n    await tester.tap(button);\n    await tester.pump();\n\n    final text = find.text('Button clicked');\n    expect(text, findsOneWidget);\n  });\n}\n\nMenjalankan Test: Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus widget testing."
  },
  {
    "objectID": "6_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "href": "6_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "title": "6  Akses Data Lokal",
    "section": "6.1 Penyimpanan dengan Shared Preferences",
    "text": "6.1 Penyimpanan dengan Shared Preferences\nShared Preferences adalah sebuah mekanisme penyimpanan data sederhana yang digunakan untuk menyimpan dan mengambil nilai-nilai (data) secara persisten di aplikasi. Hal ini berarti data yang disimpan dengan menggunakan Shared Preferences akan tetap ada meskipun aplikasi ditutup dan dijalankan kembali.\nDalam penggunaan sehari-hari, Shared Preferences sering digunakan untuk menyimpan preferensi pengguna seperti pengaturan, preferensi tema, atau data lain yang perlu dipertahankan antar-sesi aplikasi.\nBerikut ini adalah langkah-langkah sederhana untuk menggunakan Shared Preferences dalam Flutter:\n\nPertama, tambahkan dependensi SharedPreferences ke file pubspec.yaml di proyek Flutter Anda:\n\ndependencies:\n  shared_preferences: ^x.x.x\n\nKemudian, impor package shared_preferences:\n\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSelanjutnya, Anda dapat menggunakan Shared Preferences untuk menyimpan dan mengambil data. Misalnya, untuk menyimpan sebuah nilai (contohnya, preferensi pengguna), Anda dapat melakukannya sebagai berikut:\n\n// Membuat sebuah instance dari SharedPreferences\nSharedPreferences prefs = await SharedPreferences.getInstance();\n\n// Menyimpan nilai dengan menggunakan key 'nama'\nprefs.setString('nama', 'udinus');\n\nUntuk mengambil nilai yang telah disimpan sebelumnya, Anda dapat menggunakan kode berikut:\n\n// Mengambil nilai dengan menggunakan key 'nama'\nString? nama = prefs.getString('nama');\nDalam contoh di atas, variabel nama akan berisi nilai yang telah disimpan sebelumnya (‘udinus’) jika ada, atau null jika tidak ada nilai yang disimpan dengan key ‘nama’."
  },
  {
    "objectID": "6_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "href": "6_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "title": "6  Akses Data Lokal",
    "section": "6.2 Penyimpanan dengan Sqlite",
    "text": "6.2 Penyimpanan dengan Sqlite\nSQLite adalah sebuah database relasional ringan yang sering digunakan dalam pengembangan aplikasi mobile, termasuk Flutter. SQLite dapat bekerja dengan database yang disimpan secara lokal di perangkat pengguna.\nSQLite pada Flutter memungkinkan Anda menyimpan, mengelola, dan mengakses data secara efisien. Dalam konteks Flutter, Anda dapat menggunakan paket sqflite untuk berinteraksi dengan SQLite.\n\n6.2.1 Konfigurasi dan Pengaturan Awal\nUntuk menghubungkan aplikasi dengan sqlite diperlukan beberapa konfigurasi. Berikut adalah langkah langkah konfigurasi agar dapat terhubung dengan sqlite:\n\nMengimpor dependensi\n\nimpor dependensi sqflite, path, dan path_provider pada file pubspec.yaml:\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nJalankan perintah flutter pub get untuk mengunduh dependensi tersebut. Untuk menghubungkan aplikasi dengan sqlite sebenernya hanya memerlukan dependesi sqflite. Namun sebagai pembantu dalam membuat database diperlukan dua dependesi pembantu yaitu path, dan path_provider.\n\nMembuat Database Helper\n\nSetelah ditambahkan dependeciesnya aplikasi tidak langsung dapat mengakses sqlite. Terlebih dahulu dibuat sebuah class khusus untuk menghubungkan aplikasi dengan sqlite. Dalam class tersebut database akan di inisialisasi ketika belum dibuat.\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._();\n  static Database? _database;\n\n  DatabaseHelper._();\n\n  Future&lt;Database&gt; get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future&lt;Database&gt; _initDatabase() async {\n    Directory directory = await getApplicationDocumentsDirectory();\n    String path = join(\n        directory.path, \n        'my_database.db',\n    );\n    return await openDatabase(\n        path, \n        version: 1, \n        onCreate: _createDb,\n    );\n  }\n\n  Future&lt;void&gt; _createDb(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE IF NOT EXISTS my_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        age INTEGER\n      )\n    '''\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi dan inisialisasi variabel instance sebagai instance tunggal dari kelas DatabaseHelper. Variabel ini bertipe DatabaseHelper dan dideklarasikan sebagai static final, sehingga hanya ada satu instance dari kelas ini yang dapat digunakan.\nDeklarasi variabel _database sebagai variabel database yang digunakan dalam kelas. Variabel ini ditandai dengan tanda tanya (?) yang menandakan bahwa nilainya bisa null. Variabel ini bersifat private karena diawali dengan underscore (_).\nKonstruktor _DatabaseHelper._() merupakan konstruktor private yang tidak bisa diakses dari luar kelas. Ini dilakukan agar kelas ini tidak dapat diinisialisasi dari luar.\nFungsi database merupakan getter yang mengembalikan Future&lt;Database&gt;. Fungsi ini digunakan untuk mendapatkan akses ke database. Pada awalnya, fungsi ini mengecek apakah _database sudah terinisialisasi, jika sudah, maka langsung mengembalikan _database yang sudah ada. Jika belum, maka fungsi _initDatabase() dipanggil untuk menginisialisasi database dan mengembalikan nilainya.\nFungsi _initDatabase() merupakan fungsi yang digunakan untuk menginisialisasi database. Pada fungsi ini, direktori aplikasi diakses menggunakan getApplicationDocumentsDirectory() dan path untuk database dibentuk dengan menggabungkan path direktori aplikasi dengan nama file database. Kemudian, fungsi openDatabase() dipanggil dengan menggunakan path tersebut, dan versi database serta callback _createDb untuk aksi pembuatan tabel.\nFungsi _createDb() merupakan callback yang dipanggil saat database dibuat. Pada fungsi ini, tabel my_table akan dibuat jika belum ada. Tabel tersebut memiliki tiga kolom yaitu id sebagai kunci utama yang diatur untuk otomatis bertambah nilainya (AUTOINCREMENT), name sebagai teks, dan age sebagai bilangan bulat.\n\n\n\n\n\n6.2.2 CRUD Data dengan SQLite\n\nImplementasi CRUD\n\nSelanjutnya, agar aplikasi dapat melakukan interaksi dengan database seperti menambah, mengupdate, menghapus, dan mendapatkan data diperlukan method tambahan di dalam class DatabaseHelper. Method tersebut mengembalikan nilai Future karena memerlukan proses pengambilan data terlebih dahulu yang biasanya sedikit memakan waktu.\nclass DatabaseHelper {\n  // ...\n  \n  Future&lt;int&gt; insert(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    return await db.insert('my_table', row);\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; queryAll() async {\n    Database db = await instance.database;\n    return await db.query('my_table');\n  }\n\n  Future&lt;int&gt; update(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    int id = row['id'];\n    return await db.update(\n        'my_table', \n        row, \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n\n  Future&lt;int&gt; delete(int id) async {\n    Database db = await instance.database;\n    return await db.delete(\n        'my_table', \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nMetode insert:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan dimasukkan ke dalam tabel database.\nPertama, kita mendapatkan instance objek Database dengan menggunakan await instance.database. instance adalah sebuah objek yang memiliki method database yang mengembalikan objek Database.\nKemudian, menggunakan objek db, kita menggunakan metode insert untuk memasukkan data ke dalam tabel dengan nama ‘my_table’. Metode insert mengembalikan nilai int yang merupakan id dari row yang baru saja dimasukkan.\nMetode insert mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode queryAll:\n\nMetode ini tidak menerima parameter.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode query untuk melakukan kueri terhadap tabel dengan nama ‘my_table’.\nMetode query mengembalikan objek Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya berupa List dari Map yang berisi data dari tabel.\n\nMetode update:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan diperbarui pada tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nKita mengambil nilai id dari row dengan menggunakan int id = row['id'].\nMenggunakan objek db, kita menggunakan metode update untuk memperbarui data pada tabel ‘my_table’. Metode update mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh perubahan.\nMetode update mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode delete:\n\nMetode ini menerima parameter id yang merupakan nilai id yang akan dihapus dari tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode delete untuk menghapus baris dengan kondisi ‘id = ?’ dari tabel ‘my_table’. whereArgs: [id] digunakan untuk menggantikan ? dengan nilai id.\nMetode delete mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh penghapusan.\nMetode delete mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\n\n\n\n\n\n6.2.3 Query Pencarian Database Lokal\n\nImplementasi query search\n\nSetelah menambahkan method-method diatas aplikasi sudah mampu berinteraksi dengan database. Namun sebagai tambahan akan lebih seru jika aplikasi dapat mencari data didalam database. Maka dari itu selanjutnya, dalam DatabaseHelper, tambahkan metode untuk melakukan operasi query search:\nclass DatabaseHelper {\n  // ...\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {\n    Database? db = await database;\n    return await db!.query(\n        'your_table', \n        where: 'name LIKE ?', \n        whereArgs: ['%$query%'],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nFuture&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {:\n\nMembuka definisi fungsi querySearch yang menerima string query sebagai argumen dan mengembalikan Future yang berisi daftar hasil pencarian.\n\nDatabase? db = await database;:\n\nMembuat variabel db yang bertipe Database? (nullable) dan menginisialisasinya dengan hasil pemanggilan await database.\nKata kunci await digunakan untuk menunggu hingga database selesai di-load sebelum melanjutkan eksekusi kode.\n\nreturn await db!.query('your_table', where: 'name LIKE ?', whereArgs: ['%$query%']);:\n\nMengembalikan hasil dari pemanggilan metode query pada objek db.\nMetode query digunakan untuk melakukan kueri pada tabel database.\nParameter pertama 'your_table' adalah nama tabel yang ingin dikueri.\nParameter where digunakan untuk menentukan kondisi pencarian yang diterapkan pada kueri. Dalam hal ini, kondisi adalah 'name LIKE ?', yang berarti kolom ‘name’ harus mirip dengan nilai yang diberikan.\nParameter whereArgs berisi daftar argumen yang akan menggantikan tanda tanya (?) dalam kondisi pencarian. Dalam hal ini, argumen yang digunakan adalah ['%$query%'], yang akan mencocokkan nilai dengan string yang mengandung query di mana pun dalam nilainya."
  },
  {
    "objectID": "7_akses_data_api.html#konsep-dasar-rest-api",
    "href": "7_akses_data_api.html#konsep-dasar-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.1 Konsep Dasar REST API",
    "text": "7.1 Konsep Dasar REST API"
  },
  {
    "objectID": "7_akses_data_api.html#menggunakan-package-http",
    "href": "7_akses_data_api.html#menggunakan-package-http",
    "title": "7  Akses Data Melalui API",
    "section": "7.2 Menggunakan Package HTTP",
    "text": "7.2 Menggunakan Package HTTP"
  },
  {
    "objectID": "7_akses_data_api.html#mengambil-data-dari-rest-api",
    "href": "7_akses_data_api.html#mengambil-data-dari-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.3 Mengambil Data dari REST API",
    "text": "7.3 Mengambil Data dari REST API"
  },
  {
    "objectID": "7_akses_data_api.html#menampilkan-data-pada-widget",
    "href": "7_akses_data_api.html#menampilkan-data-pada-widget",
    "title": "7  Akses Data Melalui API",
    "section": "7.4 Menampilkan Data pada Widget",
    "text": "7.4 Menampilkan Data pada Widget"
  },
  {
    "objectID": "8_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "href": "8_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.1 Konsep BAaS dan Serverless Application",
    "text": "8.1 Konsep BAaS dan Serverless Application"
  },
  {
    "objectID": "8_integrasi_baas.html#pengenalan-supabase",
    "href": "8_integrasi_baas.html#pengenalan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.2 Pengenalan Supabase",
    "text": "8.2 Pengenalan Supabase"
  },
  {
    "objectID": "8_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "href": "8_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.3 Integrasi Supabase dengan Flutter",
    "text": "8.3 Integrasi Supabase dengan Flutter"
  },
  {
    "objectID": "8_integrasi_baas.html#otentikasi-dengan-supabase",
    "href": "8_integrasi_baas.html#otentikasi-dengan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.4 Otentikasi dengan Supabase",
    "text": "8.4 Otentikasi dengan Supabase"
  },
  {
    "objectID": "8_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "href": "8_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.5 Pengunaan Supabase untuk Penyimpanan Data",
    "text": "8.5 Pengunaan Supabase untuk Penyimpanan Data"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "href": "9_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.1 Menggunakan Package Location",
    "text": "9.1 Menggunakan Package Location"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "href": "9_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.2 Mengunakan Widget Geolocator",
    "text": "9.2 Mengunakan Widget Geolocator"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "href": "9_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.3 Menampilkan OpenStreetMap API pada Aplikasi",
    "text": "9.3 Menampilkan OpenStreetMap API pada Aplikasi"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "href": "10_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS",
    "text": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#autentikasi-pengguna",
    "href": "10_pengamanan_aplikasi.html#autentikasi-pengguna",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.2 Autentikasi Pengguna",
    "text": "10.2 Autentikasi Pengguna"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#obfuscating-dart-code",
    "href": "10_pengamanan_aplikasi.html#obfuscating-dart-code",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.3 Obfuscating Dart Code",
    "text": "10.3 Obfuscating Dart Code"
  },
  {
    "objectID": "studi_kasus_dan_proyek.html",
    "href": "studi_kasus_dan_proyek.html",
    "title": "Studi Kasus dan Proyek",
    "section": "",
    "text": "Studi Kasus dan Proyek :\n\nStudi Kasus 1\nStudi Kasus 2\nStudi Kasus 3\nProyek 1 : Kalkulator\nProyek 2 : Password Vault\nProyek 3 : Lapor Book"
  },
  {
    "objectID": "studi_kasus_2.html",
    "href": "studi_kasus_2.html",
    "title": "12  Studi Kasus 2",
    "section": "",
    "text": "13 Studi Kasus 2 : List Kuliner\n\n\n\n\n\n\nTips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 1 hingga 4\n\n\nDalam studi kasus ini, kita akan membuat sebuah aplikasi yang menampilkan daftar makanan dalam bentuk daftar yang terlihat di layar serta tampilan detailnya. Berikut adalah tampilan aplikasi yang dihasilkan dari studi kasus ini.\n\n\n\nHasil\n\n\n\n\n\nHasil\n\n\nTahap-tahap pembuatan studi kasus adalah sebagai berikut:\n\nBuatlah projek flutter baru.\nBuka file main.dart dan hapus kode template yang ada di dalamnya, kemudian gantikan dengan kode berikut ini:\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n\n\n\nTampilan langkah ke 2\n\n\n\nBuatlah styles.dart dan isilah dengan beberapa variabel yang digunakan untuk menampung text style, warna yang akan digunakan nantinya.\n\n\n\n\nLangkah ke 3\n\n\nimport 'package:flutter/material.dart';\n\nconst textHeader1 = TextStyle(fontSize: 25, fontWeight: FontWeight.bold);\nconst textHeader2 = TextStyle(fontSize: 20, fontWeight: FontWeight.bold);\n\nconst headerBackColor = Color.fromARGB(255, 83, 67, 40);\nconst pageBgColor = Color(0xFFFFF3E0);\nconst iconColor = Color.fromRGBO(255, 111, 0, 1);\n\nBuatlah sebuah file baru dengan nama “home_page.dart” di dalam direktori “lib”. Pada file ini, tampilan utama dari aplikasi akan disimpan, sehingga membuat kode menjadi lebih mudah dibaca dan dikelola.\n\n\n\n\nTampilan langkah ke 4\n\n\n\nSelanjutnya buat sebuah class baru bernama HomePage pada file home_page.dart dengan tipe StatelessWidget.\n\nimport 'package:flutter/material.dart';\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n\nSetelah itu kembali ke dalam file main.dart, ubah kode pada bagian body menjadi HomePage(). Dengan melakukan perubahan tersebut, tampilan di emulator akan mengikuti konten yang ada di halaman utama (HomePage). Selain itu, tambahkan judul pada aplikasi dengan menggunakan komponen AppBar.\n\nSafeArea(\n  child: Scaffold(\n    backgroundColor: pageBgColor,\n    appBar: AppBar(\n      backgroundColor: headerBackColor,\n      title: const Text(\n        \"Kuliner Nusantara\",\n        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n      ),\n      centerTitle: true,\n    ),\n    body: const HomePage(),\n  ),\n),\n\n\n\nLangkah ke 6\n\n\n\nBuka file home_page.dart dan gantilah placeholder dengan widget ListView. Selanjutnya, tambahkan widget Container di dalam ListView tersebut. Sesuaikan gaya tampilan (styling) pada ListView dan Container sesuai dengan preferensi Anda. Tampilan ini akan menjadi dasar dari aplikasi studi kasus yang sedang dibangun.\n\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        const SizedBox(height: 20),\n        const Row(mainAxisAlignment: MainAxisAlignment.center, children: [\n          Icon(Icons.list_alt_sharp, size: 30),\n          SizedBox(width: 10),\n          Text('List Kuliner', style: textHeader1),\n        ]),\n        Padding(padding: EdgeInsets.only(bottom: 20)),\n        Container(\n            margin: EdgeInsets.symmetric(vertical: 8),\n            decoration: BoxDecoration(\n                color: Colors.white,\n                borderRadius: \n                BorderRadius.all(Radius.circular(10)),\n                boxShadow: [\n                BoxShadow(\n                    color: Color.fromARGB(255, 178, 178, 178),\n                    offset: Offset(1.0, 2.0),\n                    blurRadius: 6.0,\n                ),\n                ],\n            ),\n            height: 100,\n            padding: EdgeInsets.symmetric(\n                horizontal: 15,\n                vertical: 10,\n            ),\n        ),\n    ],\n),\n\n\n\nLangkah ke 7\n\n\n\nBuatlah beberapa widget di dalam sebuah container, menggunakan widget Column atau Row, untuk mengubah tampilan container menjadi sebuah kartu (card) yang dapat digunakan untuk menyimpan data makanan. Sesuaikan juga gaya (styling) seperti margin, padding, dan warna.\n\nContainer(\n    //...\n    \n    child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n        Container(\n            width: 85,\n            height: 75,\n            color: Colors.grey,\n        ),\n        SizedBox(\n            width: 10,\n        ),\n        Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n            Text(\n                \"Title\",\n                style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n                ),\n            ),\n            Text(\n                \"Sub Title\",\n                style: TextStyle(\n                fontWeight: FontWeight.w500,\n                ),\n            ),\n            ],\n        )\n        ],\n    ),\n),\n\n\n\nLangkah ke 8\n\n\n\nUntuk mempermudah pembacaan kode, buatlah sebuah file baru bernama “list_item.dart”. Di dalam file tersebut, buatlah sebuah class baru dengan nama “ListItem” yang merupakan turunan dari StatelessWidget. Kemudian, pindahkan seluruh kode yang berada di dalam container ke dalam class ListItem tersebut.\n\n\n\n\nLangkah ke 9\n\n\nimport 'package:flutter/material.dart';\n\nclass ListItem extends StatelessWidget {\n  const ListItem({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      //...\n    );\n  }\n}\nPastikan untuk menyertakan Widget ListItem() di dalam ListView pada file home_page.dart agar kontainer dapat ditampilkan dengan benar.\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        ListItem(),\n    ],\n),\n\nSampai pada tahap ke 8 tampilan statis dari aplikasi telah selesai. Langkah selanjutnya adalah membuat data dan menampilkannya dalam aplikasi.\n\nPertama-tama Anda perlu membuat file baru bernama “makanan.dart” untuk menyimpan kelas makanan beserta atribut-atributnya.\n\n\n\nLangkah ke 10\n\n\nclass Makanan {\n  final String nama;\n  final String deskripsi;\n  final String gambar;\n  final String detail;\n  final String waktubuka;\n  final String harga;\n  final String kalori;\n  final List&lt;String&gt; gambarlain;\n  final List&lt;Map&lt;String, String&gt;&gt; bahan;\n\n  Makanan(\n      {required this.nama,\n      required this.harga,\n      required this.gambarlain,\n      required this.waktubuka,\n      required this.detail,\n      required this.kalori,\n      required this.bahan,\n      required this.deskripsi,\n      required this.gambar});\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nKode tersebut adalah definisi dari sebuah kelas (class) yang disebut “Makanan”. Kelas ini memiliki properti (properties) yaitu “nama”, “deskripsi”, “gambar”, “detail”, “waktubuka”, “harga”, “kalori”, “gambarlain”, dan “bahan”, yang memiliki tipe data String dan list string. Properti-properti tersebut ditandai dengan kata kunci “final” yang menunjukkan bahwa setelah objek Makanan dibuat, nilai-nilai properti tersebut tidak dapat diubah.\nSelain itu, kelas Makanan juga memiliki sebuah constructor dengan sintaksis yang sedikit berbeda. Constructor ini menggunakan named parameters (parameter yang diberi nama) dengan menggunakan kurung kurawal {}. Constructor ini memiliki parameter yaitu “nama”, “deskripsi”, “gambar”, “detail”, “waktubuka”, “harga”, “kalori”, “gambarlain”, dan “bahan”, dan parameter tersebut ditandai dengan kata kunci “required” yang menunjukkan bahwa nilai-nilai parameter tersebut harus disediakan saat membuat objek Makanan.\n\n\n\nSebelum membuat daftar makanan yang akan ditampilkan, langkah pertama adalah mengunduh gambar-gambar yang akan digunakan. Untuk itu, buatlah folder khusus bernama “assets” di dalam proyek Anda dan simpan gambar-gambar tersebut di dalam folder tersebut.\n\n\n\n\nLangkah ke 11\n\n\nSetelah itu, buatlah folder bernama “bahan” di dalam folder “assets” yang telah dibuat tadi\n\n\n\nLangkah ke 11\n\n\nGambar-gambar yang ada di dalam folder bahan, dapat diunduh melalui link berikut : https://drive.google.com/drive/folders/1zhRE3u8DVGAwts3K4K41q9ukd7rbcx7M?usp=sharing\nSelanjutnya, Anda perlu menambahkan folder “assets” dan “bahan” pada file pubspec.yaml agar gambar yang terdapat di dalamnya dapat diakses oleh aplikasi.\n\n\n\nLangkah ke 11\n\n\n\nBuka file “makanan.dart” dan buatlah sebuah variabel list yang berisi sebuah list array untuk menyimpan data makanan yang akan di-load dalam aplikasi.\n\nList&lt;Makanan&gt; listMakanan = [\n  Makanan(\n      nama: 'Bubur',\n      deskripsi: 'Nasi Lembek',\n      gambar: 'assets/bubur.jpg',\n      detail:\n          'Bubur merupakan istilah umum untuk mengacu pada campuran bahan padat dan cair, dengan komposisi cairan yang lebih banyak daripada padatan dan keadaan bahan padatan yang tercerai-berai.',\n      waktubuka: '07.00-10.00',\n      harga: 'Rp 10.000',\n      gambarlain: [\n        'assets/bubur1.jpg',\n        'assets/bubur2.jpg',\n        'assets/bubur3.jpg',\n      ],\n      bahan: [\n        {'Daging': 'assets/bahan/daging.png'},\n        {'Cabai': 'assets/bahan/cabai.png'},\n        {'Bawang': 'assets/bahan/bawang.png'},\n        {'Jahe': 'assets/bahan/jahe.png'},\n        {'Santan': 'assets/bahan/santan.png'},\n      ],\n      kalori: '372 kkal'),\n  Makanan(\n      nama: 'Soto',\n      deskripsi: 'Makanan berkuah',\n      gambar: 'assets/soto.jpg',\n      detail:\n          'Soto (juga dikenal dengan beberapa nama lokal seperti, sroto, sauto, tauto, atau coto) adalah makanan khas Indonesia seperti sop yang terbuat dari kaldu daging dan sayuran.',\n      waktubuka: '09.00-12.00',\n      harga: 'Rp 6.000',\n      gambarlain: [\n        'assets/soto1.jpg',\n        'assets/soto2.jpg',\n        'assets/soto3.jpg',\n      ],\n      bahan: [\n        {'Ayam': 'assets/bahan/ayam.png'},\n        {'Cabai': 'assets/bahan/cabai.png'},\n        {'Bawang': 'assets/bahan/bawang.png'},\n        {'Saus Kacang': 'assets/bahan/kacang.png'},\n        {'Kecap': 'assets/bahan/kecap.png'},\n      ],\n      kalori: '400 kkal'),\n  Makanan(\n      nama: 'Pecel',\n      deskripsi: 'Sayuran dengan bumbu kacang',\n      gambar: 'assets/pecel.jpg',\n      detail:\n          'Makanan pecel adalah makanan yang menggunakan bumbu sambal kacang sebagai bahan utamanya yang dicampur dengan aneka jenis sayuran. Asal kata dan daerah pecel belum diketahui secara pasti, tetapi dalam bahasa Jawa, pecel dapat diartikan sebagai “tumbuk” atau dihancurkan dengan cara ditumbuk.',\n      waktubuka: '08.00-16.00',\n      harga: 'Rp 8.000',\n      gambarlain: [\n        'assets/pecel1.jpg',\n        'assets/pecel2.jpg',\n        'assets/pecel3.jpg',\n      ],\n      bahan: [\n        {'Sayur': 'assets/bahan/sayur.png'},\n        {'Tahu': 'assets/bahan/tahu.png'},\n        {'Kentang': 'assets/bahan/kentang.png'},\n        {'Telur': 'assets/bahan/telur.png'},\n        {'Saus Kacang': 'assets/bahan/kacang.png'},\n      ],\n      kalori: '426 kkal'),\n];\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi List: List&lt;Makanan&gt; listMakanan = [...]\n\nList&lt;Makanan&gt; mengindikasikan bahwa listMakanan adalah sebuah List yang berisi objek-objek bertipe Makanan.\n[] menandakan bahwa List tersebut akan diinisialisasi dengan sejumlah elemen objek Makanan.\n\nInisialisasi elemen-elemen List:\n\nSetiap elemen dalam List adalah sebuah objek Makanan yang diinisialisasi dengan menggunakan sintaksis Makanan(...).\n\n\n\n\n\nSilahkan tambahkan atribut yang sesuai dalam ListItem() sesuai dengan atribut yang ada dalam kelas makanan. Gantikan widget container yang berada di dalam row dengan Image.asset(). Kemudian, ubah data dalam teks agar menggunakan atribut yang telah ditambahkan sebelumnya.\n\nfinal String nama;\nfinal String detail;\nfinal String deskripsi;\nfinal String gambar;\nfinal String waktubuka;\nfinal String harga;\nfinal String kalori;\nfinal List&lt;String&gt; gambarlain;\nfinal List&lt;Map&lt;String, String&gt;&gt; bahan;\n\nconst ListItem(\n  {super.key,\n  required this.nama,\n  required this.harga,\n  required this.gambarlain,\n  required this.detail,\n  required this.kalori,\n  required this.bahan,\n  required this.waktubuka,\n  required this.deskripsi,\n  required this.gambar}\n);\nRow(\n    crossAxisAlignment: CrossAxisAlignment.center,\n    children: [\n        // widget untuk menampilkan gambar lokal\n        Image.asset(\n            gambar,\n            height: 75,\n            width: 75,\n        ),\n        SizedBox(\n        width: 10,\n        ),\n        Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n            Text(\n            nama,\n            style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n            ),\n            ),\n            Text(\n            deskripsi,\n            style: TextStyle(\n                fontWeight: FontWeight.w500,\n            ),\n            ),\n        ],\n        )\n    ],\n),\n\nSilakan buka kembali file “home_page.dart” dan ubah bagian yang menampilkan ListView menjadi menggunakan ListView.builder.\n\nListView.builder(\n    // mengatur panjang / jumlah item dalam list\n    itemCount: list_makanan.length,\n    padding: EdgeInsets.all(10),\n    itemBuilder: (context, index) {\n        return ListItem(\n        nama: list_makanan[index].nama,\n        deskripsi: list_makanan[index].deskripsi,\n        gambar: list_makanan[index].gambar,\n        );\n    },\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nitemCount: list_makanan.length,: Ini mengatur jumlah item dalam daftar, yang diambil dari panjang (length) dari daftar list_makanan. Jadi, jumlah item dalam daftar akan sesuai dengan jumlah elemen dalam list_makanan.\nitemBuilder: (context, index) { ... },: Ini adalah fungsi yang digunakan untuk membangun tampilan item dalam daftar. Fungsi ini akan dipanggil secara berulang untuk setiap item dalam daftar.\n\ncontext: Objek context yang memberikan informasi tentang lingkungan tampilan saat ini.\nindex: Indeks item saat ini dalam daftar.\n\nreturn ListItem(...);: Di dalam itemBuilder, setiap item dalam daftar dibangun dengan menggunakan widget ListItem. Nilai-nilai yang diperlukan untuk membangun ListItem diambil dari list_makanan dengan menggunakan index saat ini. Ini berarti setiap item dalam daftar akan memiliki nama, deskripsi, dan gambar yang sesuai dengan elemen dalam list_makanan\n\n\n\n\nSelanjutnya buatlah file baru bernama “detail_page.dart” sebagai tampilan halaman detail kuliner.\n\n\n\n\nLangkah ke 15\n\n\nclass DetailPage extends StatelessWidget {\n  const DetailPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n\nSilahkan desain halaman baru sesuai dengan preferensi kalian. Berikut adalah contoh desain untuk halaman detail.\n\n\n\n\nLangkah ke 16\n\n\nStack(\n  children: &lt;Widget&gt;[\n    Image.asset(\n      gambar,\n      scale: 0.5,\n    ),\n    SafeArea(\n      child: Padding(\n        padding: const EdgeInsets.all(12.0),\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: [\n            CircleAvatar(\n              backgroundColor: Colors.grey,\n              child: IconButton(\n                icon: const Icon(\n                  Icons.arrow_back,\n                  color: Colors.white,\n                ),\n                onPressed: () {\n                  Navigator.pop(context);\n                },\n              ),\n            ),\n            const FavouriteButton(),\n          ],\n        ),\n      ),\n    ),\n  ],\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\nWidget Stack untuk menempatkan beberapa widget di atas satu sama lain. Lebih spesifiknya, kode ini menciptakan tampilan yang terdiri dari:\n\nImage.asset: Ini adalah widget yang menampilkan gambar dari berkas aset (asset) dalam proyek Flutter. Variabel ‘gambar’ akan diisi sesuai dengan data yang ada di List ‘list_makanan’ yang diambil dari folder ‘assets’, lalu diberi skala 0.5 (setengah dari ukuran aslinya).\nSafeArea: Widget ini memastikan bahwa konten aplikasi ditempatkan di dalam “area aman” pada layar perangkat, sehingga tidak terganggu oleh elemen-elemen sistem seperti notch atau tombol navigasi.\nPadding: Widget ini menambahkan ruang kosong (padding) di sekitar widget anaknya. Di sini, ada ruang kosong sekitar 12.0 pixel di sekeliling widget yang ada di dalamnya.\nRow: Widget ini mengatur widget anaknya dalam satu baris secara horizontal. Properti mainAxisAlignment diatur menjadi MainAxisAlignment.spaceBetween, yang berarti widget anak dalam Row akan ditempatkan dengan jarak yang sama di antara kiri dan kanan, memberikan ruang kosong di antara mereka.\nCircleAvatar: Ini adalah widget yang menampilkan gambar bulat atau avatar. Di dalamnya, ada IconButton yang menampilkan ikon panah kembali (back arrow) dengan latar belakang abu-abu (Colors.grey). Ketika ikon ini diklik (onPressed), itu akan mengarahkan pengguna kembali ke halaman sebelumnya menggunakan Navigator.pop(context).\nFavouriteButton: Memanggil widget FavouriteButton yang ada di ‘detail_page.dart’\n\n\n\n\n\n\nLangkah ke 16_1\n\n\nContainer(\n  margin: const EdgeInsets.only(top: 16.0),\n  child: Text(\n    nama,\n    textAlign: TextAlign.center,\n    style: const TextStyle(\n        fontSize: 30.0, fontWeight: FontWeight.bold),\n  ),\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nContainer: Ini adalah widget yang digunakan untuk mengatur tampilan dan tata letak dari elemen-elemen di dalamnya. Pada kode ini, widget Container digunakan untuk mengelilingi teks yang akan ditampilkan.\nmargin: const EdgeInsets.only(top: 16.0): Ini adalah properti margin yang mengatur margin di sekitar Container. Di sini di atur margin 16 untuk top only (hanya margin atas).\nWidget Text yang dimasukkan di ‘child’ dari Container, Ini adalah widget yang digunakan untuk menampilkan teks. Di dalamnya, teks yang akan ditampilkan diambil dari variabel nama. Properti textAlign diatur menjadi TextAlign.center, yang berarti teks akan ditampilkan secara terpusat (centered) secara horizontal.\n‘Text’ dapat di styling dengan property style, yang diisi dengan widget TextStyle untuk styling text. Di sini, teks diberi gaya dengan ukuran font sebesar 30.0 dan bobot font sebagai Bold.\n\n\n\n\n\n\nLangkah ke 16_2\n\n\nContainer(\n  margin: const EdgeInsets.symmetric(vertical: 16.0),\n  child: Row(\n    mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n    children: &lt;Widget&gt;[\n      Column(\n        children: [\n          const Icon(Icons.access_time_filled,\n              color: Color.fromARGB(255, 255, 230, 0)),\n          const SizedBox(\n            height: 8,\n          ),\n          Text(\n            waktubuka,\n          ),\n        ],\n      ),\n      Column(\n        children: [\n          const Icon(\n            Icons.local_fire_department,\n            color: Colors.red,\n          ),\n          const SizedBox(\n            height: 8,\n          ),\n          Text(\n            kalori,\n          ),\n        ],\n      ),\n      Column(\n        children: [\n          const Icon(Icons.monetization_on, color: Colors.green),\n          const SizedBox(\n            height: 8,\n          ),\n          Text(\n            harga,\n          ),\n        ],\n      ),\n    ],\n  ),\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nContainer dengan properti margin untuk mengatur margin untuk symmetric vertical atau margin top dan bottom sebesar 16. Container membukus Row.\nRow : digunakan untuk mengatur tata letak susunan dalam satu baris horizontal. Properti mainAxisAlignment diatur menjadi MainAxisAlignment.spaceEvenly, yang berarti widget anak dalam Row akan ditempatkan dengan jarak yang sama di antara mereka, memberikan ruang yang merata. Row disini diisi dengan 3 column menggunakan properti children.\nTiga Column: Setiap Column berisi ikon, jarak kosong (SizedBox), dan teks yang menggambarkan informasi tertentu. Setiap Column mewadahi komponen-komponen ini secara vertikal.\nDalam Column pertama, ada sebuah ikon yang merupakan jam (Icons.access_time_filled) yang diwarnai dengan kuning (Color.fromARGB(255, 255, 230, 0)), diikuti oleh sebuah SizedBox dengan ketinggian 8 pixel, dan kemudian teks yang diambil dari variabel waktubuka.\nDalam Column kedua, ada sebuah ikon yang merupakan api (Icons.local_fire_department) yang diwarnai dengan merah, diikuti oleh sebuah SizedBox dengan ketinggian 8 piksel, dan kemudian teks yang diambil dari variabel kalori.\nDalam Column ketiga, ada sebuah ikon yang merupakan uang (Icons.monetization_on) yang diwarnai dengan hijau, diikuti oleh sebuah SizedBox dengan ketinggian 8 piksel, dan kemudian teks yang diambil dari variabel harga.\n\n\n\n\n\n\nLangkah ke 16_3\n\n\nContainer(\n  padding: const EdgeInsets.all(16),\n  child: Text(\n    detail,\n    textAlign: TextAlign.center,\n    style: TextStyle(\n      fontSize: 16,\n    ),\n  ),\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nContainer: Ini adalah widget yang digunakan untuk mengatur tampilan dan tata letak dari elemen-elemen di dalamnya.\n\npadding: const EdgeInsets.all(16): Properti padding mengatur ruang kosong (padding) sekitar elemen di dalam Container. Di sini, ada padding sebesar 16 piksel di sekeliling Container. Ini memberikan ruang kosong di sekitar teks yang akan ditampilkan.\nchild: Properti ini adalah widget anak yang akan ditempatkan di dalam Container. Pada kode ini, widget anaknya adalah Text.\n\nText: Ini adalah widget yang digunakan untuk menampilkan teks.\n\ndetail: Teks yang akan ditampilkan diambil dari variabel detail.\ntextAlign: TextAlign.center: Properti ini mengatur teks untuk ditampilkan secara terpusat (centered) secara horizontal.\nstyle: Properti ini mengatur gaya atau tampilan teks. Di sini, teks diberi ukuran font sebesar 16 piksel.\n\n\n\n\n\n\n\nLangkah ke 16_4\n\n\nSizedBox(\n  height: 150,\n  child: ListView(\n    scrollDirection: Axis.horizontal,\n    children: gambarlain.map((url) {\n      return Padding(\n        padding: const EdgeInsets.all(4),\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(10),\n          child: Image.asset(url),\n        ),\n      );\n    }).toList(),\n  ),\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nSizedBox: Ini adalah widget yang mengatur ukuran kotak kosong (box) dengan tinggi sebesar 150 piksel. Ini digunakan untuk mengatur tinggi dari area yang akan menampung daftar gambar.\nListView: Ini adalah widget yang digunakan untuk membuat daftar elemen dalam sebuah daftar gulir (scrollable list).\n\n\nscrollDirection: Axis.horizontal: Properti scrollDirection diatur menjadi Axis.horizontal, yang berarti daftar akan digulir secara horizontal.\nchildren: Diisi dengan daftar gambar-gambar yang akan ditampilkan. Gambar-gambar ini diambil dari daftar gambarlain menggunakan metode map. Setiap URL gambar dalam gambarlain diproses dengan map dan ditempatkan dalam sebuah Padding widget yang memiliki padding 4 piksel di sekelilingnya. Di dalam Padding, gambar tersebut ditempatkan dalam ClipRRect.\nPadding: Ini adalah widget yang digunakan untuk menambahkan ruang kosong (padding) di sekeliling widget anaknya. Di sini, padding sebesar 4 piksel diberikan di sekeliling setiap gambar.\nClipRRect: Ini adalah widget yang digunakan untuk membulatkan sudut dari widget anaknya. Properti borderRadius digunakan untuk mengatur sudut gambar sehingga menjadi bulat dengan radius 10 piksel.\nImage.asset(url): Ini adalah widget yang digunakan untuk menampilkan gambar dari berkas aset (asset) dalam proyek Flutter. URL gambar diambil dari daftar gambarlain.\n\n\n\n\n\n\nLangkah ke 16_5\n\n\nSizedBox(\n  height: 20,\n),\nContainer(\n  child: Text(\n    'Bahan Racikan',\n    textAlign: TextAlign.center,\n    style: TextStyle(fontSize: 30, fontWeight: FontWeight.bold),\n  ),\n),\nSizedBox(\n  height: 20,\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nSizedBox yang digunakan untuk menambahkan ruang kosong vertikal sebesar 20 piksel. Dengan kata lain, elemen ini adalah spasi kosong yang menggeser elemen selanjutnya ke bawah sejauh 20 pixel.\nContainer yang membungkus widget Text. Text disini digunakan untuk menampilkan teks “Bahan Racikan”. Teks ini memiliki pengaturan tampilan sebagai berikut:\n\n\ntextAlign: Teks akan ditampilkan secara terpusat (centered) secara horizontal.\nstyle: Ini adalah pengaturan gaya teks. Teks ini diberikan ukuran font sebesar 30 pixel (fontSize: 30) dan ketebalan teks yang diatur sebagai FontWeight.bold. Dengan demikian, teks “Bahan Racikan” akan ditampilkan dengan ukuran font yang besar dan tebal.\n\n\nSizedBox kedua yang digunakan untuk menambahkan ruang kosong vertikal sebesar 20 pixel lagi. Ini bisa digunakan untuk memisahkan elemen yang ada setelahnya dari elemen “Bahan Racikan” dengan ruang kosong.\n\n\n\n\n\n\nLangkah ke 16_6\n\n\nContainer(\n  height: 100,\n  child: ListView.separated(\n      scrollDirection: Axis.horizontal,\n      itemBuilder: (context, index) =&gt; Container(\n            padding: EdgeInsets.all(10),\n            decoration: BoxDecoration(\n              color: Colors.white,\n              borderRadius: BorderRadius.circular(40),\n            ),\n            child: Column(\n              children: [\n                Image.asset(bahan[index].values.first, width: 52),\n                Text(bahan[index].keys.first),\n              ],\n            ),\n          ),\n      separatorBuilder: (_, index) =&gt; SizedBox(\n            width: 15,\n          ),\n      itemCount: bahan.length),\n),\nSizedBox(\n  height: 50,\n),\nContainer(\n  height: 100,\n  child: ListView.separated(\n      scrollDirection: Axis.horizontal,\n      itemBuilder: (context, index) =&gt; Container(\n            padding: EdgeInsets.all(10),\n            decoration: BoxDecoration(\n              color: Colors.white,\n              borderRadius: BorderRadius.circular(40),\n            ),\n            child: Column(\n              children: [\n                Image.asset(bahan[index].values.first, width: 52),\n                Text(bahan[index].keys.first),\n              ],\n            ),\n          ),\n      separatorBuilder: (_, index) =&gt; SizedBox(\n            width: 15,\n          ),\n      itemCount: bahan.length),\n),\nSizedBox(\n  height: 50,\n)\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nContainer dengan property height 100 untuk membungkus ListView untuk item tiap bahan racikan.\nListView.separated: Membuat array linier daftar “item” yang dapat digulir dengan panjang tetap yang dipisahkan oleh “pemisah” item daftar.\n\nscrollDirection: Axis.horizontal: Ini mengatur bahwa ListView akan digulir secara horizontal, sehingga elemen-elemen bahan akan tampil secara horizontal.\nitemBuilder: Ini adalah fungsi yang akan membangun setiap elemen dalam ListView. Setiap elemen dalam ListView adalah Container yang berisi gambar dan teks untuk mewakili bahan.\nDi dalam Container, ada:\n\npadding: EdgeInsets.all(10): Ini mengatur padding sekeliling kontennya agar ada ruang kosong di sekelilingnya.\ndecoration: Ini adalah properti yang digunakan untuk mengatur dekorasi Container. Di sini, Container diberi latar belakang putih (color: Colors.white) dan memiliki sudut yang dibulatkan dengan radius 40 piksel (borderRadius: BorderRadius.circular(40)).\nDi dalam Container, terdapat Column yang berisi:\n\nImage.asset(bahan[index].values.first, width: 52): Ini menampilkan gambar bahan dengan lebar 52 piksel. Gambar diambil dari daftar bahan berdasarkan indeks index dan kemudian mengambil nilai pertama (values.first).\nText(bahan[index].keys.first): Ini menampilkan teks nama bahan. Nama bahan diambil dari daftar bahan berdasarkan indeks index dan kemudian mengambil kunci pertama (keys.first).\n\n\nseparatorBuilder: Ini adalah fungsi yang digunakan untuk membangun pemisah antara elemen-elemen dalam ListView. Di sini, pemisahnya adalah SizedBox dengan lebar 15 piksel (width: 15).\nitemCount: Properti ini mengatur jumlah elemen dalam ListView berdasarkan panjang daftar bahan.\n\nSizedBox kedua yang digunakan untuk menambahkan ruang kosong vertikal dengan tinggi 50 piksel. Ini bisa digunakan untuk memisahkan elemen setelahnya dari elemen-elemen bahan.\n\n\n\n\n\n\nLangkah ke 16_7\n\n\nSetelah itu, gabungkan semua code di atas dan wrap dengan Scaffold\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    backgroundColor: const Color(0xFFFFF3E0),\n    body: SingleChildScrollView(\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: &lt;Widget&gt;[\n          Stack(\n            //...\n          ),\n          Container(\n            //...\n          ),\n          Container(\n            //...\n          ),\n          Container(\n            //...\n          ),\n          SizedBox(\n            //...\n          ),\n          SizedBox(\n            //...\n          ),\n          Container(\n            //...\n          ),\n          SizedBox(\n            //...\n          ),\n          Container(\n            //...\n          ),\n          SizedBox(\n            //...\n          )\n        ],\n      ),\n    ),\n  );\n}\n\nDesain untuk halaman detail sudah jadi tetapi belum bisa diakses melalui halaman utama, untuk mengakses halaman detail, bisa membuka file “list_item.dart” dan tambahkan Navigator pada onTap.\n\nInkWell(\n  onTap: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) =&gt; DetailPage()));\n  },\n),\n\nSekarang setiap item dalam list dapat membuka halaman detail, namun data yang ditampilkan dalam halaman detail masih statis. Maka dari itu kita perlu menambahkan beberapa kode pada DetailPage agar data yang ditampikan menjadi dinamis. Buka kembali “detail_page.dart” dan tambahkan kode berikut.\n\nimport 'package:flutter/material.dart';\n\nclass DetailPage extends StatelessWidget {\n  final String nama;\n  final String detail;\n  final String deskripsi;\n  final String gambar;\n  final String waktubuka;\n  final String harga;\n  final String kalori;\n  final List&lt;String&gt; gambarlain;\n  final List&lt;Map&lt;String, String&gt;&gt; bahan;\n\n  const DetailPage(\n      {super.key,\n      required this.nama,\n      required this.harga,\n      required this.gambarlain,\n      required this.detail,\n      required this.kalori,\n      required this.waktubuka,\n      required this.deskripsi,\n      required this.gambar,\n      required this.bahan});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      //...\n    );\n  }\n}\n\nclass FavouriteButton extends StatefulWidget {\n  const FavouriteButton({super.key});\n\n  @override\n  State&lt;FavouriteButton&gt; createState() =&gt; _FavouriteButtonState();\n}\n\nclass _FavouriteButtonState extends State&lt;FavouriteButton&gt; {\n  bool isFavourite = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return IconButton(\n      icon: Icon(\n        isFavourite ? Icons.favorite : Icons.favorite_border,\n        color: Colors.red,\n        size: 40,\n      ),\n      onPressed: () {\n        setState(() {\n          isFavourite = !isFavourite;\n        });\n      },\n    );\n  }\n}\n\nSilahkan kembali ke home_page.dart dan update bagian ListView builder supaya bisa menampilkan semua data yang terdapat di `list_makanan.\n\nListView.builder(\n  itemCount: list_makanan.length,\n  padding: const EdgeInsets.all(10),\n  itemBuilder: (context, index) {\n    return ListItem(\n      nama: list_makanan[index].nama,\n      deskripsi: list_makanan[index].deskripsi,\n      gambar: list_makanan[index].gambar,\n      detail: list_makanan[index].detail,\n      waktubuka: list_makanan[index].waktubuka,\n      harga: list_makanan[index].harga,\n      gambarlain: list_makanan[index].gambarlain,\n      bahan: list_makanan[index].bahan,\n      kalori: list_makanan[index].kalori,\n    );\n  },\n),\n\nMasih dalam file list_item.dart, sesuaikan Navigator pada onTap.\n\nInkWell(\n  onTap: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) =&gt; DetailPage(\n          nama: nama,\n          gambar: gambar,\n          kalori: kalori,\n          deskripsi: deskripsi,\n          waktubuka: waktubuka,\n          detail: detail,\n          harga: harga,\n          gambarlain: gambarlain,\n          bahan: bahan,\n        ),\n      ),\n    );\n  },\n  //... \n);\n\nSetelah melalui beberapa tahapan diatas, maka studi kasus List Makanan sudah selesai dibuat. Untuk hasil dari halaman detail adalah sebagai berikut:\n\n\n\n\nHasil"
  },
  {
    "objectID": "studi_kasus_3.html",
    "href": "studi_kasus_3.html",
    "title": "13  Studi Kasus 3",
    "section": "",
    "text": "14 Studi Kasus 3 : Todo-List\n\n\n\n\n\n\nTips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 6\n\n\nPada studi kasus bab ini kita akan mencoba membuat aplikasi yang dapat melakukan crud untuk membuat aplikasi todo list sederhana dengan menggunakan sqlite pada flutter. Pertama-tama silahkan buat projek flutter baru. Lalu setelah itu tambahkan dependencies sqflite, path_provider dan path pada pubspec.yaml.\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nSelanjutnya buat file todo.dart yang akan digunakan untuk menyimpan class Todo sebagai model data.\n\n\n\nStudi Kasus Todo-List\n\n\nclass Todo {\n  final int id;\n  final String title;\n  final String description;\n  final bool completed;\n  Todo({\n    required this.id,\n    required this.title,\n    required this.description,\n    required this.completed,\n  });\n\n  Map&lt;String, dynamic&gt; toMap() {\n    return &lt;String, dynamic&gt;{\n      'id': id,\n      'title': title,\n      'description': description,\n      'completed': completed,\n    };\n  }\n\n  factory Todo.fromMap(Map&lt;String, dynamic&gt; map) {\n    return Todo(\n      id: map['id'] as int,\n      title: map['title'] as String,\n      description: map['description'] as String,\n      completed: map['completed'] == 0 ? false : true,\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nKode di atas adalah definisi dari sebuah class bernama Todo yang merepresentasikan sebuah tugas atau aktivitas. Class ini memiliki properti-properti seperti id (nomor identifikasi), title (judul), description (deskripsi), dan completed (status selesai atau belum).\nClass Todo memiliki dua method. Method pertama, toMap(), digunakan untuk mengubah objek Todo menjadi bentuk Map yang dapat digunakan untuk penyimpanan atau pemrosesan data. Method kedua, fromMap(), adalah constructor khusus yang digunakan untuk membuat objek Todo dari data yang diberikan dalam bentuk Map.\n\n\nSetelah itu buat file database_helper.dart. Didalam file ini kita akan membuat class DatabaseHelper.\n\n\n\nStudi Kasus Todo-List\n\n\nimport 'package:flutter_crud_sqflite/todo.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\nimport 'dart:async';\nimport 'dart:io' as io;\nimport 'package:path_provider/path_provider.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper _instance = DatabaseHelper.internal();\n\n  factory DatabaseHelper() =&gt; _instance;\n\n  static Database? _db;\n\n  Future&lt;Database?&gt; get db async {\n    if (_db != null) return _db;\n    _db = await initDb();\n    return _db;\n  }\n\n  DatabaseHelper.internal();\n\n  Future&lt;Database&gt; initDb() async {\n    io.Directory documentsDirectory = await getApplicationDocumentsDirectory();\n    String path = join(\n      documentsDirectory.path,\n      'todolist.db',\n    );\n    var theDb = await openDatabase(\n      path,\n      version: 1,\n      onCreate: _onCreate,\n    );\n    return theDb;\n  }\n\n  void _onCreate(Database db, int version) async {\n    await db.execute('''\n        CREATE TABLE \n        IF NOT EXISTS todos \n        (\n          id INTEGER PRIMARY KEY,\n          title TEXT NOT NULL,\n          description TEXT,\n          completed INTEGER NOT NULL\n        )   \n        ''');\n  }\n\n  Future&lt;List&lt;Todo&gt;&gt; getAllTodos() async {\n    var dbClient = await db;\n    var todos = await dbClient!.query('todos');\n    return todos.map((todo) =&gt; Todo.fromMap(todo)).toList();\n  }\n\n  Future&lt;Todo&gt; getTodoById(int id) async {\n    var dbClient = await db;\n    var todo = await dbClient!.query('todos', where: 'id = ?', whereArgs: [id]);\n    return todo.map((todo) =&gt; Todo.fromMap(todo)).single;\n  }\n\n  Future&lt;List&lt;Todo&gt;&gt; getTodoByTitle(String title) async {\n    var dbClient = await db;\n    var todo = await dbClient!\n        .query('todos', where: 'title like ?', whereArgs: [title]);\n    return todo.map((todo) =&gt; Todo.fromMap(todo)).toList();\n  }\n\n  Future&lt;int&gt; insertTodo(Todo todo) async {\n    var dbClient = await db;\n    return await dbClient!.insert('todos', todo.toMap());\n  }\n\n  Future&lt;int&gt; updateTodo(Todo todo) async {\n    var dbClient = await db;\n    return await dbClient!\n        .update('todos', todo.toMap(), where: 'id = ?', whereArgs: [todo.id]);\n  }\n\n  Future&lt;int&gt; deleteTodo(int id) async {\n    var dbClient = await db;\n    return await dbClient!.delete('todos', where: 'id = ?', whereArgs: [id]);\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nKode di atas adalah sebuah file Dart yang berisi definisi dari class DatabaseHelper. Class ini bertanggung jawab untuk mengelola operasi-operasi database terkait objek Todo menggunakan paket sqflite.\nBeberapa poin penting dalam class DatabaseHelper ini:\n\nTerdapat sebuah singleton instance _instance dari DatabaseHelper yang akan digunakan untuk mengakses class ini.\nTerdapat sebuah method factory DatabaseHelper() yang mengembalikan instance dari _instance. Ini digunakan untuk memastikan bahwa hanya satu instance dari DatabaseHelper yang ada.\nTerdapat sebuah variabel _db yang akan menyimpan instance dari Database. Variabel ini digunakan untuk menyimpan database yang dibuka dan menghindari membuka koneksi database berulang-ulang.\nTerdapat method initDb() yang akan menginisialisasi database. Method ini akan membuka database dengan menggunakan openDatabase() dari paket sqflite dan mengembalikan instance database yang telah dibuka.\nTerdapat method _onCreate() yang akan dipanggil saat database pertama kali dibuat. Method ini akan mengeksekusi perintah SQL untuk membuat tabel todos dalam database.\nTerdapat beberapa method lain seperti getAllTodos(), getTodoById(), getTodoByTitle(), insertTodo(), updateTodo(), dan deleteTodo(). Method-method ini digunakan untuk melakukan operasi CRUD (Create, Read, Update, Delete) terhadap tabel todos dalam database. Mereka menggunakan instance database yang telah dibuka untuk menjalankan perintah-perintah SQL yang sesuai.\n\n\n\nSelanjutnya buatlah satu tampilan sederhana untuk menampung data dari database, menambah data, menghapus data, mengupdate data, dan melakukan pencarian data pada main.dart. Tampilan akan ditampung dalam StatefullWidget dikarenakan data yang digunakan dalam tampilan tersebut akan berubah menyesuaikan dengan isi database. Berikut adalah contoh dari tampilannya.\nimport 'package:flutter/material.dart';\nimport 'package:flutter_crud_sqflite/database_helper.dart';\nimport 'package:flutter_crud_sqflite/todo.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Todo-List App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const TodoApp(),\n    );\n  }\n}\n\nclass TodoApp extends StatefulWidget {\n  const TodoApp({Key? key}) : super(key: key);\n\n  @override\n  State&lt;TodoApp&gt; createState() =&gt; _TodoAppState();\n}\n\nclass _TodoAppState extends State&lt;TodoApp&gt; {\n  final TextEditingController _searchController = TextEditingController();\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _descController = TextEditingController();\n  List&lt;Todo&gt; _todos = [];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Todo List'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: const InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) {},\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _todos.length,\n              itemBuilder: (context, index) {\n                var todo = _todos[index];\n                return ListTile(\n                  leading: todo.completed\n                      ? IconButton(\n                          icon: const Icon(Icons.check_circle),\n                          onPressed: () {},\n                        )\n                      : IconButton(\n                          icon: const Icon(Icons.radio_button_unchecked),\n                          onPressed: () {},\n                        ),\n                  title: Text(todo.title),\n                  subtitle: Text(todo.description),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.delete),\n                    onPressed: () {},\n                  ),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          showDialog(\n            context: context,\n            builder: (context) =&gt; AlertDialog(\n              title: const Text('Tambah Todo'),\n              content: SizedBox(\n                width: 200,\n                height: 200,\n                child: Column(\n                  children: [\n                    TextField(\n                      controller: _titleController,\n                      decoration: const InputDecoration(hintText: 'Judul todo'),\n                    ),\n                    TextField(\n                      controller: _descController,\n                      decoration:\n                          const InputDecoration(hintText: 'Deskripsi todo'),\n                    ),\n                  ],\n                ),\n              ),\n              actions: [\n                TextButton(\n                  child: const Text('Batalkan'),\n                  onPressed: () =&gt; Navigator.pop(context),\n                ),\n                TextButton(\n                  child: const Text('Tambah'),\n                  onPressed: () {},\n                ),\n              ],\n            ),\n          );\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\n\nStudi Kasus Todo-List\n\n\nSetelah itu tambahkan beberapa atribut dan method dalam TodoApp supaya dapat terhubung dengan database melalui DatabaseHelper\nclass TodoApp extends StatefulWidget {\n  const TodoApp({Key? key}) : super(key: key);\n\n  @override\n  State&lt;TodoApp&gt; createState() =&gt; _TodoAppState();\n}\n\nclass _TodoAppState extends State&lt;TodoApp&gt; {\n  final TextEditingController _searchController = TextEditingController();\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _descController = TextEditingController();\n  final dbHelper = DatabaseHelper();\n  List&lt;Todo&gt; _todos = [];\n  int _count = 0;\n\n  void refreshItemList() async {\n    final todos = await dbHelper.getAllTodos();\n    setState(() {\n      _todos = todos;\n    });\n  }\n\n  void searchItems() async {\n    final keyword = _searchController.text.trim();\n    if (keyword.isNotEmpty) {\n      final todos = await dbHelper.getTodoByTitle(keyword);\n      setState(() {\n        _todos = todos;\n      });\n    } else {\n      refreshItemList();\n    }\n  }\n\n  void addItem(String title, String desc) async {\n    final todo =\n        Todo(id: _count, title: title, description: desc, completed: false);\n    await dbHelper.insertTodo(todo);\n    refreshItemList();\n  }\n\n  void updateItem(Todo todo, bool completed) async {\n    final item = Todo(\n      id: todo.id,\n      title: todo.title,\n      description: todo.description,\n      completed: completed,\n    );\n    await dbHelper.updateTodo(item);\n    refreshItemList();\n  }\n\n  void deleteItem(int id) async {\n    await dbHelper.deleteTodo(id);\n    refreshItemList();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ...;\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nrefreshItemList(): Fungsi ini digunakan untuk memperbarui daftar item pada tampilan. Pertama, fungsi ini memanggil getAllTodos() dari dbHelper untuk mendapatkan semua objek Todo dari database. Kemudian, daftar _todos diperbarui dengan nilai yang baru, dan setState() dipanggil untuk memperbarui tampilan.\nsearchItems(): Fungsi ini digunakan untuk melakukan pencarian item berdasarkan kata kunci. Pertama, kata kunci diambil dari _searchController.text.trim(). Jika kata kunci tidak kosong, fungsi ini memanggil getTodoByTitle(keyword) dari dbHelper untuk mendapatkan daftar Todo yang sesuai dengan kata kunci. Daftar _todos diperbarui dengan nilai yang baru, dan setState() dipanggil untuk memperbarui tampilan. Jika kata kunci kosong, fungsi ini memanggil refreshItemList() untuk memperbarui daftar item.\naddItem(String title, String desc): Fungsi ini digunakan untuk menambahkan item baru ke database. Pertama, objek Todo baru dibuat dengan nilai-nilai yang diberikan. Kemudian, insertTodo() dari dbHelper dipanggil untuk memasukkan objek Todo ke dalam database. Setelah itu, refreshItemList() dipanggil untuk memperbarui daftar item.\nupdateItem(Todo todo, bool completed): Fungsi ini digunakan untuk memperbarui status selesai dari sebuah item. Pertama, objek Todo baru dibuat dengan nilai-nilai yang sama seperti objek todo yang diberikan, kecuali nilai completed yang diubah sesuai dengan parameter completed. Kemudian, updateTodo() dari dbHelper dipanggil untuk memperbarui objek Todo dalam database. Setelah itu, refreshItemList() dipanggil untuk memperbarui daftar item.\ndeleteItem(int id): Fungsi ini digunakan untuk menghapus sebuah item dari database berdasarkan ID. Pertama, deleteTodo() dari dbHelper dipanggil untuk menghapus objek Todo dari database. Setelah itu, refreshItemList() dipanggil untuk memperbarui daftar item.\n\n\n\nLalu agar ketika pertama kali dibuka data dari database langsung ditampilkan panggil method refreshItemList() pada initState()\n@override\nvoid initState() {\n  refreshItemList();\n  super.initState();\n}\nlangkah terakhir adalah dengan memanggil method method tersebut dengan widget dalam aplikasi seperti tombol, text field, dan listview.\nclass TodoApp extends StatefulWidget {\n  const TodoApp({Key? key}) : super(key: key);\n\n  @override\n  State&lt;TodoApp&gt; createState() =&gt; _TodoAppState();\n}\n\nclass _TodoAppState extends State&lt;TodoApp&gt; {\n  ...\n\n  @override\n  void initState() {\n    refreshItemList();\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Todo List'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: const InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) {\n                searchItems();\n              },\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _todos.length,\n              itemBuilder: (context, index) {\n                var todo = _todos[index];\n                return ListTile(\n                  leading: todo.completed\n                      ? IconButton(\n                          icon: const Icon(Icons.check_circle),\n                          onPressed: () {\n                            updateItem(todo, !todo.completed);\n                          },\n                        )\n                      : IconButton(\n                          icon: const Icon(Icons.radio_button_unchecked),\n                          onPressed: () {\n                            updateItem(todo, !todo.completed);\n                          },\n                        ),\n                  title: Text(todo.title),\n                  subtitle: Text(todo.description),\n                  trailing: IconButton(\n                    icon: const Icon(Icons.delete),\n                    onPressed: () {\n                      deleteItem(todo.id);\n                    },\n                  ),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          showDialog(\n            context: context,\n            builder: (context) =&gt; AlertDialog(\n              title: const Text('Tambah Todo'),\n              content: SizedBox(\n                width: 200,\n                height: 200,\n                child: Column(\n                  children: [\n                    TextField(\n                      controller: _titleController,\n                      decoration: const InputDecoration(hintText: 'Judul todo'),\n                    ),\n                    TextField(\n                      controller: _descController,\n                      decoration:\n                          const InputDecoration(hintText: 'Deskripsi todo'),\n                    ),\n                  ],\n                ),\n              ),\n              actions: [\n                TextButton(\n                  child: const Text('Batalkan'),\n                  onPressed: () =&gt; Navigator.pop(context),\n                ),\n                TextButton(\n                  child: const Text('Tambah'),\n                  onPressed: () {\n                    addItem(_titleController.text, _descController.text);\n\n                    Navigator.pop(context);\n                    setState(() {\n                      _count = _count + 1;\n                    });\n                  },\n                ),\n              ],\n            ),\n          );\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}"
  },
  {
    "objectID": "studi_kasus_4.html",
    "href": "studi_kasus_4.html",
    "title": "14  Studi Kasus 4",
    "section": "",
    "text": "15 Studi Kasus 4 : Aplikasi Biodata\n\n\n\n\n\n\nTips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 1 hingga 3\n\n\nTutorial kali ini juga teserdia dalam bentuk video yang bisa di tonton pada tautan berikut.\n\n\nDalam studi kasus ini, kita akan membuat sebuah aplikasi satu halaman yang menampilkan biodata. Kurang lebih inilah isi konten aplikasi biodata nya nanti.\n\n\n\nDesign aplikasi\n\n\n\nBuatlah project flutter baru, pilihlah yang empty application\n\n\n\n\nBuat project\n\n\n\nClear default code di lib/main.dart.\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Placeholder();\n  }\n}\n\nBuatlah folder assets, dan masukkan gambar yang ingin kalian gunakan.\n\n\n\n\nBuat folder assets\n\n\nLalu tambahkan folder “assets” pada file pubspec.yaml agar gambar yang terdapat di dalamnya dapat diakses oleh aplikasi.\n\n\n\nMasukan folder assets di pubspec.yaml\n\n\n\nBuatlah variable biodata yang disimpan dalam bentuk Map &lt;String,String&gt; di class MainApp, dan assign value nya secara langsung di constructor\n\nclass MainApp extends StatelessWidget {\n  final biodata = &lt;String, String&gt;{};\n\n  MainApp({super.key}) {\n    biodata['name'] = 'Barbatos (Venti)';\n    biodata['email'] = 'venti@genshinimpact.com';\n    biodata['phone'] = '+62345678910';\n    biodata['image'] = 'Venti_Card.png';\n    biodata['hobby'] = 'Bermain Lira dan Flute';\n    biodata['addr'] = 'St. Freeway in side of Moonstad';\n    biodata['desc'] =\n        \"'A bard that seems to have arrived on some unknown wind — sometimes sings songs as old as the hills, and other times sings poems fresh and new. Likes apples and lively places but is not a fan of cheese or anything sticky. When using his Anemo power to control the wind, it often appears as feathers, as he's fond of that which appears light and breezy.'\";\n  }\n\n  ///\n}\n\nBuatlah UI sesuai design, kita menggunakan widget MaterialApp dengan Scaffold di dalamnya seperti aplikasi pada biasanya, lalu kita menggunakan widget column untuk layouting utama agar tiap konten tersusun vertical. Pertama kita isi widget container untuk judul nama, dan image untuk gambar profile.\n\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: \"Aplikasi Biodata\",\n      home: Scaffold(\n        appBar: AppBar(title: Text(\"Aplukasi Biodata\")),\n        body: SingleChildScrollView(\n          padding: EdgeInsets.all(10),\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              Container(\n                padding: EdgeInsets.all(10),\n                alignment: Alignment.center,\n                width: double.infinity,\n                \n                decoration: BoxDecoration(color: Colors.black),\n                child: Text(\n                  biodata['name'] ?? '',\n                  style: TextStyle(\n                    fontWeight: FontWeight.bold,\n                    fontSize: 20,\n                    color: Colors.white,\n                  ),\n                ),\n              ),\n              Image(image: AssetImage('assets/${biodata[\"image\"] ?? ''}')),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n\n\n\n\n\nTips\n\n\n\n\nSingleChildScrolledView : digunakan agar jika konten melebihi layar, maka konten dapat di scroll.\nContainer : digunakan untuk membuat kotak nama judul, dengan box decoration untuk background color.\nText untuk nama, dan Image untuk gambar profile mengambil dari variable biodata, diberi ?? ’’ untuk null safety agar jika value ter detect null maka value akan menjadi String kosong.\n\n\n\n\n\n\nTampilan langkah ke-5\n\n\n\nSelanjutnya untuk 3 button, kita gunakan widget Row untuk layout yang diisi 3 elevated button. Karena button harus penuh maka kita harus membungkusnya dengan Expanded agar dapat mengisi ruang kosong. Karena perlu 3 button, dengan syling yang sama bisa kita extract widgetnya ke method yang disini diberi nama btnContact.\n\n  Column(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              ///\n              SizedBox(\n                height: 10,\n              ),\n              Row(\n                children: [\n                  btnContact(Icons.alternate_email, Colors.green[900]),\n                  btnContact(Icons.mark_email_read, Colors.blueAccent),\n                  btnContact(Icons.phone, Colors.deepPurple),\n                ],\n              ),\n            ],\n          ),\n\n  Expanded btnContact(IconData icon, var color) {\n    return Expanded(\n      child: ElevatedButton(\n        onPressed: () {},\n        child: Icon(icon),\n        style: ElevatedButton.styleFrom(\n            shape: StadiumBorder(),\n            backgroundColor: color,\n            foregroundColor: Colors.white),\n      ),\n    );\n  }\n\n\n\n\n\n\nTips\n\n\n\n\nSizedbox : digunakan untuk memberi jarak antar widget(seperti fungsi margin).\nExpanded : agar size widget di dalamnya dapat mengisi ruang kosong.\nbtnContact disini memiliki parameter IconData untuk icon dan var untuk background color, agar styling tiap button dapat berbeda.\n\n\n\n\n\n\nTampilan langkah ke-6\n\n\n\nBerikutnya buat text untuk hobby dan alamat, kita menggunakan row agar layout tertata dengan baik, karena layout itu digunakan berkali kali, alangkah lebih baik kita extract sebagai method seperti dengan btnContact.\n\n\nColumn(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n                ///\n              SizedBox(\n                height: 10,\n              ),\n              textAttribute('Hobby', biodata['hobby'] ?? ''),\n              textAttribute('Alamat', biodata['addr'] ?? ''),\n            ],\n          ),\n\nRow textAttribute(String judul, String teks) {\n    return Row(\n      children: [\n        Container(\n          width: 80,\n          child: Text(\n            '- $judul ',\n            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 20),\n          ),\n        ),\n        Text(\n          ': ',\n          style: TextStyle(fontSize: 18),\n        ),\n        Text(\n          teks,\n          style: TextStyle(fontSize: 18),\n        ),\n      ],\n    );\n  }\n\n\n\n\n\n\nTips\n\n\n\n\ntextAttribute : method untuk membuat layout text dengan Row, dengan parameter judul dan teks, agar dapat passing valuenya.\nContainer : agar width judul dapat sama tiap\n\n\n\n\n\n\nTampilan langkah ke-7\n\n\n\nKarena Judul deskripsi mirip dengan judul untuk nama, maka Container judul nama dapat kita extract ke method, dengan parameter Color untuk background color dan Text untuk value teksnya\n\n\nColumn(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              teksKotak(Colors.black, biodata['name'] ?? ''),\n\n              ///\n              \n              SizedBox(\n                height: 10,\n              ),\n              teksKotak(Colors.black38, 'Deskripsi'),\n              SizedBox(\n                height: 10,\n              ),\n            ],\n          ),\n\n  Container teksKotak(Color bgColor, String teks) {\n    return Container(\n      padding: EdgeInsets.all(10),\n      alignment: Alignment.center,\n      width: double.infinity,\n      decoration: BoxDecoration(color: bgColor),\n      child: Text(\n        teks,\n        style: const TextStyle(\n          fontWeight: FontWeight.bold,\n          fontSize: 20,\n          color: Colors.white,\n        ),\n      ),\n    );\n  }\n\n\n\nTampilan langkah ke-8\n\n\n\nLalu untuk deskripsi menggunakan Widget Text biasa,\n\nColumn(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n                  ///\n                Text(\n                biodata['desc'] ?? '',\n                style: TextStyle(\n                  fontSize: 18,\n                ),\n                textAlign: TextAlign.center,\n              ),\n            ],\n          ),\n\n\n\nTampilan langkah ke-9\n\n\n\nUI nya sudah selesai, sekarang kita menambahkan klik button untuk menuju ke link, maka kita membutuhkan plugin tambahan. Di pubspec.yaml tambahkan url_launcher di dependency dan pilih versi terakhir atau versi yang compatible.\n\n\n\n\nTampilan langkah ke-10\n\n\n\nBalik lagi ke main, lalu import 'package:url_launcher/url_launcher.dart';, lalu buat fungsi baru untuk buka url nya.\n\n  Future launch(String uri) async {\n    if (!await launchUrl(Uri.parse(uri))) {\n      throw Exception('Tidak dapat memanggil : $uri');\n    }\n  }\nLalu kita modifikasi btnContact di bagian onPressed, kita isi dengan panggil fungsi tadi, karena tiap button url nya berbeda beda, maka kita tambahkan di parameter agar bisa di set satu satu.\n  Expanded btnContact(IconData icon, var color, String uri) {\n    return Expanded(\n      child: ElevatedButton(\n        onPressed: () {\n          launch(uri);\n        },\n        child: Icon(icon),\n        style: ElevatedButton.styleFrom(\n            shape: StadiumBorder(),\n            backgroundColor: color,\n            foregroundColor: Colors.white),\n      ),\n    );\n  }\nJangan lupa di button nya juga kita tambahin parameter sesuai link nya\nColumn(\n            mainAxisAlignment: MainAxisAlignment.start,\n            children: [\n              Row(\n                children: [\n                  btnContact(Icons.alternate_email, Colors.green[900],\n                      \"mailto:${biodata['email'] ?? ''}\"),\n                  btnContact(Icons.mark_email_read, Colors.blueAccent,\n                      \"https://wa.me/${biodata['phone']}\"),\n                  btnContact(\n                      Icons.phone, Colors.deepPurple, \"tel:${biodata['phone']}\")\n                ],\n              ),\n              \n            ],\n          ),"
  },
  {
    "objectID": "proyek_1.html",
    "href": "proyek_1.html",
    "title": "15  Proyek Kalkulator",
    "section": "",
    "text": "Proyek Kalkulator\nAplikasi Kalkulator adalah proyek Flutter yang bertujuan untuk membuat sebuah kalkulator fungsional yang dapat digunakan untuk melakukan operasi matematika dasar. Aplikasi ini akan menyediakan antarmuka pengguna yang intuitif dan responsif untuk memudahkan pengguna dalam melakukan perhitungan."
  },
  {
    "objectID": "proyek_1.html#fitur-utama",
    "href": "proyek_1.html#fitur-utama",
    "title": "15  Proyek Kalkulator",
    "section": "15.1 Fitur Utama",
    "text": "15.1 Fitur Utama\n\nTampilan Antarmuka Pengguna:\n\nAplikasi akan memiliki tampilan antarmuka pengguna yang terdiri dari tombol-tombol angka, operator, dan fungsi matematika seperti tambah, kurang, kali, bagi, dan sebagainya.\nTampilan akan dirancang agar mudah digunakan dan memberikan pengalaman pengguna yang intuitif.\n\nPerhitungan Matematika:\n\nPengguna dapat melakukan perhitungan matematika dasar seperti penjumlahan, pengurangan, perkalian, dan pembagian.\nAplikasi akan memiliki logika yang memungkinkan pengguna melakukan perhitungan secara berurutan, menggabungkan beberapa operasi, dan menghasilkan hasil yang akurat.\n\nDesain Responsif:\n\nAplikasi akan memiliki desain yang responsif dan bisa diakses dengan baik di berbagai perangkat dengan ukuran layar yang berbeda."
  },
  {
    "objectID": "proyek_1.html#teknologi-yang-digunakan",
    "href": "proyek_1.html#teknologi-yang-digunakan",
    "title": "15  Proyek Kalkulator",
    "section": "15.2 Teknologi yang Digunakan",
    "text": "15.2 Teknologi yang Digunakan\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nDart sebagai bahasa pemrograman untuk mengembangkan logika aplikasi.\nWidget dan State Management dari Flutter untuk mengatur tampilan dan interaksi pengguna.\nMatematika dasar menggunakan operator dan fungsi bawaan dari Dart.\n\nTujuan dari proyek ini adalah memberikan pengguna sebuah kalkulator yang dapat digunakan dengan mudah, memiliki performa yang baik, dan memberikan hasil perhitungan yang akurat. Aplikasi Kalkulator ini akan menjadi alat yang berguna untuk keperluan perhitungan sehari-hari, baik untuk kebutuhan pribadi maupun profesional.\nSelama mengembangkan aplikasi Kalkulator, penting untuk memastikan bahwa logika perhitungan matematika benar, antarmuka pengguna responsif dan intuitif, serta mengikuti pedoman desain terbaik dari Flutter."
  },
  {
    "objectID": "proyek_1.html#contoh-tampilan-aplikasi",
    "href": "proyek_1.html#contoh-tampilan-aplikasi",
    "title": "15  Proyek Kalkulator",
    "section": "15.3 Contoh tampilan aplikasi",
    "text": "15.3 Contoh tampilan aplikasi\nAplikasi kalkulator hanya memiliki satu halaman saja dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nContoh tampilan kalkulator"
  },
  {
    "objectID": "proyek_1.html#langkah-pembuatan-aplikasi-aplikasi",
    "href": "proyek_1.html#langkah-pembuatan-aplikasi-aplikasi",
    "title": "15  Proyek Kalkulator",
    "section": "15.4 Langkah Pembuatan Aplikasi aplikasi",
    "text": "15.4 Langkah Pembuatan Aplikasi aplikasi\n\nPersiapan Awal\n\nPastikan Komputer Anda masih terinstal Flutter dan Dart.\nBuat proyek baru menggunakan perintah flutter create nama_proyek.\nPastikan Anda telah membuat file ‘custom_button.dart’ dan ‘custom_number_button.dart’ untuk tombol yang akan digunakan\n\nDesain Tampilan Antarmuka\n\nBuka file ‘lib/main.dart’ dan rancang tampilan kalkulator menggunakan widget seperti ‘Column’, ‘Row’, atau ‘FlatButton’ untuk tombol-tombol angka, operator, dan fungsi matematika.\nDalam hal ini gunakan Scaffold dengan AppBar untuk memasukkan widget kita.\nSesuaikan gaya dan desain tampilan sesuai dengan contoh yang Anda berikan.\n‘MaterialApp’ digunakan untuk mengatur tema aplikasi dan menentukan halaman utama (MyHomePage).\n\nLogika Perhitungan\n\nBuat kelas atau fungsi yang mengelola logika perhitungan matematika.\nAnda bisa menggunakan variabel untuk menyimpan angka-angka dan operator yang dimasukkan oleh pengguna.\nBuat fungsi-fungsi untuk menjalankan operasi matematika seperti penjumlahan, pengurangan, perkalian, dan pembagian.\nPada bagian _MyHomePageState, telah ditentukan beberapa metode yang mengatur logika perhitungan. Metode ini akan memproses input dari tombol-tombol yang ditekan oleh pengguna dan memperbarui tampilan sesuai.\n\nInteraksi Pengguna\n\nHubungkan tombol-tombol dengan logika perhitungan yang telah Anda buat.\nKetika pengguna menekan tombol angka atau operator, perbarui tampilan dan logika perhitungan sesuai.\nTombol operasi dan angka dengan menggunakan widget CustomOperationButton dan CustomNumberButton. Implementasi widget-widget ini dalam file yang telah dibuat dalam file external (‘custom_button.dart’ dan ‘custom_number_button.dart’).\n\nMenampilkan Hasil\n\nBuat widget untuk menampilkan hasil perhitungan.\nKetika pengguna menekan tombol “=” atau selesai menginput operasi, tampilkan hasil perhitungan pada widget ini.\nPada tampilan, gunakan Text widget untuk menampilkan field1, operator, dan field2. Ini adalah hasil dari logika perhitungan yang telah di definisikan sebelumnya.\nGunakan widget Column, Row, dan GridView untuk mengatur tata letak tombol-tombol. Atur properti seperti crossAxisCount dan shrinkWrap sesuai kebutuhan.\nSetiap kali tombol operasi atau angka ditekan, aplikasi memanggil metode yang telah di tentukan sebelumnya. Misalnya, saat tombol “1” ditekan, Anda memanggil inputField(“1”).\n‘setState’ untuk memperbarui state ketika ada perubahan dalam logika perhitungan atau tampilan.\n\nJalankan Aplikasi\n\nPada main function, jalankan aplikasi dengan runApp(MyApp()).\n\nTesting dan Debugging\n\nUji aplikasi secara menyeluruh untuk memastikan semua operasi matematika berjalan dengan benar sesuai alur logika pada aplikasi kalkulator yang anda dibuat"
  },
  {
    "objectID": "proyek_2.html",
    "href": "proyek_2.html",
    "title": "16  Proyek 2",
    "section": "",
    "text": "Proyek Password Vault\nAplikasi Password Vault adalah sebuah proyek Flutter yang bertujuan untuk menyediakan tempat aman untuk menyimpan dan mengelola kata sandi (password) pengguna. Aplikasi ini akan menggunakan penyimpanan lokal untuk menyimpan data pengguna dan kata sandi yang dienkripsi."
  },
  {
    "objectID": "proyek_2.html#fitur-utama",
    "href": "proyek_2.html#fitur-utama",
    "title": "16  Proyek 2",
    "section": "16.1 Fitur Utama:",
    "text": "16.1 Fitur Utama:\n\nRegistrasi dan Login Pengguna:\n\nPengguna dapat membuat akun baru dengan menyediakan email dan kata sandi.\nPengguna dapat masuk ke akun mereka dengan mengautentikasi email dan kata sandi.\n\nPenyimpanan Data Kata Sandi:\n\nPengguna dapat menyimpan data kata sandi mereka dengan memasukkan judul, username, dan kata sandi untuk setiap entri.\nData kata sandi akan disimpan secara aman dalam penyimpanan lokal dengan menggunakan enkripsi.\n\nManajemen Data Kata Sandi:\n\nPengguna dapat melihat daftar entri kata sandi yang disimpan.\nPengguna dapat menambahkan, mengedit, atau menghapus entri kata sandi.\nPengguna dapat mencari entri kata sandi berdasarkan judul atau username.\n\nKeamanan dan Enkripsi:\n\nData kata sandi disimpan dalam penyimpanan lokal dengan menggunakan teknik enkripsi yang aman.\nPengguna akan diminta memasukkan kata sandi master saat masuk ke aplikasi untuk membuka akses ke data kata sandi.\n\nUI yang Responsif:\n\nAplikasi akan memiliki antarmuka pengguna yang responsif dan menarik, memungkinkan pengguna untuk dengan mudah menavigasi dan menggunakan fitur-fitur yang ada."
  },
  {
    "objectID": "proyek_2.html#teknologi-yang-digunakan",
    "href": "proyek_2.html#teknologi-yang-digunakan",
    "title": "16  Proyek 2",
    "section": "16.2 Teknologi yang Digunakan:",
    "text": "16.2 Teknologi yang Digunakan:\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nPackage sqflite untuk mengakses dan menyimpan data dalam penyimpanan lokal SQLite.\nPackage encrypt untuk melakukan enkripsi dan dekripsi data kata sandi.\nPackage flutter_secure_storage untuk menyimpan kata sandi master dengan aman.\n\nTujuan dari proyek ini adalah memberikan pengguna aplikasi sebuah solusi yang aman dan mudah digunakan untuk mengelola kata sandi mereka. Aplikasi Password Vault ini akan memberikan perlindungan terhadap pencurian kata sandi dan memberikan akses cepat ke informasi penting yang dibutuhkan oleh pengguna dalam kehidupan digital mereka.\nCatatan: Penting untuk selalu mengutamakan keamanan dalam pengembangan aplikasi semacam ini. Pastikan untuk menggunakan praktik terbaik dalam hal pengamanan dan enkripsi data yang sensitif."
  },
  {
    "objectID": "proyek_2.html#contoh-tampilan-aplikasi",
    "href": "proyek_2.html#contoh-tampilan-aplikasi",
    "title": "16  Proyek 2",
    "section": "16.3 Contoh tampilan aplikasi:",
    "text": "16.3 Contoh tampilan aplikasi:\nAplikasi Password Vault memiliki beberapa halaman dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nRancangan tampilan password vault"
  },
  {
    "objectID": "proyek_2.html#langkah-pengerjaan",
    "href": "proyek_2.html#langkah-pengerjaan",
    "title": "16  Proyek 2",
    "section": "16.4 Langkah Pengerjaan",
    "text": "16.4 Langkah Pengerjaan\n\n16.4.1 Persiapan & Perancangan Antar Muka\n\nMembuat proyek flutter baru (dengan VS Code)\nMenambahkan library yang diperlukan, serta penjelasan kegunaan library tersebut\nMembuat Halaman Login (tanpa logika dulu):\n\nMembuat komponen yang diperlukan\nMenambahkan komponen ke halaman login\nMenambahkan style komponen yang diperlukan\nMemanggil halaman login di main page\n\nMembuat halaman register (tanpa logika juga):\n\nMembuat komponen yang diperlukan\nMenambahkan komponen ke halaman register\nMemanggil halaman register dari halaman login\n\nMembuat halaman home page (Tanpa list kategori dulu):\n\nMembuat halaman home page kosongan\nMembuat halaman Add Category (tanpa logika)\nMenambahkan floatActionButton untuk manggil halaman add category dari halaman homepage\n\nMenambahkan list category pada home page:\n\nMembuat beberapa array of object dummy dulu\nMembuat list kategory dengan ListView (on pressed masih kosongan dulu)\n\nMembuat halaman list_password (tanpa data list password dulu):\n\nMembuat halaman list_password kosongan\nMembuat halaman Add Password (tanpa logika)\nMenambahkan floatActionButton untuk memanggil halaman add Password dari halaman list password\n\nMenambahkan List password pada halaman List password:\n\nMembuat beberapa array of object dummy dulu\nMembuat list password dengan ListView (on pressed masih kosongan dulu)\n\nMembuat halaman detail password:\n\nMembuat komponen custom username box\nMembuat komponen custom password box (tanpa fitur copy dan reveal password dulu)\nMembuat halaman detail password\nMenambahkan pemanggilan halaman detail password pada on pressed list password\n\n\n\n\n16.4.2 Local Storage untuk Register & Login\n\n\n\n16.4.3 Akses Basis Data Lokal"
  },
  {
    "objectID": "proyek_3.html",
    "href": "proyek_3.html",
    "title": "17  Proyek 3",
    "section": "",
    "text": "18 Proyek 3 : Lapor Book\n\n\n\n\n\n\nTips\n\n\n\nPada proyek ini disarankan sudah membaca Bab 1 hingga 10"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kursus Flutter",
    "section": "",
    "text": "Pengantar\nBengkel Koding Pemrograman Mobile dapat digunakan sebagai pengayaan materi mahasiswa yang mengambil mata kuliah pemrograman perangkat bergerak, sekaligus sebagai bahan belajar khusus untuk pengembangan aplikasi bergerak menggunakan Flutter.\nSecara garis besar, materi dalam course ini akan dipecah menjadi 2 bagian utama yaitu :\n\nKonsep\nStudi Kasus dan Proyek\n\nBagian Konsep dapat digunakan sebagai referensi cara penggunaan fitur-fitur pada pemrograman flutter. Sedangkan pada bagian studi kasus dan proyek merupakan penerapan konsep tersebut dalam sebuah aplikasi sederhana."
  }
]