[
  {
    "objectID": "8_proyek_2.html",
    "href": "8_proyek_2.html",
    "title": "8  Proyek Password Vault",
    "section": "",
    "text": "Proyek Password Vault\nAplikasi Password Vault adalah sebuah proyek Flutter yang bertujuan untuk menyediakan tempat aman untuk menyimpan dan mengelola kata sandi (password) pengguna. Aplikasi ini akan menggunakan penyimpanan lokal untuk menyimpan data pengguna dan kata sandi yang dienkripsi."
  },
  {
    "objectID": "8_proyek_2.html#fitur-utama",
    "href": "8_proyek_2.html#fitur-utama",
    "title": "12  Proyek Password Vault",
    "section": "12.1 Fitur Utama:",
    "text": "12.1 Fitur Utama:\n\nRegistrasi dan Login Pengguna:\n\nPengguna dapat membuat akun baru dengan menyediakan email dan kata sandi.\nPengguna dapat masuk ke akun mereka dengan mengautentikasi email dan kata sandi.\n\nPenyimpanan Data Kata Sandi:\n\nPengguna dapat menyimpan data kata sandi mereka dengan memasukkan judul, username, dan kata sandi untuk setiap entri.\nData kata sandi akan disimpan secara aman dalam penyimpanan lokal dengan menggunakan enkripsi.\n\nManajemen Data Kata Sandi:\n\nPengguna dapat melihat daftar entri kata sandi yang disimpan.\nPengguna dapat menambahkan, mengedit, atau menghapus entri kata sandi.\nPengguna dapat mencari entri kata sandi berdasarkan judul atau username.\n\nKeamanan dan Enkripsi:\n\nData kata sandi disimpan dalam penyimpanan lokal dengan menggunakan teknik enkripsi yang aman.\nPengguna akan diminta memasukkan kata sandi master saat masuk ke aplikasi untuk membuka akses ke data kata sandi.\n\nUI yang Responsif:\n\nAplikasi akan memiliki antarmuka pengguna yang responsif dan menarik, memungkinkan pengguna untuk dengan mudah menavigasi dan menggunakan fitur-fitur yang ada."
  },
  {
    "objectID": "8_proyek_2.html#teknologi-yang-digunakan",
    "href": "8_proyek_2.html#teknologi-yang-digunakan",
    "title": "12  Proyek Password Vault",
    "section": "12.2 Teknologi yang Digunakan:",
    "text": "12.2 Teknologi yang Digunakan:\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nPackage sqflite untuk mengakses dan menyimpan data dalam penyimpanan lokal SQLite.\nPackage encrypt untuk melakukan enkripsi dan dekripsi data kata sandi.\nPackage flutter_secure_storage untuk menyimpan kata sandi master dengan aman.\n\nTujuan dari proyek ini adalah memberikan pengguna aplikasi sebuah solusi yang aman dan mudah digunakan untuk mengelola kata sandi mereka. Aplikasi Password Vault ini akan memberikan perlindungan terhadap pencurian kata sandi dan memberikan akses cepat ke informasi penting yang dibutuhkan oleh pengguna dalam kehidupan digital mereka.\nCatatan: Penting untuk selalu mengutamakan keamanan dalam pengembangan aplikasi semacam ini. Pastikan untuk menggunakan praktik terbaik dalam hal pengamanan dan enkripsi data yang sensitif."
  },
  {
    "objectID": "8_proyek_2.html#contoh-tampilan-aplikasi",
    "href": "8_proyek_2.html#contoh-tampilan-aplikasi",
    "title": "12  Proyek Password Vault",
    "section": "12.3 Contoh tampilan aplikasi:",
    "text": "12.3 Contoh tampilan aplikasi:\nAplikasi Password Vault memiliki beberapa halaman dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nRancangan tampilan password vault"
  },
  {
    "objectID": "1_intro_flutter.html",
    "href": "1_intro_flutter.html",
    "title": "2  Pengenalan Flutter",
    "section": "",
    "text": "Pengenalan Flutter\nFlutter adalah framework yang sangat keren yang akan kita pelajari di sini."
  },
  {
    "objectID": "1_intro_flutter.html#apa-itu-flutter",
    "href": "1_intro_flutter.html#apa-itu-flutter",
    "title": "1  Pengenalan Flutter",
    "section": "1.1 Apa itu Flutter?",
    "text": "1.1 Apa itu Flutter?\nFlutter adalah sebuah SDK (Software Development Kit) open source yang dikembangkan oleh Google. Tujuan utamanya adalah untuk memudahkan pembuatan aplikasi yang dapat berjalan di berbagai platform, atau yang biasa disebut sebagai multi-platform. Dengan Flutter, pengembang dapat membangun aplikasi untuk sistem operasi Android, iOS, Web, Windows, Linux, dan MacOS dengan menggunakan kode yang sama, tanpa perlu menulis ulang kode secara terpisah. Selain itu, Flutter juga dapat digunakan baik sebagai bagian dari aplikasi native yang sudah ada maupun sebagai dasar pembangunan aplikasi baru."
  },
  {
    "objectID": "1_intro_flutter.html#kelebihan-dan-kekurangan-flutter",
    "href": "1_intro_flutter.html#kelebihan-dan-kekurangan-flutter",
    "title": "1  Pengenalan Flutter",
    "section": "1.2 Kelebihan dan kekurangan Flutter",
    "text": "1.2 Kelebihan dan kekurangan Flutter\n\n1.2.1 kelebihan dari Flutter\n\nFlutter memungkinkan pembuatan aplikasi dengan desain yang indah dan kreatif. Framework ini memberikan kebebasan dalam mengatur desain aplikasi tanpa banyak batasan. Dengan kemampuannya untuk mengontrol setiap piksel di layar, Flutter memudahkan pembuatan animasi yang menarik. Selain itu, Flutter menyediakan beragam komponen material design yang dapat digunakan dengan baik pada platform Android, iOS, dan web.\nFlutter memiliki kinerja yang sangat cepat. Flutter menggunakan mesin grafis bernama Skia-2D, yang juga digunakan oleh Chrome dan Android. Selain itu, kode Flutter ditulis dalam bahasa Dart, yang memungkinkan kompilasi ke kode native 32-bit dan 64-bit ARM untuk iOS dan Android. Dengan demikian, aplikasi Flutter dapat berjalan dengan kinerja tinggi dan responsif.\nFlutter sangat produktif dalam pengembangan aplikasi. Fitur hot-reload yang dimilikinya memungkinkan pengembang untuk melihat perubahan kode secara langsung dan secara real-time. Dengan hot-reload, perubahan yang dilakukan pada kode dapat segera diterapkan pada perangkat tanpa perlu menunggu proses restart dan tanpa kehilangan state aplikasi.\nFlutter adalah proyek open source yang bersifat terbuka. Dengan lisensi BSD, Flutter mendorong partisipasi dari komunitas pengembang di seluruh dunia. Banyak kontributor telah berkontribusi dalam pengembangan Flutter, dan ada banyak plugin yang telah dibuat oleh para pengembang.\n\n\n\n1.2.2 Kekurangan dari Flutter\n\nFlutter masih baru dibandingkan dengan beberapa framework lainnya. Ini berarti bahwa dokumentasi dan sumber daya yang tersedia mungkin belum sebanyak yang tersedia untuk framework yang lebih mapan.\nUkuran file aplikasi Flutter lebih besar dibandingkan dengan aplikasi yang dibangun menggunakan teknologi lain. Ini dapat menjadi masalah dalam situasi di mana ukuran file menjadi perhatian utama, seperti dalam pengembangan aplikasi dengan batasan ruang penyimpanan atau kecepatan internet yang terbatas.\nDukungan untuk beberapa fitur platform mungkin masih terbatas atau belum sepenuhnya matang dalam Flutter. Meskipun Flutter berusaha untuk menyediakan pengalaman yang seragam di berbagai platform, ada kemungkinan bahwa beberapa fitur khusus platform tertentu mungkin tidak sepenuhnya didukung atau membutuhkan upaya lebih dalam implementasinya."
  },
  {
    "objectID": "1_intro_flutter.html#instalasi-flutter-dan-android-studio",
    "href": "1_intro_flutter.html#instalasi-flutter-dan-android-studio",
    "title": "1  Pengenalan Flutter",
    "section": "1.3 Instalasi Flutter dan Android Studio",
    "text": "1.3 Instalasi Flutter dan Android Studio\n\n1.3.1 Instalasi Android Studio\n\nDownload android studio, dapat melalui link berikut\n\n\n\n\nWeb download android studio\n\n\n\n\n\nDownload android studio\n\n\n\n\n\nDownload android studio\n\n\n\n\nInstal android studio, buka file android studio yang telah didownload\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\n\nInstalasi android studio\n\n\n\n\nSetup wizard android studio, buka android studio yang telah diinstal\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\n\nSetup wizard android studio\n\n\n\n\nAndroid studio berhasil diinstal\n\n\n\n\n1.3.2 Instalasi Flutter\n\nDownload flutter sesuai OS perangkat yang digunakan, dapat melalui link berikut\n\n\n\n\nWeb download flutter\n\n\n\n\n\nWeb download flutter windows\n\n\n\n\n\nDownload flutter\n\n\n\n\nEkstrak file flutter yang telah diunduh, letakkan di lokasi instalasi yang diinginkan, misal di folder (“C:/Src/flutter”)\n\n\n\n\nFolder setup flutter\n\n\n\n\nUpdate path\n\n\nCari “env” di search bar windows, pilih “Edit the system environment variables”\n\n\n\n\nMencari menu system environment variables\n\n\n\n\npilih “environment variables”\n\n\n\n\nMembuka system properties\n\n\n\n\npilih “path” pada “user variables …”\n\n\n\n\nMembuka environment variables\n\n\n\n\nTambahkan alamat folder bin flutter (C:/Src/flutter/bin) pada Path\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\nJika belum ada “Path” pada “user variables”, bisa menambahkan sendiri disertai alamat folder bin flutter (C:/Src/flutter/bin).\n\n\n\n\nMenyalin flutter folder path\n\n\n\n\n\nMenambahkan flutter folder path\n\n\n\n\nCek instalasi flutter\n\n\nBuka terminal, ketik “flutter doctor”, jalankan.\n\n\n\n\nMencari terminal pada menu start\n\n\n\n\n\nMenjalankan flutter doctor\n\n\n\n\nPada hasil ditemukan 2 masalah, atasi masalah sesuai dengan panduan masing-masing masalah (masalah “visual studio …” tidak wajib diatasi)\n\n\n\n\nCek instalasi flutter doctor issue\n\n\n* Cara mengatasi “cmdline-tools component is missing”\n\n\nSetelah masalah diatasi, jalankan “flutter doctor” untuk cek apakah masalah sudah teratasi.\n\n\n\n\nMenjalankan flutter doctor\n\n\n\n\nSet up Android emulator\n\n\nBuka android studio, pilih “titik tiga (:)”, pilih”Virtual Device Manager”\n\n\n\n\nAndroid studio halaman awal\n\n\n\n\nPilih “Create device”\n\n\n\n\nMembuat virtual device pada android studio\n\n\n\n\nPilih perangkat yang diinginkan\n\n\n\n\nMemilih hardware untuk virtual device\n\n\n\n\nPilih system image yang diinginkan\n\n\n\n\nMemilih system image untuk virtual device\n\n\n\n\nPada “emulated performance”, pilih “Hardware-GLES 2.0” untuk mengizinkan hardware acceleration, lalu Finish\n\n\n\n\nMemilih hardwate-GLES untuk virtual device\n\n\n\n\nMenyetujui lisensi android, buka terminal, ketikkan “flutter doctor —android-licenses”, lalu enter\n\n\n\n\nMenyetujui android licenses dengan flutter doctor\n\n\n\n\nJalankan “flutter doctor” pada terminal\n\n\n\n\nMenjalankan flutter doctor\n\n\n\nFlutter berhasil diinstal\n\n\n\n\n1.3.3 Instalasi VSCode\n\nDownload VSCode sesuai dengan OS perangkat yang digunakan, dapat melalui link berikut,\n\n\n\n\nDownload VSCode\n\n\n\n\n\nDownload VSCode\n\n\n\n\nInstal VSCode, buka file VSCode yang telah didownload\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\n\nInstalasi VSCode\n\n\n\n\nVSCode berhasil diinstal\n\n\n\n\n1.3.4 Konfigurasi flutter dan dart di android studio (Windows atau Linux)\n\nBuka android studio, buka salah satu project, pilih “File”, pilih “setting”\n\n\n\n\nMembuka setting android studio\n\n\n\n\nPilih “Plugins”, pilih “Marketplace”, cari “flutter”, lalu install, lalu apply\n\n\n\n\nintall flutter plugin pada android studio\n\n\n\nRestart android studio\n\n\n\n\n1.3.5 Konfigurasi flutter dan dart di VS Code\n\nInstall VSCode jika belum ada\nInstal plugin flutter dan dart\n\n\nBuka VS Code, pilih “view”, pilih”Command Palette”\n\n\n\n\nMembuka command palette pada vs code\n\n\n\nKetik “Install”, pilih “Extensions: Install Extensions”\n\n\n\n\nMemilih menu install extension\n\n\n\nPilih “extensions” → cari “flutter” → lalu instal (otomatis menginstal plugin dart juga)\n\n\n\n\nintall flutter extension pada vscode\n\n\n\n\nValidasi konfigurasi\n\n\nPilih “view” → “command palette”\n\n\n\n\nMembuka command palette\n\n\n\nKetik “flutter” → pilih “Flutter: Run Flutter Doctor”\n\n\n\n\nMenjalankan flutter doctor pada vs code\n\n\n\nTinjau panel output untuk melihat masalah\n\n\n\n\nMeninjau output dari flutter doctor pada vs code\n\n\n\nJika sudah tidaka ada masalah, Environment flutter sudah siap digunakan"
  },
  {
    "objectID": "2_dasar_dart.html",
    "href": "2_dasar_dart.html",
    "title": "3  Dasar Pemrograman Dart",
    "section": "",
    "text": "Dasar Pemrograman Dart\nDart adalah bahasa pemrograman yang agak aneh. Aneh tapi nyata, emang bener ada bahasanya dan dipake."
  },
  {
    "objectID": "2_dasar_dart.html#apa-itu-dart",
    "href": "2_dasar_dart.html#apa-itu-dart",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.1 Apa itu Dart?",
    "text": "2.1 Apa itu Dart?\nDart merupakan bahasa pemrograman yang open source yang dikembangkan oleh Google dengan tujuan untuk membuat aplikasi multiplatform seperti mobile, desktop, dan web. Tujuan awal pembuatan Dart adalah untuk menggantikan JavaScript yang dinilai memiliki banyak kelemahan."
  },
  {
    "objectID": "2_dasar_dart.html#menjalankan-dart",
    "href": "2_dasar_dart.html#menjalankan-dart",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.2 Menjalankan Dart",
    "text": "2.2 Menjalankan Dart\nPada Bab ini akan belajar pemrograman dasar menggunakan dart, untuk menjalankan dart bisa menggunakan cara berikut:\n\n2.2.1 Menggunakan VSCode\n\nBuka VSCode\n\n\n\n\nBuka VSCode\n\n\n\nBuat/buka folder, pilih “File”, pilih “Open Folder”, pilih lokasi penyimpanan, pilih “Select Folder”\n\n\n\n\nBuat/Buka Folder\n\n\n\n\n\nPilih Folder\n\n\n\n\n\nFolder dibuka\n\n\n\nBuat file baru, klik simbol “New file”, ketik “[nama file].dart”, lalu enter\n\n\n\n\nBuat file dart baru\n\n\n\nKetik program dart\n\nvoid main() {\nprint('Hello, World\n  !');\n}\n\n\n\nKetik program dart\n\n\n\nJalankan program, klik “Run Code”, maka akan muncul hasilnya di output\n\n\n\n\nJalankan program\n\n\n\n\n\nHasil program\n\n\n\n\n\n2.2.2 Menggunakan DartPad\n\nBuka Dartpad, dapat melalui link berikut\n\n\n\n\nBuka DartPad\n\n\n\nKetik program dart\n\nvoid main() {\n  print('Hello, World\n    !');\n}\n\n\n\nKetik program dart\n\n\n\nJalankan program, klik “Run”, maka akan muncul hasilnya di console\n\n\n\n\nJalankan program"
  },
  {
    "objectID": "2_dasar_dart.html#tipe-data-dan-variabel",
    "href": "2_dasar_dart.html#tipe-data-dan-variabel",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.3 Tipe data dan Variabel",
    "text": "2.3 Tipe data dan Variabel\n\n2.3.1 Variabel\nDalam dart, variabel dapat dideklarasikan secara eksplisit maupun implisit.\n\n2.3.1.1 Deklarasi eksplisit\nDeklarasi secara eksplisit dilakukan dengan cara menambahkan tipe data di depan nama variabel.\nString greetings = 'Hello World!';  // String\nint myAge = 20;                     // integers\nbool isHuman = true;                // boolean\n\n\n2.3.1.2 Deklarasi implisit\nDeklarasi secara implisit dilakukan dengan cara menambahkan kata kunci var di depan nama variabel. Sebagai bahasa yang memiliki fitur type inference dart dapat menentukan tipe data otomatis dengan kata kunci var.\nvar greetings = 'Hello World!';     // String\nvar myAge = 20;                     // integers\nvar isHuman = true;                 // boolean\n\n\n\n2.3.2 Tipe data\nSebagai tambah berikut adalah tabel berbagai jenis tipe data yang dapat digunakan dalam bahasa pemrograman Dart beserta deskripsi dan contoh singkatnya:\n\n\n\n\n\n\n\n\nTipe\nDekripsi\nContoh\n\n\n\n\nint\nBilangan bulat\n5, 7, 8\n\n\ndouble\nBilangan desimal\n3.14, 1.23\n\n\nnum\nBilangan bulat dan bilangan desimal\n5, 3.14, -99.00\n\n\nbool\nBoolean\ntrue, false\n\n\nString\nTeks yang terdiri dari 0 atau beberapa karakter\n“udinus”, ““,”G”\n\n\nList\nDaftar nilai\n[1, 2, 3], [‘a’, ‘b’, ‘c’]\n\n\nMap\nPasangan key-value\n{“x”: 4, “y”: 10}\n\n\ndynamic\nTipe data apa pun"
  },
  {
    "objectID": "2_dasar_dart.html#control-flow-kondisi-dan-perulangan",
    "href": "2_dasar_dart.html#control-flow-kondisi-dan-perulangan",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.4 Control Flow (Kondisi dan Perulangan)",
    "text": "2.4 Control Flow (Kondisi dan Perulangan)\n\n2.4.1 Kondisi\nSaat membuat atau mengembangkan sebuah program, terdapat situasi di mana aliran eksekusi bercabang berdasarkan kondisi tertentu. Dalam bahasa Dart, terdapat tiga kata kunci yang dapat digunakan untuk mengakomodasi dan menguji kondisi tersebut, yaitu if, if-else, dan switch.\n\n2.4.1.1 If\nStruktur\n// if\n\nif (kondisi) {\n    // Tindakan jika kondisi benar\n} \nContoh penggunaan\nvoid main(){\n  int x = 10;\n\n  if (x &lt; 20) {\n    print('Nilai x kurang dari 20');\n  }\n}\nOutput\n\n\n\nOutput If\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel x dengan nilai 10. Mengecek apakah nilai x kurang dari 20. Jika kondisi terpenuhi, program akan mencetak teks “Nilai x kurang dari 20”. Jika kondisi tidak terpenuhi, program akan melanjutkan eksekusi tanpa mencetak apa pun. Dengan demikian, program ini memberikan pesan “Nilai x kurang dari 20” hanya jika nilai x benar-benar kurang dari 20.\n\n\n\n\n2.4.1.2 If-Else\nStruktur\n// if-else\n\nif (kondisi) {\n    // Tindakan jika kondisi benar\n} else {\n    // Tindakan jika kondisi salah\n}\nContoh penggunaan\nvoid main(){\n  int x = 30;\n\n  if (x &lt; 20) {\n    print('Nilai x kurang dari 20');\n  } else {\n    print('Nilai x lebih besar atau sama dengan 20');\n  }\n}\nOutput\n\n\n\nOutput If-Else\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel x dengan nilai 30. Mengecek apakah nilai x kurang dari 20. Jika kondisi terpenuhi, program akan mencetak teks “Nilai x kurang dari 20”. Jika kondisi tidak terpenuhi, program akan mencetak teks “Nilai x lebih besar atau sama dengan 20”. Dengan demikian, program ini memberikan pesan berdasarkan nilai x. Jika nilai x kurang dari 20, maka program akan mencetak “Nilai x kurang dari 20”. Jika nilai x lebih besar atau sama dengan 20, maka program akan mencetak “Nilai x lebih besar atau sama dengan 20”.\n\n\n\n\n2.4.1.3 Switch\nStruktur\n// switch\n\nswitch (nilai) {\n    case 1:\n        // Tindakan jika nilai sama dengan 1\n        break;\n    case 2:\n        // Tindakan jika nilai sama dengan 2\n        break;\n    default:\n        // Tindakan jika nilai tidak sama dengan kasus di atas\n}\nContoh penggunaan\nvoid main(){\n  int nilai = 75;\n\n  switch (nilai) {\n    case 80:\n      print('Nilai A');\n      break;\n    case 70:\n      print('Nilai B');\n      break;\n    case 60:\n      print('Nilai C');\n      break;\n    default:\n      print('Nilai D atau E');\n      break;\n  }     \n}\nOutput\n\n\n\nOutput Switch\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan dan menginisialisasi variabel nilai dengan nilai 75. Menggunakan struktur switch untuk memilih pernyataan berdasarkan nilai nilai. Memeriksa nilai nilai terhadap beberapa kasus menggunakan pernyataan case. Jika nilai nilai sama dengan 80, program akan mencetak “Nilai A”. Jika nilai nilai sama dengan 70, program akan mencetak “Nilai B”. Jika nilai nilai sama dengan 60, program akan mencetak “Nilai C”. Jika nilai nilai tidak sama dengan kasus-kasus di atas, program akan menjalankan pernyataan default dan mencetak “Nilai D atau E”. Dengan demikian, program ini mencetak pesan berdasarkan nilai yang disimpan dalam variabel nilai.\n\n\n\n\n\n2.4.2 Perulangan\nSaat membuat atau mengembangkan sebuah program, terdapat situasi di mana program melakukan hal yang sama berkali-kali. Dart memiliki banyak opsi untuk melakukan perulangan kode, seperti for loop, while loop, do-while, dan for-each.\n\n2.4.2.1 For loop\nStruktur\nfor (var i = 0; i &lt; length; i++) {\n  // kode yang akan dieksekusi pada setiap iterasi\n}\nContoh penggunaan\nvoid main(){\n  for (var i = 1; i &lt;= 5; i++) {\n    print('Perulangan ke-$i');\n  }\n}\nOutput\n\n\n\nOutput For loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan for untuk menjalankan blok kode di dalamnya. Menentukan kondisi perulangan i &lt;= 5, yang berarti perulangan akan berlangsung selama i kurang dari atau sama dengan 5. Setiap iterasi perulangan, program akan mencetak teks “Perulangan ke-[nilai i]” ke output. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah setiap iterasi, nilai i akan bertambah 1 menggunakan operator ++. Setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi, perulangan akan berakhir. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah.\n\n\n\n\n2.4.2.2 While loop\nStruktur\nwhile (condition) {\n  // kode yang akan dieksekusi pada setiap iterasi\n}\nContoh penggunaan\nvoid main(){\n  var i = 1;\n\n  while (i &lt;= 5) {\n    print('Perulangan ke-$i');\n    i++;\n  }\n}\nOutput\n\n\n\nOutput While loop\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan while untuk menjalankan blok kode di dalamnya. Menentukan kondisi perulangan i &lt;= 5, yang berarti perulangan akan berlangsung selama i kurang dari atau sama dengan 5. Di setiap iterasi perulangan, program akan mencetak teks “Perulangan ke-[nilai i]” ke output. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah mencetak pesan, nilai i akan bertambah 1 menggunakan operator ++. Setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi, perulangan akan berakhir. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah.\n\n\n\n\n2.4.2.3 Do-While\nStruktur\ndo {\n  // kode yang akan dieksekusi pada setiap iterasi\n} while (condition);\nContoh penggunaan\nvoid main(){\n  var i = 1;\n\n  do {\n    print('Perulangan ke-$i');\n    i++;\n  } while (i &lt;= 5);\n}\nOutput\n\n\n\nOutput Do-While\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel i dan menginisialisasinya dengan nilai 1. Menggunakan perulangan do-while untuk menjalankan blok kode di dalamnya. Di dalam blok kode, program akan mencetak teks “Perulangan ke-[nilai i]” ke output menggunakan pernyataan print. [nilai i] akan digantikan dengan nilai aktual dari i. Setelah mencetak pesan, nilai i akan bertambah 1 menggunakan operator ++. Setelah setiap iterasi, program akan mengevaluasi kondisi perulangan while (i &lt;= 5). Jika kondisi tersebut benar (true), perulangan akan berlanjut dan blok kode akan diulang. Perulangan akan berhenti setelah i mencapai nilai 6 dan kondisi perulangan tidak lagi terpenuhi. Dengan demikian, program ini akan mencetak pesan “Perulangan ke-1” hingga “Perulangan ke-5”, masing-masing pada baris yang terpisah. Meskipun kondisi perulangan tidak terpenuhi pada iterasi ke-6, perulangan do-while memastikan bahwa setidaknya satu iterasi dilakukan sebelum mengevaluasi kondisi.\n\n\n\n\n2.4.2.4 For-each\nStruktur\nlist.forEach((element) {\n  // kode yang akan dieksekusi pada setiap elemen\n});\nContoh penggunaan\nvoid main(){\n  var fruits = ['apel', 'jeruk', 'mangga'];\n\n  fruits.forEach((fruit) {\n    print(fruit);\n  });\n}\nOutput\n\n\n\nOutput For-each\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel fruits sebagai sebuah list yang berisi beberapa elemen, yaitu ‘apel’, ‘jeruk’, dan ‘mangga’. Menggunakan metode forEach pada list fruits untuk melakukan iterasi pada setiap elemen dalam list. Di dalam blok kode forEach, program akan mencetak nilai setiap elemen ke output menggunakan pernyataan print. Setelah mencetak nilai elemen, program akan melanjutkan ke elemen selanjutnya hingga semua elemen dalam list fruits selesai diproses. Dengan demikian, program ini akan mencetak nilai setiap elemen dalam list fruits (‘apel’, ‘jeruk’, ‘mangga’), masing-masing pada baris yang terpisah."
  },
  {
    "objectID": "2_dasar_dart.html#pembuatan-fungsi",
    "href": "2_dasar_dart.html#pembuatan-fungsi",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.5 Pembuatan Fungsi",
    "text": "2.5 Pembuatan Fungsi\nFungsi dalam Dart digunakan untuk mengelompokkan dan mengorganisir blok kode yang dapat digunakan secara berulang. Fungsi tersebut dapat menerima parameter input, melakukan tindakan tertentu, dan mengembalikan nilai balik (return value) jika diperlukan. Berikut macam-macam fungsi beserta pendeklarasian dan pemanggilan sebuah fungsi dalam Dart:\n\n2.5.1 Fungsi Void / tanpa nilai pengembalian\nFungsi void tidak mengembalikan nilai apapun. Fungsi ini biasanya digunakan untuk melakukan tugas-tugas tertentu, seperti mencetak sesuatu ke konsol, atau mengubah nilai variabel global.\nStruktur\nvoid namaFungsi() {\n    // kode yang akan dieksekusi \n}\nnamaFungsi();\nContoh penggunaan\nvoid main(){\n  void printHello() {\n      print('Hello');\n  }\n  printHello();\n}\nOutput\n\n\n\nOutput Fungsi Void\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printHello() yang tidak memiliki parameter dan tidak mengembalikan nilai (void). Di dalam fungsi printHello(), program mencetak teks “Hello” ke output menggunakan pernyataan print. Setelah mendefinisikan fungsi printHello(), program memanggil fungsi tersebut dengan menggunakan pernyataan printHello(). Pemanggilan fungsi printHello() menjalankan kode di dalam fungsi dan mencetak teks “Hello” ke output. Dengan demikian, program ini mencetak pesan “Hello” ke output ketika fungsi printHello() dipanggil.\n\n\n\n\n2.5.2 Fungsi dengan nilai pengembalian\nFungsi dengan nilai pengembalian mengembalikan nilai tertentu setelah dieksekusi. Contoh tipe data pengembalian yang sering digunakan adalah int, double, String, atau bool.\nStruktur\nTipeNilaiBalik namaFungsi(TipeParameter parameter1, \n                          TipeParameter parameter2) {\n    return nilaiBalik;\n}\nnamaFungsi();\nContoh penggunaan\nvoid main(){\n  int tambah(int a, int b) {\n      return a + b;\n  }\n  print(tambah(1, 1));\n}\nOutput\n\n\n\nOutput Fungsi dengan nilai pengembalian\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama tambah yang mengambil dua parameter bertipe integer, a dan b, dan mengembalikan hasil penjumlahan dari kedua parameter tersebut. Di dalam fungsi tambah, program menggunakan pernyataan return untuk mengembalikan nilai hasil penjumlahan a + b. Setelah mendefinisikan fungsi tambah, program mencetak hasil pemanggilan fungsi tambah(1, 1) ke output menggunakan pernyataan print. Pemanggilan fungsi tambah(1, 1) mengambil argumen 1 dan 1, kemudian menjalankan kode di dalam fungsi tambah dan mengembalikan hasil penjumlahan 1 + 1. Hasil penjumlahan tersebut kemudian dicetak ke output menggunakan pernyataan print. Dengan demikian, program ini mencetak hasil penjumlahan dari angka 1 dan 1, yaitu 2, ke output.\n\n\n\n\n2.5.3 Fungsi dengan parameter opsional bernama\nFungsi dengan parameter opsional memungkinkan kita untuk memanggil fungsi tanpa harus memberikan nilai pada semua parameter.\nStruktur\nvoid namaFungsi(TipeParameter parameter1, {\n                TipeParameter parameter2 = NilaiParameter, \n                TipeParameter parameter3 = NilaiParameter}) {\n    //Kode yang akan dieksekusi\n}\nnamaFungsi(parameter1);\nnamaFungsi(parameter1, parameter2: NilaiParameter);\nnamaFungsi(parameter1, parameter3: NilaiParameter);\nnamaFungsi(parameter1, parameter2: NilaiParameter, \n          parameter3: NilaiParameter);\nContoh penggunaan\nvoid main(){\n  void printPerson(String name, {int age = 18, \n                                String address = 'Unknown'}) {\n      print('Name: $name');\n    if (age \n      != null) {\n      print('Age: $age');\n      }\n    if (address \n      != null) {\n      print('Address: $address');\n      }\n  }\n  printPerson('John Doe', age: 30, address: '123 Main St');\n  print(\"\");\n  printPerson('John Doe', address: '123 Main St');\n  print(\"\");\n  printPerson('Jane Doe', age: 25);\n  print(\"\");\n  printPerson('Mark Smith');\n}\nOutput\n\n\n\nOutput Fungsi dengan parameter opsional bernama\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printPerson yang mengambil tiga parameter, yaitu name (String), age (int), dan address (String). Parameter age dan address memiliki nilai default masing-masing 18 dan ‘Unknown’. Di dalam fungsi printPerson, program mencetak nilai name menggunakan pernyataan print(‘Name: $name’). Program juga memeriksa apakah nilai age tidak null. Jika tidak null, maka nilai age akan dicetak menggunakan pernyataan print(‘Age: $age’). Program juga memeriksa apakah nilai address tidak null. Jika tidak null, maka nilai address akan dicetak menggunakan pernyataan print(‘Address: $address’). Setelah mendefinisikan fungsi printPerson, program memanggil fungsi tersebut dengan berbagai argumen untuk menguji fungsionalitasnya. Pemanggilan fungsi printPerson pada baris 13 menghasilkan output: “Name: John Doe”, “Age: 30”, dan “Address: 123 Main St”. Pemanggilan fungsi printPerson pada baris 15 menghasilkan output: “Name: John Doe” dan “Address: 123 Main St”. Pemanggilan fungsi printPerson pada baris 17 menghasilkan output: “Name: Jane Doe” dan “Age: 25”. Pemanggilan fungsi printPerson pada baris 19 menghasilkan output: “Name: Mark Smith” dan “Age: 18” (dengan nilai default karena tidak ada nilai address yang diberikan). Dengan demikian, program ini mencetak informasi tentang seseorang, yaitu nama, usia, dan alamat, dengan memanfaatkan parameter opsional dan nilai default pada fungsi printPerson.\n\n\n\n\n2.5.4 Fungsi dengan parameter opsional dinamis\nFungsi dengan parameter opsional dinamis memungkinkan kita untuk memanggil fungsi dengan jumlah parameter yang berbeda-beda setiap kali dipanggil.\nStruktur\nvoid namaFungsi(TipeParameter parameter1, [\n                TipeParameter parameter2 = NilaiParameter, \n                TipeParameter parameter3 = NilaiParameter]) {\n    //Kode yang akan dieksekusi\n}\nnamaFungsi(parameter1);\nnamaFungsi(parameter1, parameter2);\nnamaFungsi(parameter1, parameter3);\nnamaFungsi(parameter1, parameter2, parameter3);\nContoh penggunaan\nvoid main(){\n  void printLocation(String city, [String country = 'Indonesia']) {\n      print('Location: $city');\n    if (country \n      != null) {\n          print('Country: $country');\n      }\n  }\n  printLocation('Jakarta');\n  print(\"\");\n  printLocation('New York', 'USA');\n}\nOutput\n\n\n\nOutput Fungsi dengan parameter opsional dinamis\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan sebuah fungsi bernama printLocation yang mengambil dua parameter, yaitu city (String) dan country (String). Parameter country memiliki nilai default ‘Indonesia’ jika tidak diberikan argumen saat pemanggilan fungsi. Di dalam fungsi printLocation, program mencetak nilai city menggunakan pernyataan print(‘Location: $city’). Program juga memeriksa apakah nilai country tidak null. Jika tidak null, maka nilai country akan dicetak menggunakan pernyataan print(‘Country: $country’). Setelah mendefinisikan fungsi printLocation, program memanggil fungsi tersebut dengan berbagai argumen untuk menguji fungsionalitasnya. Pemanggilan fungsi printLocation pada baris 10 hanya memberikan argumen city dengan nilai ‘Jakarta’. Output yang dihasilkan adalah: “Location: Jakarta” dan “Country: Indonesia” (dengan nilai default karena tidak ada argumen country yang diberikan). Pemanggilan fungsi printLocation pada baris 12 memberikan argumen city dengan nilai ‘New York’ dan argumen country dengan nilai ‘USA’. Output yang dihasilkan adalah: “Location: New York” dan “Country: USA”. Dengan demikian, program ini mencetak informasi tentang lokasi, yaitu kota dan negara (dengan nilai default ‘Indonesia’ jika negara tidak diberikan), dengan menggunakan parameter opsional dan nilai default pada fungsi printLocation.\n\n\n\n\n2.5.5 Fungsi anonim\nFungsi anonim adalah fungsi yang tidak memiliki nama dan biasanya digunakan sebagai argumen pada fungsi lain atau dalam ekspresi.\nContoh penggunaan\nvoid main(){\n  var numbers = [1, 2, 3, 4, 5];\n  numbers.forEach((number) =&gt; print(number * 2));\n}\nOutput\n\n\n\nOutput Fungsi anonim\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendeklarasikan variabel numbers sebagai list yang berisi angka-angka. Menggunakan metode forEach pada list numbers untuk melakukan iterasi pada setiap elemen dalam list. Di setiap iterasi, program akan mencetak hasil perkalian elemen dengan 2 ke output menggunakan lambda function (number) =&gt; print(number * 2). Lambda function tersebut mengambil parameter number, dan mencetak hasil perkalian number dengan 2 ke output menggunakan pernyataan print. Setelah mencetak hasil perkalian untuk setiap elemen, iterasi berlanjut hingga semua elemen dalam list numbers selesai diproses. Dengan demikian, program ini akan mencetak hasil perkalian setiap elemen dalam list numbers dengan 2 ke output, masing-masing pada baris yang terpisah. Contohnya, jika numbers adalah [1, 2, 3, 4, 5], maka output yang dihasilkan adalah: 2 4 6 8 10"
  },
  {
    "objectID": "2_dasar_dart.html#class-dan-objek",
    "href": "2_dasar_dart.html#class-dan-objek",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.6 Class dan Objek",
    "text": "2.6 Class dan Objek\nSebagai sebuah bahasa pemrograman yang mendukung konsep OOP (Object-Oriented Programming), Dart menyediakan fitur untuk membuat class. Class dalam Dart berfungsi sebagai sebuah cetak biru (blueprint) untuk membuat objek. Di dalam class, kita dapat mendefinisikan sifat-sifat (attribute) dan perilaku-perilaku (behavior) yang akan dimiliki oleh objek yang akan kita buat.\nDalam Dart, attribute objek didefinisikan menggunakan variabel, sedangkan behavior objek seringkali direpresentasikan sebagai fungsi. Untuk mendeklarasikan sebuah class dalam Dart, kita menggunakan kata kunci class.\nBerikut ini adalah contoh pendeklarasian class, attribute, dan behavior dalam Dart:\nStruktur\nclass namaClass {   //Class\n    TipeAtribut namaAtribut;    //Attribute\n\n    TipeNilaiBalik namaFungsi() {}  //Behavior\n}\nContoh penggunaan\nclass Person {\n  String name = \"\";\n  int age = 0;\n\n  void sayHello() {\n    print('Hello, my name is $name and I am $age years old.');\n  }\n}\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nProperti name yang bertipe String dan diinisialisasi dengan nilai string kosong (““).\nProperti age yang bertipe int dan diinisialisasi dengan nilai 0.\nMetode sayHello() yang tidak mengambil parameter dan tidak mengembalikan nilai (void). Di dalam metode ini, program mencetak pesan “Hello, my name is [nilai name] and I am [nilai age] years old.” ke output. [nilai name] dan [nilai age] akan digantikan dengan nilai aktual dari properti name dan age.\nJadi, kelas Person digunakan untuk merepresentasikan entitas manusia dengan properti name dan age, serta memiliki metode sayHello() untuk mencetak pesan salam.\n\n\nSelanjutnya adalah cara membuat sebuah objek dari suatu class, mengakses atribut, dan menggunakan method:\nStruktur\nNamaClass namaObjek = NamaClass();\nnamaObjek.namaAtribut;\nnamaObjek.namaMethod();\nContoh penggunaan\nvoid main() {\n  Person person1 = new Person();\n  person1.name = 'John';\n  person1.age = 30;\n  person1.sayHello(); \n}\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMembuat instance dari kelas Person dengan menggunakan sintaks Person person1 = new Person();. Ini membuat objek baru dari kelas Person dan menetapkan referensinya ke variabel person1.\nMenggunakan operator titik (dot) untuk mengakses properti name dan age dari objek person1 dan mengatur nilainya. Di dalam program ini, properti name diatur menjadi ‘John’ dan properti age diatur menjadi 30.\nMemanggil metode sayHello() pada objek person1 menggunakan sintaks person1.sayHello(). Ini menjalankan kode di dalam metode sayHello() dari objek person1 dan mencetak pesan salam yang mencakup nilai properti name dan age.\nDengan demikian, program ini menciptakan objek person1 dari kelas Person, mengatur nilai properti name dan age pada objek tersebut, dan kemudian memanggil metode sayHello() untuk mencetak pesan salam dengan nama dan usia yang ditentukan. Dalam contoh ini, program akan mencetak “Hello, my name is John and I am 30 years old.” ke output.\n\n\nVersi lengkapnya\nclass Person {\n  String name = \"\";\n  int age = 0;\n\n  void sayHello() {\n    print('Hello, my name is $name and I am $age years old.');\n  }\n}\n\nvoid main() {\n  Person person1 = new Person();\n  person1.name = 'John';\n  person1.age = 30;\n  person1.sayHello(); \n}\nOutput\n\n\n\nOutput Class dan Objek\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Person dengan dua properti, yaitu name yang bertipe String dan diinisialisasi dengan string kosong (““) serta age yang bertipe int dan diinisialisasi dengan nilai 0. Kelas ini juga memiliki metode sayHello() yang mencetak pesan salam dengan menggunakan nilai properti name dan age.\nDi dalam fungsi main(), program membuat instance dari kelas Person dengan menggunakan sintaks Person person1 = new Person();. Objek baru dari kelas Person diciptakan dan disimpan dalam variabel person1.\nMenggunakan operator titik (dot) untuk mengakses properti name dan age dari objek person1 dan mengatur nilainya. Properti name diatur menjadi ‘John’ dan properti age diatur menjadi 30.\nMemanggil metode sayHello() pada objek person1 menggunakan sintaks person1.sayHello(). Metode sayHello() dijalankan dan mencetak pesan salam ke output dengan menggunakan nilai properti name dan age yang telah ditetapkan sebelumnya.\nDengan demikian, program ini menciptakan objek person1 dari kelas Person, mengatur nilai properti name dan age pada objek tersebut, dan kemudian memanggil metode sayHello() untuk mencetak pesan salam dengan nama dan usia yang ditentukan. Output yang dihasilkan adalah “Hello, my name is John and I am 30 years old.”"
  },
  {
    "objectID": "2_dasar_dart.html#pewarisan-dan-polimorfisme",
    "href": "2_dasar_dart.html#pewarisan-dan-polimorfisme",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.7 Pewarisan dan Polimorfisme",
    "text": "2.7 Pewarisan dan Polimorfisme\n\n2.7.1 Pewarisan\nPewarisan atau Inheritance adalah kemampuan suatu program untuk membuat kelas baru berdasarkan kelas yang sudah ada. Konsep inheritance dapat dibayangkan layaknya seorang anak mewarisi sifat dari orang tuanya. Di dalam OOP kelas yang menurunkan sifat disebut sebagai kelas induk (parent class/superclass) sementara kelas yang mewarisi kelas induknya disebut sebagai kelas anak (child class/subclass). Dalam dart pewarisan dapat dideklarasikan sebagai berikut:\nStruktur\nclass ParentClass {\n    void parentMethod() {}\n}\n\nclass ChildClass extends ParentClass {\n    void childMethod() {}\n}\n\nChildClass childObj = ChildClass();\nchildObj.parentMethod(); // Memanggil metode dari kelas induk\nchildObj.childMethod(); // Memanggil metode dari kelas anak\nContoh penggunaan\nclass Vehicle {\n  void start() {\n    print('Vehicle started');\n  }\n}\n\nclass Car extends Vehicle {\n  void drive() {\n    print('Car is being driven');\n  }\n}\n\nvoid main() {\n  var car = Car();\n  car.start();\n  car.drive();\n}\nOutput\n\n\n\nOutput Pewarisan\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Vehicle dengan metode start(). Metode ini mencetak pesan “Vehicle started” ke output.\nMendefinisikan kelas Car yang merupakan turunan dari kelas Vehicle menggunakan kata kunci extends. Kelas Car memiliki metode tambahan yaitu drive(), yang mencetak pesan “Car is being driven” ke output.\nDi dalam fungsi main(), program membuat instance dari kelas Car menggunakan sintaks var car = Car();. Objek baru dari kelas Car diciptakan dan disimpan dalam variabel car.\nMenggunakan operator titik (dot) untuk mengakses metode start() pada objek car menggunakan sintaks car.start(). Metode start() dari kelas Vehicle dijalankan dan mencetak pesan “Vehicle started” ke output.\nMenggunakan operator titik (dot) juga untuk mengakses metode drive() pada objek car menggunakan sintaks car.drive(). Metode drive() dari kelas Car dijalankan dan mencetak pesan “Car is being driven” ke output.\nDengan demikian, program ini menunjukkan penggunaan pewarisan (inheritance) dalam Dart, di mana kelas Car mewarisi metode start() dari kelas Vehicle dan memiliki metode tambahan drive(). Objek car dapat memanggil metode start() dan drive() untuk mencetak pesan yang sesuai ke output. Output yang dihasilkan adalah:\nVehicle started Car is being driven\n\n\n\n\n2.7.2 Polimorfisme\nPolimorfisme adalah konsep di mana suatu objek dapat muncul dalam berbagai bentuk atau tipe. Dalam konteks Dart, polimorfisme memungkinkan penggunaan objek dari kelas turunan sebagai objek dari kelas induknya, sehingga objek-objek tersebut dapat diperlakukan secara umum tanpa perlu mengetahui tipe spesifik dari objek.\nBerikut adalah contoh sederhana untuk pendeklarasian polimorfisme dalam Dart:\nStruktur\nclass Shape {\n    void draw() {}\n}\n\nclass Circle extends Shape {\n    @override\n    void draw() {}\n}\n\nclass Rectangle extends Shape {\n    @override\n    void draw() {}\n}\n\nList&lt;Shape&gt; shapes = [Circle(), Rectangle()];\n\nfor (var shape in shapes) {\n    shape.draw(); // Polimorfisme terjadi di sini\n}\nContoh penggunaan\nclass Hewan {\n  void makan() {\n    print('Hewan sedang makan');\n  }\n}\n\nclass Kucing extends Hewan {\n  @override\n  void makan() {\n    print('Kucing sedang makan ikan');\n  }\n}\n\nclass Anjing extends Hewan {\n  @override\n  void makan() {\n    print('Anjing sedang makan daging');\n  }\n}\n\nvoid main() {\n  Hewan hewan1 = new Kucing();\n  Hewan hewan2 = new Anjing();\n  \n  hewan1.makan(); // Output: Kucing sedang makan ikan\n  hewan2.makan(); // Output: Anjing sedang makan daging\n}\nOutput\n\n\n\nOutput Polimorfisme\n\n\n\n\n\n\n\n\nTip\n\n\n\nPenjelasan Kode\nMendefinisikan kelas Hewan dengan metode makan(). Metode ini mencetak pesan “Hewan sedang makan” ke output.\nMendefinisikan kelas Kucing yang merupakan turunan dari kelas Hewan menggunakan kata kunci extends. Kelas Kucing menggunakan anotasi (override?) untuk menandakan bahwa metode makan() dalam kelas Kucing akan menggantikan (override) metode makan() yang ada di kelas Hewan. Metode makan() dalam kelas Kucing mencetak pesan “Kucing sedang makan ikan” ke output.\nMendefinisikan kelas Anjing yang juga merupakan turunan dari kelas Hewan. Seperti pada kelas Kucing, kelas Anjing menggunakan anotasi (override?) untuk menggantikan metode makan() di kelas Hewan. Metode makan() dalam kelas Anjing mencetak pesan “Anjing sedang makan daging” ke output.\nDi dalam fungsi main(), program membuat objek hewan1 dan hewan2 yang bertipe Hewan namun diinisialisasi sebagai objek Kucing dan Anjing secara berturut-turut.\nMenggunakan operator titik (dot) untuk memanggil metode makan() pada objek hewan1 dan hewan2. Karena metode makan() telah digantikan (override) dalam kelas Kucing dan Anjing, pemanggilan metode makan() pada objek hewan1 akan mencetak pesan “Kucing sedang makan ikan” ke output, sedangkan pemanggilan metode makan() pada objek hewan2 akan mencetak pesan “Anjing sedang makan daging” ke output.\nDengan demikian, program ini menunjukkan penggunaan overriding metode dalam Dart, di mana metode makan() dalam kelas Kucing dan Anjing menggantikan metode makan() yang ada dalam kelas Hewan. Output yang dihasilkan adalah:\nKucing sedang makan ikan Anjing sedang makan daging"
  },
  {
    "objectID": "2_dasar_dart.html#studi-kasus",
    "href": "2_dasar_dart.html#studi-kasus",
    "title": "2  Dasar Pemrograman Dart",
    "section": "2.8 Studi Kasus",
    "text": "2.8 Studi Kasus\nMisalkan kita ingin membuat sebuah program sederhana untuk mengelola data karyawan pada sebuah perusahaan. Kita akan membuat sebuah class Karyawan sebagai superclass, dan dua subclass yaitu KaryawanTetap dan KaryawanKontrak, yang akan mewarisi sifat-sifat dari Karyawan. Kita juga akan menggunakan control flow seperti if-else dan penggunaan fungsi untuk melakukan perhitungan gaji karyawan.\nBerikut adalah implementasi programnya:\nclass Karyawan {\n  String nama;\n  int umur;\n  String alamat;\n\n  Karyawan(this.nama, this.umur, this.alamat);\n\n  double hitungGaji() {\n    return 0;\n  }\n}\n\nclass KaryawanTetap extends Karyawan {\n  double gajiPokok;\n  double tunjangan;\n\n  KaryawanTetap(String nama, \n                int umur, \n                String alamat, \n                this.gajiPokok, \n                this.tunjangan) : \n                super(nama, umur, alamat);\n\n  @override\n  double hitungGaji() {\n    return gajiPokok + tunjangan;\n  }\n}\n\nclass KaryawanKontrak extends Karyawan {\n  int durasiKontrak;\n  double gajiPerBulan;\n\n  KaryawanKontrak(String nama, \n                  int umur, \n                  String alamat, \n                  this.durasiKontrak, \n                  this.gajiPerBulan) : \n                  super(nama, umur, alamat);\n\n  @override\n  double hitungGaji() {\n    return durasiKontrak * gajiPerBulan;\n  }\n}\n\nvoid main() {\n  KaryawanTetap karyawanTetap = KaryawanTetap('John Doe', 28, \n  'Jl. Sudirman No. 123', 5000000, 1000000);\n  KaryawanKontrak karyawanKontrak = KaryawanKontrak('Jane Doe', 25, \n  'Jl. Thamrin No. 456', 12, 3000000);\n\n  if (karyawanTetap.hitungGaji() &gt; karyawanKontrak.hitungGaji()) {\n    print('Gaji ${karyawanTetap.nama} &gt; gaji ${karyawanKontrak.nama}');\n  } else {\n    print('Gaji ${karyawanKontrak.nama} &gt; gaji ${karyawanTetap.nama}');\n  }\n}\nOutput\n\n\n\nOutput Studi Kasus\n\n\n\n\n\n\n\n\nPenjelasan Kode\n\n\n\nMendefinisikan kelas Karyawan dengan properti nama, umur, dan alamat. Kelas ini juga memiliki konstruktor yang menerima tiga parameter untuk menginisialisasi properti-propertinya. Selain itu, kelas ini memiliki metode hitungGaji() yang mengembalikan nilai 0. Metode ini akan digantikan (override) di kelas-kelas turunannya.\nMendefinisikan kelas KaryawanTetap yang merupakan turunan dari kelas Karyawan. Kelas ini memiliki properti tambahan gajiPokok dan tunjangan. Konstruktor kelas ini menerima enam parameter, termasuk dua parameter yang digunakan untuk menginisialisasi properti tambahan. Kelas ini juga menggantikan metode hitungGaji() yang menghitung total gaji dengan menjumlahkan gajiPokok dan tunjangan.\nMendefinisikan kelas KaryawanKontrak yang juga merupakan turunan dari kelas Karyawan. Kelas ini memiliki properti tambahan durasiKontrak dan gajiPerBulan. Konstruktor kelas ini menerima enam parameter, termasuk dua parameter yang digunakan untuk menginisialisasi properti tambahan. Kelas ini juga menggantikan metode hitungGaji() yang menghitung total gaji dengan mengalikan durasiKontrak dan gajiPerBulan.\nDi dalam fungsi main(), program membuat objek karyawanTetap dari kelas KaryawanTetap dan objek karyawanKontrak dari kelas KaryawanKontrak. Setiap objek diinisialisasi dengan nilai-nilai yang sesuai.\nProgram membandingkan gaji yang diterima oleh karyawanTetap dan karyawanKontrak menggunakan metode hitungGaji(). Jika gaji yang diterima oleh karyawanTetap lebih besar daripada karyawanKontrak, program mencetak pesan “${karyawanTetap.nama} mendapatkan gaji lebih besar daripada \\({karyawanKontrak.nama}\". Jika tidak, program mencetak pesan \"\\){karyawanKontrak.nama} mendapatkan gaji lebih besar daripada ${karyawanTetap.nama}”.\nDengan demikian, program ini mengilustrasikan penggunaan pewarisan dan overriding dalam konteks penggajian karyawan. Output yang dihasilkan akan mencetak perbandingan gaji antara karyawan tetap dan karyawan kontrak berdasarkan perhitungan gaji yang dilakukan pada masing-masing kelas."
  },
  {
    "objectID": "3_user_interface.html",
    "href": "3_user_interface.html",
    "title": "3  Antarmuka Pengguna",
    "section": "",
    "text": "Antarmuka Pengguna\nAplikasi yang baik memiliki antarmuka yang dapat digunakan oleh penggunanya."
  },
  {
    "objectID": "3_user_interface.html#widget",
    "href": "3_user_interface.html#widget",
    "title": "3  Antarmuka Pengguna",
    "section": "3.1 Widget",
    "text": "3.1 Widget\nWidget pada Flutter merupakan elemen dasar dalam membangun antarmuka pengguna (UI). Dalam Flutter, hampir semua komponen yang berada di layar adalah widget, termasuk tombol, teks, gambar, kotak, daftar, dan sebagainya. Berikut merupakan widget yang umum digunakan dalam flutter :\n\n3.1.1 Scaffold\nWidget yang digunakan untuk membuat tampilan dasar aplikasi Flutter. Memiliki 3 bagian yaitu AppBar, Body, dan FloatingActionButton.\nScaffold(\n    appBar: AppBar(\n        title: const Text('First Screen'),\n        actions: [\n            IconButton(\n                icon: const Icon(\n                Icons.search,\n                color: Colors.white,\n                ),\n                onPressed: () {},\n            ),\n        ],\n        leading: IconButton(\n            icon: const Icon(\n                Icons.menu,\n                color: Colors.white,\n        ),\n            onPressed: () {},\n        ),\n    ),\n    body: const Center(\n        child: Text('Hello world!'),\n    ),\n    floatingActionButton: FloatingActionButton(\n        child: const Icon(Icons.add),\n        onPressed: () {},\n    ),\n);\n\n\n\nAppbar Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nappBar: AppBar(...): Ini adalah bagian yang mendefinisikan AppBar (bilah aplikasi) di atas tampilan utama. Di dalam AppBar, kita menentukan judul dengan menggunakan widget Text. Selain itu, ada juga dua tombol ikon yang ditempatkan di sebelah kanan dan kiri AppBar. Tombol ikon kanan menggunakan IconButton dengan ikon Icons.search, sedangkan tombol ikon kiri menggunakan IconButton dengan ikon Icons.menu.\nbody:... : Ini adalah bagian yang mendefinisikan konten utama dari tampilan aplikasi.\nfloatingActionButton: FloatingActionButton(...) : Ini adalah bagian yang mendefinisikan tombol aksi mengambang (floating action button) di sudut kanan bawah tampilan. Menggunakan widget FloatingActionButton dan menentukan ikon dengan Icon(Icons.add).\n\n\n\n\n\n3.1.2 Container\nWidget yang digunakan untuk melakukan styling, membuat sebuah shape (bentuk), dan layout pada widget child-nya.\nContainer(\n    alignment: Alignment.center,\n    width: 300,\n    height: 300,\n    color: Colors.blue,\n    padding: const EdgeInsets.all(10),\n    margin: const EdgeInsets.all(10),\n    child: const Text(\n    'Hello',\n    ),\n),\n\n\n\nContainer Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nalignment:...: Properti ini mengatur posisi atau penempatan konten di dalam container.\nwidth:..., height:...: Properti ini mengatur lebar (width) dan tinggi (height) dari container.\ncolor:...: Properti ini mengatur warna latar belakang dari container.\npadding:...: Properti ini mengatur ruang padding (jarak) di sekeliling konten di dalam container.\nmargin:...: Properti ini mengatur ruang margin (jarak) di sekeliling container itu sendiri.\nchild:...: Properti ini menyediakan konten yang akan ditampilkan di dalam container.\n\n\n\n\n\n3.1.3 Center\nWidget Center merupakan sebuah widget yang digunakan untuk membuat suatu widget berada pada posisi tengah.\nCenter(\n    // konten yang ingin diposisikan ketengah\n    child: const Text('Text berada di tengah'),\n),\n\n\n3.1.4 Safe Area\nWidget dalam Flutter yang digunakan untuk mengatur area konten yang “aman” atau bebas dari gangguan seperti bilah status (status bar) atau bilah navigasi (navigation bar) pada perangkat.\nSafeArea(\n    // konten yang ingin diposisi dibawah bilah navigasi\n    child: Scaffold(\n        body: Center(\n        child: Text('Konten utama aplikasi'),\n        ),\n    ),\n)\n\n\n\nSafe Area Details\n\n\n\n\n3.1.5 SizedBox\nWidget dalam Flutter yang digunakan untuk mengatur ukuran ruang kosong yang tetap dalam tata letak.\nSizedBox(\n    width: 200.0,\n    height: 100.0,\n)\n\n\n\nSizedBox Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nwidth:... - Properti ini mengatur lebar kotak yang akan dibuat.\nheight:... - Properti ini mengatur tinggi kotak yang akan dibuat.\n\n\n\n\n\n3.1.6 Text\nWidget dalam Flutter yang digunakan untuk menampilkan teks.\nText('Hello world!')\n\n\n3.1.7 Button\nWidget dalam Flutter yang digunakan untuk membuat elemen yang dapat diinteraksi oleh pengguna. Flutter menyediakan beberapa jenis button yang dapat digunakan, seperti ElevatedButton, TextButton, IconButton, FloatingActionButton, dan lainnya.\nElevatedButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    child: Text('Tombol'),\n),\nIconButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    icon: Icon(Icons.radio_button_checked),\n),\nTextButton(\n    onPressed: () {\n    print('Tombol ditekan!');\n    },\n    // text di dalam button\n    child: Text('Tombol'),\n),\nfloatingActionButton: FloatingActionButton(\n    onPressed: () {},\n    child: Text('Tombol'),\n),\n\n\n\nButton Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nElevatedButton: Ini adalah tombol dengan tampilan yang sedikit lebih “mengangkat” atau menonjol daripada tombol standar. Saat tombol ini ditekan, logika yang diberikan di dalam fungsi onPressed akan dijalankan. child merupakan properti yang digunakan untuk menambahkan konten teks ke dalam tombol.\nIconButton: Ini adalah tombol yang berisi sebuah ikon. Ikon tersebut diberikan melalui properti icon. Ketika tombol ini ditekan, logika di dalam fungsi onPressed akan dijalankan.\nTextButton: Ini adalah tombol dengan tampilan teks sederhana. Properti child digunakan untuk menentukan teks yang akan ditampilkan di dalam tombol. Saat tombol ini ditekan, logika di dalam fungsi onPressed akan dijalankan.\nFloatingActionButton: Ini adalah tombol tindakan yang mengambang (floating action button) yang umumnya digunakan untuk tindakan utama dalam aplikasi. Dalam contoh ini, tombol ini tidak memiliki logika yang ditentukan dalam fungsi onPressed. child digunakan untuk menambahkan teks “Tombol” ke dalam tombol tersebut."
  },
  {
    "objectID": "3_user_interface.html#layout",
    "href": "3_user_interface.html#layout",
    "title": "3  Antarmuka Pengguna",
    "section": "3.2 Layout",
    "text": "3.2 Layout\nLayout dalam Flutter mengacu pada tata letak atau susunan widget di antarmuka pengguna. Dalam Flutter, tata letak dapat diatur menggunakan berbagai widget dan komponen yang tersedia untuk mengatur posisi, ukuran, dan hubungan antara elemen-elemen dalam antarmuka. Berikut adalah beberapa contoh layout umum dalam Flutter:\n\n3.2.1 Column\nLayout ini mengatur widget secara vertikal, mulai dari atas ke bawah.\nColumn(\n    mainAxisAlignment: MainAxisAlignment.center,\n    crossAxisAlignment: CrossAxisAlignment.end,\n    children: const &lt;Widget&gt;[\n        Text('Sebuah Judul'),\n        Text('Lorem ipsum dolor sit amet'),\n    ],\n),\n\n\n\nColumn Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nmainAxisAlignment:... : Atribut ini digunakan untuk mengatur perataan utama (main axis alignment) dari widget-column.\ncrossAxisAlignment:... : Atribut ini digunakan untuk mengatur perataan lintang (cross axis alignment) dari widget-column.\nchildren: const &lt;Widget&gt;[...]: Ini adalah daftar widget yang akan ditampilkan di dalam column secara vertikal. Penggunaan const menandakan bahwa daftar widget ini merupakan konstanta yang tetap, dan tidak akan berubah selama runtime.\n\n\n\n\n\n3.2.2 Row\nLayout ini mengatur widget secara horizontal, mulai dari kiri ke kanan.\nRow(\n    mainAxisAlignment: MainAxisAlignment.start,\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: const &lt;Widget&gt;[\n        Icon(Icons.share),\n        Icon(Icons.thumb_up),\n        Icon(Icons.thumb_down),\n    ],\n)\n\n\n\nRow Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nmainAxisAlignment:... : menentukan posisi utama (main axis) dari elemen-elemen di dalam Row.\ncrossAxisAlignment:... : menentukan posisi silang (cross axis) dari elemen-elemen di dalam Row.\nchildren : merupakan properti yang berisi daftar elemen-elemen yang ingin ditampilkan dalam Row.\n&lt;Widget&gt;[...] menandakan bahwa tipe elemen yang ditampilkan dalam children adalah Widget.\nconst digunakan untuk mengindikasikan bahwa daftar elemen dalam children adalah konstan, artinya tidak akan berubah.\n\n\n\n\n\n3.2.3 ListView\nLayout ini mengatur widget-widget didalamnya dalam tampilan daftar item yang dapat di-scroll secara vertikal. Widget ini berguna untuk kumpulan data yang ingin ditampilkan dalam bentuk daftar, seperti daftar kontak, daftar pesan, atau daftar produk.\nListView(\n    children: [\n        // ....\n\n        Container(\n        color: Colors.amber,\n        width: double.infinity,\n        height: 100,\n        ),\n        Container(\n        color: Colors.blueAccent,\n        width: double.infinity,\n        height: 100,\n        ),\n        Container(\n        color: Colors.brown,\n        width: double.infinity,\n        height: 100,\n        ),\n        \n        // ...\n    ],\n)\n\n\n\nListview Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nProperti children adalah properti wajib pada ListView yang berisi daftar widget yang akan ditampilkan sebagai elemen dalam daftar.\n\n\n\n\n\n3.2.4 GridView\nLayout ini digunakan untuk menampilkan daftar item dalam bentuk grid. Grid ini dapat berisi item-item yang ditampilkan secara berbaris dan berkolom. Layout ini berguna ketika menampilkan data dalam tata letak grid yang teratur.\nGridView(\n    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: 2,\n        mainAxisSpacing: 10.0,\n        crossAxisSpacing: 10.0,\n    ),\n    children: &lt;Widget&gt;[\n        Container(color: Colors.red),\n        Container(color: Colors.green),\n        Container(color: Colors.blue),\n        Container(color: Colors.yellow),\n    ],\n)\n\n\n\nGridview Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\ngridDelegate: Properti ini mengatur tata letak dan konfigurasi grid. Pada kode di atas, digunakan SliverGridDelegateWithFixedCrossAxisCount yang merupakan salah satu implementasi dari SliverGridDelegate. crossAxisCount menentukan jumlah kolom dalam grid. mainAxisSpacing mengatur ruang antara item secara vertikal, sedangkan crossAxisSpacing mengatur ruang antara item secara horizontal.\nchildren: Properti ini berisi daftar widget yang akan ditampilkan dalam grid. Widget ini akan ditampilkan dalam bentuk grid sesuai dengan konfigurasi yang diberikan oleh gridDelegate.\n\n\n\n\n\n3.2.5 Expanded\nLayout ini digunakan untuk mengalokasikan ruang yang tersisa dalam tata letak yang fleksibel. Expanded memungkinkan widget untuk memperluas dan mengisi ruang yang tersedia sebanyak mungkin, sesuai dengan aturan penempatan dan proporsi yang ditentukan.\nRow(\n    children: [\n        Container(\n        color: Colors.red,\n        height: 100,\n        width: 100,\n        ),\n        Expanded(\n        child: Container(\n            color: Colors.blue,\n        ),\n        ),\n        Container(\n        color: Colors.green,\n        height: 100,\n        width: 100,\n        ),\n    ],\n)\n\n\n\nExpanded Details"
  },
  {
    "objectID": "3_user_interface.html#styling",
    "href": "3_user_interface.html#styling",
    "title": "3  Antarmuka Pengguna",
    "section": "3.3 Styling",
    "text": "3.3 Styling\nStyling dalam Flutter mengacu pada pengaturan penampilan visual dari widget. Dalam Flutter, berbagai properti gaya seperti warna, ukuran, jenis huruf, latar belakang, dan sebagainya dapat diatur untuk memodifikasi penampilan widget.\nBerikut adalah beberapa contoh penggunaan styling dalam Flutter:\n\n3.3.1 Pada Teks\nText(\n  'Hello, world!',\n  style: TextStyle(\n    color: Colors.blue,\n    fontSize: 20,\n    fontWeight: FontWeight.bold,\n    fontStyle: FontStyle.italic,\n    letterSpacing: 2,\n    wordSpacing: 5,\n    background: Paint()..color = Colors.yellow,\n    decoration: TextDecoration.underline,\n    decorationColor: Colors.red,\n    decorationStyle: TextDecorationStyle.dashed,\n  ),\n)\n\n\n\nFont Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\ncolor:... : digunakan untuk mengatur warna teks.\nfontSize:... : digunakan untuk mengatur ukuran font teks.\nfontWeight:... : digunakan untuk mengatur ketebalan font teks.\nfontStyle:... : digunakan untuk mengatur gaya font teks.\nletterSpacing:... : digunakan untuk mengatur jarak antar huruf pada teks.\nwordSpacing:... : digunakan untuk mengatur jarak antar kata pada teks.\nbackground: Paint()..color = ... : digunakan untuk memberikan latar belakang pada teks.\ndecoration: TextDecoration.underline : digunakan untuk menambahkan garis bawah pada teks.\ndecorationColor:... : digunakan untuk mengatur warna garis bawah pada teks.\ndecorationStyle:... : digunakan untuk mengatur garis bawah pada teks.\n\n\n\n\n\n3.3.2 Pada Container\nContainer(\n  width: 200,\n  height: 200,\n  decoration: BoxDecoration(\n    color: Colors.blue,\n    borderRadius: BorderRadius.circular(10),\n    boxShadow: [\n      BoxShadow(\n        color: Colors.grey,\n        blurRadius: 10,\n        offset: Offset(5, 5),\n      ),\n    ],\n    gradient: LinearGradient(\n      begin: Alignment.topLeft,\n      end: Alignment.bottomRight,\n      colors: [Colors.blue, Colors.green],\n    ),\n  ),\n  padding: EdgeInsets.all(16),\n  margin: EdgeInsets.all(16),\n  alignment: Alignment.center,\n  child: Text(\n    'Hello, world!',\n    style: TextStyle(\n      color: Colors.white,\n      fontSize: 20,\n      fontWeight: FontWeight.bold,\n    ),\n  ),\n)\n\n\n\nContainer Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\nDalam BoxDecoration, terdapat beberapa properti yang digunakan untuk mengatur dekorasi pada Container, yaitu:\n\ncolor:...: digunakan untuk mengatur warna latar belakang Container.\nborderRadius:...: digunakan untuk mengatur radius border Container.\nboxShadow:...: digunakan untuk memberikan bayangan pada Container.\ngradient: LinearGradient(...): digunakan untuk mengatur warna gradient pada Container.\n\n\n\n\n\n3.3.3 Pada Elevated Button\nElevatedButton(\n  style: ButtonStyle(\n    backgroundColor: MaterialStateProperty.all&lt;Color&gt;(Colors.blue),\n    shape: MaterialStateProperty.all&lt;RoundedRectangleBorder&gt;(\n      RoundedRectangleBorder(\n        borderRadius: BorderRadius.circular(18.0),\n      ),\n    ),\n  ),\n  onPressed: () {\n    // lakukan sesuatu saat tombol ditekan\n  },\n  child: Text(\n    'Click me!',\n    style: TextStyle(\n      color: Colors.white,\n      fontSize: 20,\n      fontWeight: FontWeight.bold,\n    ),\n  ),\n)\n\n\n\nButton Styling Details\n\n\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nstyle: ButtonStyle(): Properti ini digunakan untuk mengatur gaya (style) dari tombol. Di dalamnya, terdapat beberapa properti yang bisa dikonfigurasi.\nbackgroundColor: MaterialStateProperty.all&lt;Color&gt;(Colors.blue): Properti ini digunakan untuk mengatur warna latar belakang (background color) tombol.\nshape: MaterialStateProperty.all&lt;RoundedRectangleBorder&gt; (RoundedRectangleBorder(borderRadius: BorderRadius.circular(18.0))): Properti ini digunakan untuk mengatur bentuk (shape) tombol. Di contoh ini, sebuah RoundedRectangleBorder digunakan dengan jari-jari sudut sebesar 18.0.\nonPressed: () { ... }: Properti ini digunakan untuk menentukan aksi yang dilakukan saat tombol ditekan. Di dalam tanda kurung kurawal ({…}), Anda dapat menulis kode untuk menjalankan aksi tertentu."
  },
  {
    "objectID": "3_user_interface.html#handling-input",
    "href": "3_user_interface.html#handling-input",
    "title": "3  Antarmuka Pengguna",
    "section": "3.4 Handling Input",
    "text": "3.4 Handling Input\n\n3.4.1 GestureDetector\nGestureDetector adalah widget yang dapat digunakan untuk mendeteksi dan menangani berbagai jenis gestur pengguna. Widget ini dapat digunakan untuk menangkap ketukan, gesekan, geseran, dan gestur lainnya.\nGestureDetector(\n    onTap: () {\n       print('Tap!');\n    },\n    onDoubleTap: () {\n       print('Double tap!');\n    },\n    onLongPress: () {\n       print('Long tap!');\n    },\n    onSwipeUp: () {\n       print('Swipe Up!');\n    },\n    child: Container(\n    alignment: Alignment.center,\n    width: 200,\n    height: 200,\n    color: Colors.grey[300],\n    child: Text(\n        _message,\n        textAlign: TextAlign.center,\n        style: TextStyle(fontSize: 20),\n    ),\n    ),\n)\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nonTap: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan satu ketukan (tap) pada area yang diberikan.\nonDoubleTap: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan dua ketukan (double tap) pada area yang diberikan.\nonLongPress: Properti ini menentukan aksi yang akan dilakukan ketika pengguna menahan lama (long press) pada area yang diberikan.\nonSwipeUp: Properti ini menentukan aksi yang akan dilakukan ketika pengguna melakukan geseran ke atas (swipe up) pada area yang diberikan.\nchild: Properti ini digunakan untuk menentukan widget yang akan diletakkan di dalam GestureDetector.\n\n\n\n\n\n3.4.2 InkWell\nInkWell adalah widget yang memberikan umpan balik visual saat pengguna menyentuhnya. Ketika pengguna menyentuh InkWell, widget ini akan menampilkan animasi “splash” atau efek “ink”.\nInkWell(\n    onTap: () {\n       print('Tap!');\n    },\n    onLongPress: () {\n       print('Long tap!');\n    },\n    child: Container(\n    alignment: Alignment.center,\n    width: 200,\n    height: 200,\n    color: Colors.grey[300],\n    child: Text(\n        _message,\n        textAlign: TextAlign.center,\n        style: TextStyle(fontSize: 20),\n    ),\n    ),\n)\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nonTap: Properti ini adalah sebuah fungsi yang akan dieksekusi ketika pengguna mengetuk widget yang dibungkus oleh InkWell.\nonLongPress: Properti ini juga merupakan sebuah fungsi yang akan dieksekusi ketika pengguna menahan lama (long press) pada widget yang dibungkus oleh InkWell.\nchild: Properti ini adalah widget lain yang akan ditampilkan di dalam InkWell."
  },
  {
    "objectID": "3_user_interface.html#studi-kasus",
    "href": "3_user_interface.html#studi-kasus",
    "title": "3  Antarmuka Pengguna",
    "section": "3.5 Studi Kasus",
    "text": "3.5 Studi Kasus\nDalam studi kasus ini, kita akan membuat sebuah aplikasi satu halaman yang menampilkan daftar makanan dalam bentuk daftar yang terlihat di layar. Berikut adalah tampilan aplikasi yang dihasilkan dari studi kasus ini.\n\n\n\nHasil\n\n\nTahap-tahap pembuatan studi kasus adalah sebagai berikut:\n\nBuatlah projek flutter baru.\nBuka file main.dart dan hapus kode template yang ada di dalamnya, kemudian gantikan dengan kode berikut ini:\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n\n\n\nTampilan langkah ke 2\n\n\n\nBuatlah sebuah file baru dengan nama “home_page.dart” di dalam direktori “lib”. Pada file ini, tampilan utama dari aplikasi akan disimpan, sehingga membuat kode menjadi lebih mudah dibaca dan dikelola.\n\n\n\n\nTampilan langkah ke 3\n\n\n\nSelanjutnya buat sebuah class baru bernama HomePage pada file home_page.dart dengan tipe StatelessWidget.\n\nimport 'package:flutter/material.dart';\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n\nSetelah itu kembali ke dalam file “main.dart”, ubah kode pada bagian “body” menjadi “HomePage()”. Dengan melakukan perubahan tersebut, tampilan di emulator akan mengikuti konten yang ada di halaman utama (HomePage). Selain itu, tambahkan judul pada aplikasi dengan menggunakan komponen AppBar.\n\nScaffold(\n    appBar: AppBar(\n        title: Text(\"List Kuliner\"),\n    ),\n    body: HomePage(),\n),\n\n\n\nLangkah ke 5\n\n\n\nBuka file “home_page.dart” dan gantilah placeholder dengan widget ListView. Selanjutnya, tambahkan widget Container di dalam ListView tersebut. Sesuaikan gaya tampilan (styling) pada ListView dan Container sesuai dengan preferensi Anda. Tampilan ini akan menjadi dasar dari aplikasi studi kasus yang sedang dibangun.\n\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        Container(\n            margin: EdgeInsets.symmetric(vertical: 5),\n            decoration: BoxDecoration(\n                color: Colors.blueAccent,\n                borderRadius: \n                BorderRadius.all(Radius.circular(10)),\n                boxShadow: [\n                BoxShadow(\n                    color: Colors.black,\n                    offset: Offset(3.0, 5.0),\n                    blurRadius: 2.0,\n                ),\n                ],\n            ),\n            height: 100,\n            padding: EdgeInsets.symmetric(\n                horizontal: 10,\n                vertical: 15,\n            ),\n        ),\n    ],\n),\n\n\n\nLangkah ke 6\n\n\n\nBuatlah beberapa widget di dalam sebuah container, menggunakan widget Column atau Row, untuk mengubah tampilan container menjadi sebuah kartu (card) yang dapat digunakan untuk menyimpan data makanan. Sesuaikan juga gaya (styling) seperti margin, padding, dan warna.\n\nContainer(\n    //...\n    \n    child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n        Container(\n            width: 75,\n            height: 75,\n            color: Colors.black,\n        ),\n        SizedBox(\n            width: 10,\n        ),\n        Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n            Text(\n                \"Title\",\n                style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n                ),\n            ),\n            Text(\n                \"Sub Title\",\n                style: TextStyle(\n                fontWeight: FontWeight.w500,\n                ),\n            ),\n            ],\n        )\n        ],\n    ),\n),\n\n\n\nLangkah ke 7\n\n\n\nUntuk mempermudah pembacaan kode, buatlah sebuah file baru bernama “list_item.dart”. Di dalam file tersebut, buatlah sebuah class baru dengan nama “ListItem” yang merupakan turunan dari StatelessWidget. Kemudian, pindahkan seluruh kode yang berada di dalam container ke dalam class ListItem tersebut.\n\n\n\n\nLangkah ke 8\n\n\nimport 'package:flutter/material.dart';\n\nclass ListItem extends StatelessWidget {\n  const ListItem({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      //...\n    );\n  }\n}\nPastikan untuk menyertakan Widget ListItem() di dalam ListView pada file home_page.dart agar kontainer dapat ditampilkan dengan benar.\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        ListItem(),\n    ],\n),\n\nSamapai pada tahap ke 8 tampilan statis dari aplikasi telah selesai. Langkah selanjutnya adalah membuat data dan menampilkannya dalam aplikasi.\n\nPertama-tama Anda perlu membuat file baru bernama makanan.dart untuk menyimpan kelas makanan beserta atribut-atributnya.\n\n\n\nLangkah ke 9\n\n\nclass Makanan {\n  final String nama;\n  final String deskripsi;\n  final String gambar;\n\n  Makanan({\n    required this.nama, \n    required this.deskripsi, \n    required this.gambar,\n  });\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nKode tersebut adalah definisi dari sebuah kelas (class) yang disebut “Makanan”. Kelas ini memiliki tiga properti (properties) yaitu “nama”, “deskripsi”, dan “gambar”, yang semuanya memiliki tipe data String. Properti-properti tersebut ditandai dengan kata kunci “final” yang menunjukkan bahwa setelah objek Makanan dibuat, nilai-nilai properti tersebut tidak dapat diubah.\nSelain itu, kelas Makanan juga memiliki sebuah constructor dengan sintaksis yang sedikit berbeda. Constructor ini menggunakan named parameters (parameter yang diberi nama) dengan menggunakan kurung kurawal {}. Constructor ini memiliki tiga parameter yaitu “nama”, “deskripsi”, dan “gambar”, dan ketiga parameter tersebut ditandai dengan kata kunci “required” yang menunjukkan bahwa nilai-nilai parameter tersebut harus disediakan saat membuat objek Makanan.\n\n\n\nSebelum membuat daftar makanan yang akan ditampilkan, langkah pertama adalah mengunduh gambar-gambar yang akan digunakan. Untuk itu, buatlah folder khusus bernama “assets” di dalam proyek Anda dan simpan gambar-gambar tersebut di dalam folder tersebut.\n\n\n\n\nLangkah ke 10\n\n\nSelanjutnya, Anda perlu menambahkan folder “assets” pada file pubspec.yaml agar gambar yang terdapat di dalamnya dapat diakses oleh aplikasi.\n\n\n\nLangkah ke 10\n\n\n\nBuatlah sebuah file bernama “makanan.dart” yang berisi sebuah list array untuk menyimpan data makanan yang akan di-load dalam aplikasi.\n\nList&lt;Makanan&gt; list_makanan = [\n  Makanan(\n    nama: 'Bubur',\n    deskripsi: 'Nasi Lembek',\n    gambar: 'assets/bubur.jpg',\n  ),\n  Makanan(\n    nama: 'Soto',\n    deskripsi: 'Makanan berkuah',\n    gambar: 'assets/soto.jpg',\n  ),\n  Makanan(\n    nama: 'Pecel',\n    deskripsi: 'Sayuran dengan bumbu kacang',\n    gambar: 'assets/pecel.jpg',\n  ),\n];\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi List: List&lt;Makanan&gt; list_makanan = [...]\n\nList&lt;Makanan&gt; mengindikasikan bahwa list_makanan adalah sebuah List yang berisi objek-objek bertipe Makanan.\n[] menandakan bahwa List tersebut akan diinisialisasi dengan sejumlah elemen objek Makanan.\n\nInisialisasi elemen-elemen List:\n\nSetiap elemen dalam List adalah sebuah objek Makanan yang diinisialisasi dengan menggunakan sintaksis Makanan(...).\nObjek Makanan memiliki tiga atribut: nama, deskripsi, dan gambar. Nilai-nilai atribut tersebut diberikan melalui parameter nama-nama yang sesuai dalam sintaksis inisialisasi objek.\n\n\n\n\n\nSilakan tambahkan atribut yang sesuai dalam ListItem() sesuai dengan atribut yang ada dalam kelas makanan. Gantikan widget container yang berada di dalam row dengan Image.asset(). Kemudian, ubah data dalam teks agar menggunakan atribut yang telah ditambahkan sebelumnya.\n\nfinal String nama;\nfinal String deskripsi;\nfinal String gambar;\nconst ListItem(\n    {super.key,\n    required this.nama,\n    required this.deskripsi,\n    required this.gambar,\n    });\nRow(\n    crossAxisAlignment: CrossAxisAlignment.center,\n    children: [\n        // widget untuk menampilkan gambar lokal\n        Image.asset(\n            gambar,\n            height: 75,\n            width: 75,\n        ),\n        SizedBox(\n        width: 10,\n        ),\n        Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n            Text(\n            nama,\n            style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n            ),\n            ),\n            Text(\n            deskripsi,\n            style: TextStyle(\n                fontWeight: FontWeight.w500,\n            ),\n            ),\n        ],\n        )\n    ],\n),\n\nSilakan buka kembali file home_page.dart dan ubah bagian yang menampilkan ListView menjadi menggunakan ListView.builder.\n\nListView.builder(\n    // mengatur panjang / jumlah item dalam list\n    itemCount: list_makanan.length,\n    padding: EdgeInsets.all(10),\n    itemBuilder: (context, index) {\n        return ListItem(\n        nama: list_makanan[index].nama,\n        deskripsi: list_makanan[index].deskripsi,\n        gambar: list_makanan[index].gambar,\n        );\n    },\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nitemCount: list_makanan.length,: Ini mengatur jumlah item dalam daftar, yang diambil dari panjang (length) dari daftar list_makanan. Jadi, jumlah item dalam daftar akan sesuai dengan jumlah elemen dalam list_makanan.\nitemBuilder: (context, index) { ... },: Ini adalah fungsi yang digunakan untuk membangun tampilan item dalam daftar. Fungsi ini akan dipanggil secara berulang untuk setiap item dalam daftar.\n\ncontext: Objek context yang memberikan informasi tentang lingkungan tampilan saat ini.\nindex: Indeks item saat ini dalam daftar.\n\nreturn ListItem(...);: Di dalam itemBuilder, setiap item dalam daftar dibangun dengan menggunakan widget ListItem. Nilai-nilai yang diperlukan untuk membangun ListItem diambil dari list_makanan dengan menggunakan index saat ini. Ini berarti setiap item dalam daftar akan memiliki nama, deskripsi, dan gambar yang sesuai dengan elemen dalam list_makanan\n\n\n\nSetelah melalui beberapa tahapan, aplikasi studi kasus akhirnya selesai dan siap digunakan. Anda memiliki kebebasan untuk menambahkan data baru atau mengubah tampilan sesuai dengan preferensi Anda."
  },
  {
    "objectID": "4_proyek_1.html",
    "href": "4_proyek_1.html",
    "title": "4  Proyek Kalkulator",
    "section": "",
    "text": "Proyek Kalkulator\nAplikasi Kalkulator adalah proyek Flutter yang bertujuan untuk membuat sebuah kalkulator fungsional yang dapat digunakan untuk melakukan operasi matematika dasar. Aplikasi ini akan menyediakan antarmuka pengguna yang intuitif dan responsif untuk memudahkan pengguna dalam melakukan perhitungan."
  },
  {
    "objectID": "4_proyek_1.html#fitur-utama",
    "href": "4_proyek_1.html#fitur-utama",
    "title": "11  Proyek Kalkulator",
    "section": "11.1 Fitur Utama",
    "text": "11.1 Fitur Utama\n\nTampilan Antarmuka Pengguna:\n\nAplikasi akan memiliki tampilan antarmuka pengguna yang terdiri dari tombol-tombol angka, operator, dan fungsi matematika seperti tambah, kurang, kali, bagi, dan sebagainya.\nTampilan akan dirancang agar mudah digunakan dan memberikan pengalaman pengguna yang intuitif.\n\nPerhitungan Matematika:\n\nPengguna dapat melakukan perhitungan matematika dasar seperti penjumlahan, pengurangan, perkalian, dan pembagian.\nAplikasi akan memiliki logika yang memungkinkan pengguna melakukan perhitungan secara berurutan, menggabungkan beberapa operasi, dan menghasilkan hasil yang akurat.\n\nDesain Responsif:\n\nAplikasi akan memiliki desain yang responsif dan bisa diakses dengan baik di berbagai perangkat dengan ukuran layar yang berbeda."
  },
  {
    "objectID": "4_proyek_1.html#teknologi-yang-digunakan",
    "href": "4_proyek_1.html#teknologi-yang-digunakan",
    "title": "11  Proyek Kalkulator",
    "section": "11.2 Teknologi yang Digunakan",
    "text": "11.2 Teknologi yang Digunakan\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nDart sebagai bahasa pemrograman untuk mengembangkan logika aplikasi.\nWidget dan State Management dari Flutter untuk mengatur tampilan dan interaksi pengguna.\nMatematika dasar menggunakan operator dan fungsi bawaan dari Dart.\n\nTujuan dari proyek ini adalah memberikan pengguna sebuah kalkulator yang dapat digunakan dengan mudah, memiliki performa yang baik, dan memberikan hasil perhitungan yang akurat. Aplikasi Kalkulator ini akan menjadi alat yang berguna untuk keperluan perhitungan sehari-hari, baik untuk kebutuhan pribadi maupun profesional.\nSelama mengembangkan aplikasi Kalkulator, penting untuk memastikan bahwa logika perhitungan matematika benar, antarmuka pengguna responsif dan intuitif, serta mengikuti pedoman desain terbaik dari Flutter."
  },
  {
    "objectID": "4_proyek_1.html#contoh-tampilan-aplikasi",
    "href": "4_proyek_1.html#contoh-tampilan-aplikasi",
    "title": "11  Proyek Kalkulator",
    "section": "11.3 Contoh tampilan aplikasi",
    "text": "11.3 Contoh tampilan aplikasi\nAplikasi kalkulator hanya memiliki satu halaman saja dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nContoh tampilan kalkulator"
  },
  {
    "objectID": "5_routing_navigasi.html",
    "href": "5_routing_navigasi.html",
    "title": "5  Routing dan Navigasi",
    "section": "",
    "text": "Routing dan Navigasi\nMembuat aplikasi yang lebih dari satu halaman dan menavigasikannya."
  },
  {
    "objectID": "5_routing_navigasi.html#widget-navigator",
    "href": "5_routing_navigasi.html#widget-navigator",
    "title": "4  Routing dan Navigasi",
    "section": "4.1 Widget Navigator",
    "text": "4.1 Widget Navigator\nFlutter menyediakan kelas Navigator yang bertanggung jawab untuk mengelola tumpukan tampilan. Setiap kali pengguna berpindah ke tampilan baru, Navigator menambahkannya ke tumpukan dan menampilkan tampilan tersebut di layar. Ketika pengguna menekan tombol “kembali” atau melakukan tindakan kembali lainnya, Navigator akan menghapus tampilan teratas dari tumpukan dan menampilkan tampilan sebelumnya.\nAda beberapa jenis navigator yang dapat digunakan dalam Flutter, di antaranya:\n\n4.1.1 MaterialPageRoute\nMaterialPageRoute: Ini adalah jenis navigator yang umum digunakan dalam aplikasi Flutter yang mengikuti desain material dari Flutter. MaterialPageRoute menampilkan transisi animasi bawaan saat tampilan baru ditampilkan atau ditutup.\n\n\n4.1.2 CupertinoPageRoute\nCupertinoPageRoute: Ini adalah jenis navigator yang mengikuti desain iOS dengan menggunakan transisi animasi khas iOS. Jika Anda ingin aplikasi Anda memiliki tampilan yang mirip dengan aplikasi iOS, Anda dapat menggunakan CupertinoPageRoute."
  },
  {
    "objectID": "5_routing_navigasi.html#navigasi-antar-halaman",
    "href": "5_routing_navigasi.html#navigasi-antar-halaman",
    "title": "4  Routing dan Navigasi",
    "section": "4.2 Navigasi Antar Halaman",
    "text": "4.2 Navigasi Antar Halaman\nAda beberapa metode navigasi yang umum digunakan dalam Flutter:\n\n4.2.1 push\npush: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru. Contoh kode navigator membawa pengguna dari halaman pertama ke halaman kedua.\nElevatedButton(\n    child: const Text('Go to Second Screen'),\n    onPressed: () {\n        Navigator.push(context,\n            MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),\n\n\n4.2.2 pop\npop: Metode ini menghapus rute saat ini dari tumpukan dan membawa pengguna kembali ke halaman sebelumnya. Contoh navigator menghapus halaman kedua dan membawa pengguna kembali ke halaman pertama.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pop(context);\n    },\n),\n\n\n4.2.3 pushReplacement\npushReplacement: Metode ini mengganti rute saat ini dengan rute baru. Ini berguna ketika Anda ingin mengganti halaman tetapi tidak ingin menjaga halaman sebelumnya di tumpukan. Contoh navigator menggantikan halaman saat ini dengan halaman baru.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pushReplacement(context, MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),"
  },
  {
    "objectID": "5_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "href": "5_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "title": "4  Routing dan Navigasi",
    "section": "4.3 Navigasi antar halaman dengan nama route",
    "text": "4.3 Navigasi antar halaman dengan nama route\nAda beberapa metode navigasi dengan nama route yang digunakan dalam Flutter:\n\n4.3.1 pushNamed\npushNamed: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.pushNamed() di dalam Flutter untuk melakukan navigasi dengan nama routes:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk melakukan navigasi ke halaman dengan nama route, gunakan method Navigator.pushNamed() dan berikan nama route yang ingin dituju:\nNavigator.pushNamed(context, '/detail');\n\n\n4.3.2 popAndPushNamed\npopAndPushNamed: Metode ini digunakan untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.popAndPushNamed() di dalam Flutter untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route, gunakan method Navigator.popAndPushNamed() dan berikan nama route yang ingin dituju:\nNavigator.popAndPushNamed(context, '/result');"
  },
  {
    "objectID": "5_routing_navigasi.html#berbagi-data-antar-halaman",
    "href": "5_routing_navigasi.html#berbagi-data-antar-halaman",
    "title": "4  Routing dan Navigasi",
    "section": "4.4 Berbagi Data Antar Halaman",
    "text": "4.4 Berbagi Data Antar Halaman\nDalam Flutter, terdapat beberapa cara untuk berbagi data antara halaman atau layar dalam aplikasi:\n\n4.4.1 Menggunakan Konstruktor\nMenggunakan Konstruktor: Mengirim data menggunakan konstruktor dilakukan dengan cara menginisialisasi data yang ingin dikirim pada konstruktor halaman yang ingin dituju.\n// Halaman Sumber\nNavigator.push(\n    context,\n    MaterialPageRoute(\n    builder: (context) =&gt; HalamanTujuan(\n        data: dataYangDibagikan,\n        ),\n    ),\n);\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    final String data;\n\n    HalamanTujuan({required this.data});\n\n    // ...\n}\n\n\n4.4.2 Menggunakan ModalRoute\nMenggunakan ModalRoute: Untuk mengambil data kembali dari halaman tujuan ke halaman sumber setelah halaman tujuan ditutup, dapat menggunakan ModalRoute dalam kombinasi dengan metode pop.\n// Halaman Sumber\nfinal data = await Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) =&gt; HalamanTujuan()),\n);\n// Proses data yang dikembalikan dari Halaman Tujuan\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    // ...\n    // Pada saat ingin mengirimkan data kembali ke halaman sumber\n    Navigator.pop(context, dataYangDikirimkanKembali);\n    // ...\n}\n\n\n4.4.3 Menggunakan State Management\nMenggunakan State Management: Jika data yang perlu dibagikan di seluruh aplikasi berjumlah banyak, dapat menggunakan paket state management seperti provider, riverpod, maupun bloc untuk mengelola state aplikasi secara global."
  },
  {
    "objectID": "5_routing_navigasi.html#state-management",
    "href": "5_routing_navigasi.html#state-management",
    "title": "4  Routing dan Navigasi",
    "section": "4.5 State Management",
    "text": "4.5 State Management\nSeperti yang sudah dijelaskan sebelumnya jika memiliki data yang banyak keberadaan state management menjadi diperlukan. Ada banyak jenis state management namun pada dasarnya mereka semua sama yaitu untuk membantu perpindahan data dalam flutter.\nPada modul ini state management yang akan digunakan merupakan flutter_riverpod. Flutter Riverpod merupakan pustaka dalam Flutter yang digunakan untuk manajemen state dan dependency injection. Riverpod didasarkan pada konsep “provider” dan memberikan solusi yang lebih sederhana dan fleksibel untuk manajemen state dibandingkan dengan paket Flutter lainnya seperti Provider atau GetX.\nUntuk menggunakan flutter_riverpod terlebih dahulu tambahkan pustakanya didalam pubspec.yaml lalu ketik perintah flutter pub get di terminal atau dengan menggunakan perintah flutter pub add flutter_riverpod. Lalu setelah itu deklarasikan scope dari provider dengan cara sebagai berikut :\nvoid main() {\n    runApp(const ProviderScope(child: MainApp()));\n}\nPaket flutter_provider menyediakan berbagai macam provider yang digunakan untuk manajemen state dan dependency injection dalam aplikasi Flutter. Berikut adalah provider-provider yang umum digunakan dalam flutter_provider:\n\nProvider: Provider ini digunakan untuk menyediakan objek tanpa adanya state yang dapat berubah. Berguna untuk menyediakan ketergantungan yang tidak memerlukan pembaruan atau perubahan state.\nStateProvider: Provider ini digunakan untuk menyediakan objek yang nilainya dapat dimodifikasi dari luar. Berguna dalam kondisi sederhana seperti melakukan fiter atau memberikan data yang bisa diakses dan diperbarui dari berbagai halaman.\nFutureProvider: Provider ini digunakan untuk mengelola hasil dari Future. Ini memungkinkan Anda untuk melakukan pemrosesan asinkron dan mengubah UI ketika future selesai atau mengalami perubahan.\nStateNotifierProvider: Provider ini merupakan provider khusus yang harus digunakan bersama dengan state notifier. State notifer merupakan sebuah kelas yang menyimpan satu tipe data untuk dan dapat diamati setiap aktvitasnya oleh StateNotifierProvider. Provider beserta kelas tersebut dapat digunakan untuk memanipulasi state tingkat lanjut, yang akan sulit direpresentasikan dengan provider yang lebih sederhana seperti [Provider] atau [FutureProvider]."
  },
  {
    "objectID": "5_routing_navigasi.html#studi-kasus",
    "href": "5_routing_navigasi.html#studi-kasus",
    "title": "4  Routing dan Navigasi",
    "section": "4.6 Studi Kasus",
    "text": "4.6 Studi Kasus\nPada studi kasus kali ini kita akan melanjutkan studi kasus pada bab 3. Jadi silahkan ikuti dulu studi kasus bab 3 lalu lanjut ke studi kasus bab ini. Hasil dari studi kasus bab ini adalah aplikasi dengan dua halaman, yaitu halaman list makanan dan halaman detail makanan.\nUntuk membuat aplikasi nya dapat berpindah ke halaman selanjutnya pertama-tama kita harus membuat container / setiap item dalam list di berinteraksi dengan disentuh. Hal ini bisa dilakukan dengan cara membungkus Container dengan InkWell atau GestureDetector. Pada studi kasus ini kita akan menggunakan InkWell. Silahkan buka file list_item.dart dan tambahkan kode berikut.\n@override\nWidget build(BuildContext context) {\nreturn InkWell(\n        onTap: () {},\n        child: Container(\n        // ....\n        ),\n    );\n}\nSetelah dibungkus dengan InkWell item dalam list dapat di berinteraksi dengan sentuhan. Selanjutnya adalah menyiapkan halaman baru yang akan dibuka ketika item dalam list di sentuh. Buat file baru dengan nama detail_page.dart dan buat stateless widget didalamnya.\n\n\n\nLangkah 2\n\n\nclass DetailPage extends StatelessWidget {\n  const DetailPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\nSelanjutnya silahkan desain halaman baru sesuai dengan preferensi. Berikut adalah contoh desain untuk halaman detail.\nWidget build(BuildContext context) {\nreturn Scaffold(\n    body: Column(\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: [\n        Image.asset(\n        'assets/pecel.jpg',\n        scale: 0.5,\n        ),\n        Container(\n        margin: EdgeInsets.all(10),\n        padding: EdgeInsets.all(5),\n        width: double.infinity,\n        decoration: BoxDecoration(\n            border: Border.all(\n            width: 2,\n            ),\n        ),\n        child: Column(\n            children: [\n            Text(\n                \"Pecel\",\n                style: TextStyle(\n                fontSize: 40,\n                fontWeight: FontWeight.bold,\n                ),\n            ),\n            Divider(\n                thickness: 4,\n                color: Colors.black87,\n            ),\n            Text(\n                \"deskripsi\",\n                style: TextStyle(\n                fontSize: 15,\n                fontStyle: FontStyle.italic,\n                ),\n            ),\n            ],\n        ),\n        )\n    ],\n    ),\n);\n}\n\n\n\nContoh Desain\n\n\nSetelah desainnya jadi halaman detail masih belum bisa diakses. Untuk bisa diakses buka file list_item.dart dan tambahkan Navigator pada onTap.\nInkWell(\n    onTap: () {\n    Navigator.push(\n        context, MaterialPageRoute(builder: (context) =&gt; DetailPage()));\n    },\n),\nSekarang setiap item dalam list dapat membuka halaman detail, namun data yang ditampilkan dalam halaman detail masih statis. Maka dari itu kita perlu menambahkan beberapa kode pada DetailPage agar data yang ditampikan menjadi dinamis. Buka kembali detail_page.dart dan tambahkan kode berikut.\nclass DetailPage extends StatelessWidget {\n  final String nama;\n  final String gambar;\n  final String deskripsi;\n  const DetailPage(\n      {super.key,\n      required this.nama,\n      required this.gambar,\n      required this.deskripsi});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        // ...\n        children: [\n          Image.asset(\n            gambar,\n            // ...\n          ),\n          Container(\n            // ...\n            child: Column(\n              children: [\n                Text(\n                  nama,\n                  // ...\n                ),\n                // ...\n                Text(\n                  deskripsi,\n                  // ...\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\nLalu kembali pada file list_item.dart dan sesuaikan sesuaikan Navigator pada onTap\nInkWell(\n    onTap: () {\n    Navigator.push(\n        context,\n        MaterialPageRoute(\n        builder: (context) =&gt; DetailPage(\n            nama: nama,\n            gambar: gambar,\n            deskripsi: deskripsi,\n        ),\n        ),\n    );\n    },\n),\nSetelah melalui beberapa tahapan maka studi kasus bab ini pun selesai. Berikut gambaran akhir halaman detail.\n\n\n\nHasil"
  },
  {
    "objectID": "6_pengujian_debugging.html",
    "href": "6_pengujian_debugging.html",
    "title": "6  Pengujian dan Debugging",
    "section": "",
    "text": "Pengujian dan Debugging"
  },
  {
    "objectID": "6_pengujian_debugging.html#debugging-di-flutter",
    "href": "6_pengujian_debugging.html#debugging-di-flutter",
    "title": "5  Pengujian dan Debugging",
    "section": "5.1 Debugging di Flutter",
    "text": "5.1 Debugging di Flutter\nProses debugging dalam Flutter melibatkan pencarian dan perbaikan kesalahan atau bug yang ada dalam aplikasi. Ada beberapa metode yang dapat digunakan dalam proses debugging pada Flutter:\n\n5.1.1 Print\nMencetak pesan kesalahan pada terminal menggunakan pernyataan ‘print’: Saat aplikasi mengalami kegagalan atau kesalahan, pernyataan “print” dapat ditambahkan di berbagai bagian kode untuk mencetak nilai variabel atau pesan di konsol. Pencetakan pesan kesalahan ini dapat memberikan petunjuk tentang lokasi masalah, seperti baris kode yang menyebabkan kesalahan tersebut.\nContoh penggunaan pernyataan ‘print’:\nprint('Nilai dari variabel x: $x');\n\n\n5.1.2 Breakpoint\nBreakpoint: Breakpoint dapat ditempatkan dalam kode untuk memberhentikan eksekusi program sehingga nilai variabel, status aplikasi, dan alur eksekusi dapat diperiksa.\n\n\n5.1.3 Debugger\nMenjalankan Aplikasi dalam Mode Debug atau menggunakan debugger: Aplikasi dapat dijalankan dalam mode debug dengan membuka terminal dan menjalankan perintah “flutter run –debug”. Debugger adalah alat yang disediakan dalam Flutter yang memungkinkan untuk melihat kode secara rinci dan melakukan pemecahan masalah dengan lebih efisien. Debugger dapat membantu melacak nilai variabel, melihat tumpukan panggilan (stack trace), dan memperbaiki bug secara interaktif.\n\n\n5.1.4 Logging\nLogging: Logging merupakan proses pencatatan aktivitas di dalam aplikasi. Pernyataan logging dapat membantu dalam memahami alur eksekusi dan memeriksa nilai variabel.\nContoh penggunaan logging:\nimport 'package:logger/logger.dart';\n\nvar logger = Logger();\n\nlogger.d('Pesan debug');\nlogger.i('Pesan info');\nlogger.w('Pesan peringatan');\nlogger.e('Pesan error');\nlogger.f('Pesan fatal');\n\n\n5.1.5 Inspector Flutter\nInspector Flutter: Flutter menyediakan Inspector, yaitu alat visual yang membantu menganalisis widget dan properti dalam aplikasi. Inspector dapat membantu dalam memahami struktur widget dan melacak masalah dengan widget tertentu. Inspector dapat diaktifkan dengan menekan tombol “Toggle Inspector” pada toolbar dalam mode debug.\n\n\n5.1.6 Exception Handling\nException Handling: Exception Handling adalah cara untuk menangani kesalahan atau pengecualian yang terjadi selama eksekusi kode. Dengan menangani pengecualian, crash pada aplikasi dapat dihindari.\nContoh penggunaan Exception Handling:\ntry {\n  // beberapa kode yang dapat menimbulkan pengecualian\n} catch (e) {\n  // menangani pengecualian\n}\n\n\n5.1.7 Dokumentasi dan Komunitas\nMembaca Dokumentasi dan Menggunakan Komunitas: Dokumentasi resmi Flutter menyediakan informasi yang lengkap dan bermanfaat. Jika Anda mengalami kesulitan dalam proses debugging, Anda dapat merujuk pada dokumentasi Flutter yang dapat memberikan informasi yang berguna. Selain itu, komunitas pengembang Flutter juga merupakan sumber daya yang berharga, di mana Anda dapat mencari bantuan dan berdiskusi dengan pengembang lainnya."
  },
  {
    "objectID": "6_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "href": "6_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "title": "5  Pengujian dan Debugging",
    "section": "5.2 Menggunakan Unit Test untuk Uji Logika",
    "text": "5.2 Menggunakan Unit Test untuk Uji Logika\nUnit testing adalah proses pengujian perangkat lunak yang dilakukan pada tingkat terkecil, yaitu pada unit-unit kode yang independen dan dapat diuji secara terpisah. Dalam konteks Flutter, unit testing digunakan untuk menguji fungsi-fungsi individual dalam aplikasi Flutter. Tujuan dari unit testing adalah untuk memastikan bahwa setiap unit kode berfungsi sesuai dengan harapan, dan untuk menghindari bug atau kesalahan yang mungkin terjadi pada aplikasi.\nBerikut adalah langkah-langkah umum untuk melakukan unit testing pada Flutter:\nLangkah 1: Menyiapkan Proyek - Buat proyek Flutter baru atau buka proyek Flutter yang sudah ada. - Impor package “flutter_test” ke dependencies dalam file pubspec.yaml dan jalankan perintah ‘flutter pub get’ untuk menginstalnya.\nLangkah 2: Membuat File Test - Buat file baru dengan ekstensi .dart di dalam direktori test dengan nama yang diakhiri dengan “_test.dart” untuk menyimpan tes unit. - Impor paket flutter_test dan file yang ingin Anda uji, contohnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:nama_aplikasi/file_yang_di_uji.dart';\nLangkah 3: Menulis Tes Unit Buat test case dengan menambahkan fungsi yang menguji fungsi atau metode tertentu. Contoh:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/utils.dart';\n\nvoid main() {\n  test('Test add function', () {\n    expect(add(1, 2), equals(3));\n    expect(add(0, 0), equals(0));\n    expect(add(-1, 1), equals(0));\n  });\n\n  test('Test subtract function', () {\n    expect(subtract(3, 1), equals(2));\n    expect(subtract(0, 0), equals(0));\n    expect(subtract(-1, 1), equals(-2));\n  });\n}\nLangkah 4: Menjalankan Tes Unit - Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus unit testing."
  },
  {
    "objectID": "6_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "href": "6_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "title": "5  Pengujian dan Debugging",
    "section": "5.3 Menggunakan Widget Test untuk Uji Widget",
    "text": "5.3 Menggunakan Widget Test untuk Uji Widget\nWidget testing adalah metode pengujian yang digunakan untuk memastikan bahwa widget-widget dalam aplikasi Flutter berfungsi seperti yang diharapkan. Tujuan dari widget testing adalah untuk memastikan bahwa widget berfungsi dengan benar dan sesuai dengan harapan pada saat runtime.\nBerikut adalah langkah-langkah dasar dalam melakukan widget testing pada Flutter:\n\nMenyiapkan Dependensi: Pastikan bahwa dependensi yang diperlukan dalam file pubspec.yaml proyek Flutter sudah tersedia. Jika belum ada, dependensi dapat ditambahkan sebagai berikut:\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\nMembuat File Test: Buat file test baru dengan ekstensi .dart dan nama yang diakhiri dengan “_test.dart” di direktori “test” pada proyek Flutter dalam direktori test proyek. Misalnya, widget_test.dart.\nMengimpor Paket dan Widget yang Dibutuhkan: Dalam file widget_test.dart, impor paket-paket dan widget-widget yang akan diuji. Misalnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter/material.dart';\nimport 'package:my_app/my_widget.dart';\nMenulis Test Case: Buat test case dengan menambahkan fungsi yang menguji widget tertentu. Contoh:\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('Test MyButton widget', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    final button = find.byType(MyButton);\n    expect(button, findsOneWidget);\n\n    await tester.tap(button);\n    await tester.pump();\n\n    final text = find.text('Button clicked');\n    expect(text, findsOneWidget);\n  });\n}\n\nMenjalankan Test: Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus widget testing."
  },
  {
    "objectID": "7_akses_data_lokal.html",
    "href": "7_akses_data_lokal.html",
    "title": "7  Akses Data Lokal",
    "section": "",
    "text": "Akses Data Lokal"
  },
  {
    "objectID": "7_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "href": "7_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "title": "6  Akses Data Lokal",
    "section": "6.1 Penyimpanan dengan Shared Preferences",
    "text": "6.1 Penyimpanan dengan Shared Preferences\nShared Preferences adalah sebuah mekanisme penyimpanan data sederhana yang digunakan untuk menyimpan dan mengambil nilai-nilai (data) secara persisten di aplikasi. Hal ini berarti data yang disimpan dengan menggunakan Shared Preferences akan tetap ada meskipun aplikasi ditutup dan dijalankan kembali.\nDalam penggunaan sehari-hari, Shared Preferences sering digunakan untuk menyimpan preferensi pengguna seperti pengaturan, preferensi tema, atau data lain yang perlu dipertahankan antar-sesi aplikasi.\nBerikut ini adalah langkah-langkah sederhana untuk menggunakan Shared Preferences dalam Flutter:\n\nPertama, tambahkan dependensi SharedPreferences ke file pubspec.yaml di proyek Flutter Anda:\n\ndependencies:\n  shared_preferences: ^x.x.x\n\nKemudian, impor package shared_preferences:\n\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSelanjutnya, Anda dapat menggunakan Shared Preferences untuk menyimpan dan mengambil data. Misalnya, untuk menyimpan sebuah nilai (contohnya, preferensi pengguna), Anda dapat melakukannya sebagai berikut:\n\n// Membuat sebuah instance dari SharedPreferences\nSharedPreferences prefs = await SharedPreferences.getInstance();\n\n// Menyimpan nilai dengan menggunakan key 'nama'\nprefs.setString('nama', 'udinus');\n\nUntuk mengambil nilai yang telah disimpan sebelumnya, Anda dapat menggunakan kode berikut:\n\n// Mengambil nilai dengan menggunakan key 'nama'\nString? nama = prefs.getString('nama');\nDalam contoh di atas, variabel nama akan berisi nilai yang telah disimpan sebelumnya (‘udinus’) jika ada, atau null jika tidak ada nilai yang disimpan dengan key ‘nama’."
  },
  {
    "objectID": "7_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "href": "7_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "title": "6  Akses Data Lokal",
    "section": "6.2 Penyimpanan dengan Sqlite",
    "text": "6.2 Penyimpanan dengan Sqlite\nSQLite adalah sebuah database relasional ringan yang sering digunakan dalam pengembangan aplikasi mobile, termasuk Flutter. SQLite dapat bekerja dengan database yang disimpan secara lokal di perangkat pengguna.\nSQLite pada Flutter memungkinkan Anda menyimpan, mengelola, dan mengakses data secara efisien. Dalam konteks Flutter, Anda dapat menggunakan paket sqflite untuk berinteraksi dengan SQLite.\n\n6.2.1 Konfigurasi dan Pengaturan Awal\nUntuk menghubungkan aplikasi dengan sqlite diperlukan beberapa konfigurasi. Berikut adalah langkah langkah konfigurasi agar dapat terhubung dengan sqlite:\n\nMengimpor dependensi\n\nimpor dependensi sqflite, path, dan path_provider pada file pubspec.yaml:\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nJalankan perintah flutter pub get untuk mengunduh dependensi tersebut. Untuk menghubungkan aplikasi dengan sqlite sebenernya hanya memerlukan dependesi sqflite. Namun sebagai pembantu dalam membuat database diperlukan dua dependesi pembantu yaitu path, dan path_provider.\n\nMembuat Database Helper\n\nSetelah ditambahkan dependeciesnya aplikasi tidak langsung dapat mengakses sqlite. Terlebih dahulu dibuat sebuah class khusus untuk menghubungkan aplikasi dengan sqlite. Dalam class tersebut database akan di inisialisasi ketika belum dibuat.\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._();\n  static Database? _database;\n\n  DatabaseHelper._();\n\n  Future&lt;Database&gt; get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future&lt;Database&gt; _initDatabase() async {\n    Directory directory = await getApplicationDocumentsDirectory();\n    String path = join(\n        directory.path, \n        'my_database.db',\n    );\n    return await openDatabase(\n        path, \n        version: 1, \n        onCreate: _createDb,\n    );\n  }\n\n  Future&lt;void&gt; _createDb(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE IF NOT EXISTS my_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        age INTEGER\n      )\n    '''\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi dan inisialisasi variabel instance sebagai instance tunggal dari kelas DatabaseHelper. Variabel ini bertipe DatabaseHelper dan dideklarasikan sebagai static final, sehingga hanya ada satu instance dari kelas ini yang dapat digunakan.\nDeklarasi variabel _database sebagai variabel database yang digunakan dalam kelas. Variabel ini ditandai dengan tanda tanya (?) yang menandakan bahwa nilainya bisa null. Variabel ini bersifat private karena diawali dengan underscore (_).\nKonstruktor _DatabaseHelper._() merupakan konstruktor private yang tidak bisa diakses dari luar kelas. Ini dilakukan agar kelas ini tidak dapat diinisialisasi dari luar.\nFungsi database merupakan getter yang mengembalikan Future&lt;Database&gt;. Fungsi ini digunakan untuk mendapatkan akses ke database. Pada awalnya, fungsi ini mengecek apakah _database sudah terinisialisasi, jika sudah, maka langsung mengembalikan _database yang sudah ada. Jika belum, maka fungsi _initDatabase() dipanggil untuk menginisialisasi database dan mengembalikan nilainya.\nFungsi _initDatabase() merupakan fungsi yang digunakan untuk menginisialisasi database. Pada fungsi ini, direktori aplikasi diakses menggunakan getApplicationDocumentsDirectory() dan path untuk database dibentuk dengan menggabungkan path direktori aplikasi dengan nama file database. Kemudian, fungsi openDatabase() dipanggil dengan menggunakan path tersebut, dan versi database serta callback _createDb untuk aksi pembuatan tabel.\nFungsi _createDb() merupakan callback yang dipanggil saat database dibuat. Pada fungsi ini, tabel my_table akan dibuat jika belum ada. Tabel tersebut memiliki tiga kolom yaitu id sebagai kunci utama yang diatur untuk otomatis bertambah nilainya (AUTOINCREMENT), name sebagai teks, dan age sebagai bilangan bulat.\n\n\n\n\n\n6.2.2 CRUD Data dengan SQLite\n\nImplementasi CRUD\n\nSelanjutnya, agar aplikasi dapat melakukan interaksi dengan database seperti menambah, mengupdate, menghapus, dan mendapatkan data diperlukan method tambahan di dalam class DatabaseHelper. Method tersebut mengembalikan nilai Future karena memerlukan proses pengambilan data terlebih dahulu yang biasanya sedikit memakan waktu.\nclass DatabaseHelper {\n  // ...\n  \n  Future&lt;int&gt; insert(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    return await db.insert('my_table', row);\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; queryAll() async {\n    Database db = await instance.database;\n    return await db.query('my_table');\n  }\n\n  Future&lt;int&gt; update(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    int id = row['id'];\n    return await db.update(\n        'my_table', \n        row, \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n\n  Future&lt;int&gt; delete(int id) async {\n    Database db = await instance.database;\n    return await db.delete(\n        'my_table', \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nMetode insert:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan dimasukkan ke dalam tabel database.\nPertama, kita mendapatkan instance objek Database dengan menggunakan await instance.database. instance adalah sebuah objek yang memiliki method database yang mengembalikan objek Database.\nKemudian, menggunakan objek db, kita menggunakan metode insert untuk memasukkan data ke dalam tabel dengan nama ‘my_table’. Metode insert mengembalikan nilai int yang merupakan id dari row yang baru saja dimasukkan.\nMetode insert mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode queryAll:\n\nMetode ini tidak menerima parameter.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode query untuk melakukan kueri terhadap tabel dengan nama ‘my_table’.\nMetode query mengembalikan objek Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya berupa List dari Map yang berisi data dari tabel.\n\nMetode update:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan diperbarui pada tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nKita mengambil nilai id dari row dengan menggunakan int id = row['id'].\nMenggunakan objek db, kita menggunakan metode update untuk memperbarui data pada tabel ‘my_table’. Metode update mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh perubahan.\nMetode update mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode delete:\n\nMetode ini menerima parameter id yang merupakan nilai id yang akan dihapus dari tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode delete untuk menghapus baris dengan kondisi ‘id = ?’ dari tabel ‘my_table’. whereArgs: [id] digunakan untuk menggantikan ? dengan nilai id.\nMetode delete mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh penghapusan.\nMetode delete mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\n\n\n\n\n\n6.2.3 Query Pencarian Database Lokal\n\nImplementasi query search\n\nSetelah menambahkan method-method diatas aplikasi sudah mampu berinteraksi dengan database. Namun sebagai tambahan akan lebih seru jika aplikasi dapat mencari data didalam database. Maka dari itu selanjutnya, dalam DatabaseHelper, tambahkan metode untuk melakukan operasi query search:\nclass DatabaseHelper {\n  // ...\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {\n    Database? db = await database;\n    return await db!.query(\n        'your_table', \n        where: 'name LIKE ?', \n        whereArgs: ['%$query%'],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nFuture&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {:\n\nMembuka definisi fungsi querySearch yang menerima string query sebagai argumen dan mengembalikan Future yang berisi daftar hasil pencarian.\n\nDatabase? db = await database;:\n\nMembuat variabel db yang bertipe Database? (nullable) dan menginisialisasinya dengan hasil pemanggilan await database.\nKata kunci await digunakan untuk menunggu hingga database selesai di-load sebelum melanjutkan eksekusi kode.\n\nreturn await db!.query('your_table', where: 'name LIKE ?', whereArgs: ['%$query%']);:\n\nMengembalikan hasil dari pemanggilan metode query pada objek db.\nMetode query digunakan untuk melakukan kueri pada tabel database.\nParameter pertama 'your_table' adalah nama tabel yang ingin dikueri.\nParameter where digunakan untuk menentukan kondisi pencarian yang diterapkan pada kueri. Dalam hal ini, kondisi adalah 'name LIKE ?', yang berarti kolom ‘name’ harus mirip dengan nilai yang diberikan.\nParameter whereArgs berisi daftar argumen yang akan menggantikan tanda tanya (?) dalam kondisi pencarian. Dalam hal ini, argumen yang digunakan adalah ['%$query%'], yang akan mencocokkan nilai dengan string yang mengandung query di mana pun dalam nilainya."
  },
  {
    "objectID": "7_akses_data_lokal.html#studi-kasus",
    "href": "7_akses_data_lokal.html#studi-kasus",
    "title": "6  Akses Data Lokal",
    "section": "6.3 Studi Kasus",
    "text": "6.3 Studi Kasus\nSetelah mengetahui cara menghubungkan dan berinteraksi dengan database sqlite pada aplikasi flutter tahap selanjutnya adalah membuat studi kasus. Pada studi kasus bab ini kita akan mencoba membuat aplikasi yang dapat melakukan crud data mahasiswa dengan menggunakan sqlite pada flutter. Pertama-tama silahkan buat projek flutter baru. Lalu setelah itu tambahkan dependencies database_helper.dart masukan sqflite, path_provider dan path pada pubspec.yaml.\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nSetelah itu buat file database_helper.dart. Didalam file ini kita akan membuat class DatabaseHelper sama seperti penjelasan diatas namun dengan beberapa perubahan menyesuaikan dengan studi kasus crud data mahasiswa.\n\n\n\nStudi Kasus Details\n\n\nimport 'dart:async';\nimport 'dart:io' as io;\nimport 'package:path/path.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'package:path_provider/path_provider.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper _instance = DatabaseHelper.internal();\n\n  factory DatabaseHelper() =&gt; _instance;\n\n  static Database? _db;\n\n  Future&lt;Database?&gt; get db async {\n    if (_db != null) return _db;\n    _db = await initDb();\n    return _db;\n  }\n\n  DatabaseHelper.internal();\n\n  Future&lt;Database&gt; initDb() async {\n    io.Directory documentsDirectory = await \n    getApplicationDocumentsDirectory();\n    String path = join(\n        documentsDirectory.path, \n        'database.db',\n    );\n    var theDb = await openDatabase(\n        path, \n        version: 1, \n        onCreate: _onCreate,\n    );\n    return theDb;\n  }\n\n  void _onCreate(Database db, int version) async {\n    await db.execute(\n        '''\n        CREATE TABLE \n        IF NOT EXISTS mahasiswa \n        (id INTEGER PRIMARY KEY, name TEXT, nim TEXT)\n        '''\n    );\n  }\n\n  Future&lt;int&gt; addMahasiswa(Map&lt;String, dynamic&gt; mahasiswa) \n  async {\n    var dbClient = await db;\n    return await dbClient!.insert('mahasiswa', mahasiswa);\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getAllMahasiswa() \n  async {\n    var dbClient = await db;\n    return await dbClient!.query('mahasiswa');\n  }\n\n  Future&lt;int&gt; updateMahasiswa(Map&lt;String, dynamic&gt; mahasiswa) \n  async {\n    var dbClient = await db;\n    return await dbClient!.update('mahasiswa', mahasiswa,\n        where: 'id = ?', whereArgs: [mahasiswa['id']]);\n  }\n\n  Future&lt;int&gt; deleteMahasiswa(int id) async {\n    var dbClient = await db;\n    return await dbClient!\n        .delete(\n            'mahasiswa', \n            where: 'id = ?', \n            whereArgs: [id],\n        );\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; searchMahasiswa(String keyword) \n  async {\n    var dbClient = await db;\n    return await dbClient!\n        .query(\n            'mahasiswa', \n            where: 'name LIKE ?', \n            whereArgs: ['%$keyword%'],\n        );\n  }\n}\nSelanjutnya buatlah satu tampilan sederhana untuk menampung data dari database, menambah data, menghapus data, mengupdate data, dan melakukan pencarian data. Tampilan akan ditampung dalam StatefullWidget dikarenakan data yang digunakan dalam tampilan tersebut akan berubah menyesuaikan dengan isi database. Berikut adalah contoh dari tampilannya.\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'CRUD App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  final TextEditingController _searchController = \n  TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('CRUD App'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) {},\n            ),\n          ),\n          Expanded(\n            child: ListTile(\n              title: Text(\"Nama\"),\n              subtitle: Text(\"NIM\"),\n              trailing: IconButton(\n                icon: Icon(Icons.delete),\n                onPressed: () {},\n              ),\n              onTap: () =&gt; showDialog(\n                context: context,\n                builder: (context) =&gt; AlertDialog(\n                  title: Text('Edit Data'),\n                  content: Column(\n                    mainAxisSize: MainAxisSize.min,\n                    children: [\n                      TextField(\n                        decoration: InputDecoration(\n                          labelText: 'Nama',\n                        ),\n                        controller: \n                        TextEditingController(text: \"Nama\"),\n                        onChanged: (value) {},\n                      ),\n                      TextField(\n                        decoration: InputDecoration(\n                          labelText: 'NIM',\n                        ),\n                        controller: \n                        TextEditingController(text: \"NIM\"),\n                        onChanged: (value) {},\n                      ),\n                    ],\n                  ),\n                  actions: [\n                    ElevatedButton(\n                      onPressed: () {\n                        Navigator.pop(context);\n                      },\n                      child: Text('Save'),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\n\nStudi Kasus Details\n\n\nSetelah itu tambahkan beberapa atribut dan method dalam HomePage supaya dapat terhubung dengan database melalui DatabaseHelper\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  final dbHelper = DatabaseHelper();\n  List&lt;Map&lt;String, dynamic&gt;&gt; _items = [];\n\n  void refreshItemList() async {\n    final items = await dbHelper.getAllMahasiswa();\n    setState(() {\n      _items = items;\n    });\n  }\n\n  void searchItems() async {\n    final keyword = _searchController.text.trim();\n    if (keyword.isNotEmpty) {\n      final items = await dbHelper.searchMahasiswa(keyword);\n      setState(() {\n        _items = items;\n      });\n    } else {\n      refreshItemList();\n    }\n  }\n\n  void addItem() async {\n    final item = {\n      'name': 'udinus',\n      'nim': 'a11.2020.12345',\n    };\n    await dbHelper.addMahasiswa(item);\n    refreshItemList();\n  }\n\n  void updateItem(int id, String name, String nim) async {\n    final item = {\n      'id': id,\n      'name': name,\n      'nim': nim,\n    };\n    await dbHelper.updateMahasiswa(item);\n    refreshItemList();\n  }\n\n  void deleteItem(int id) async {\n    await dbHelper.deleteMahasiswa(id);\n    refreshItemList();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nfinal dbHelper = DatabaseHelper();\n\nMembuat objek dbHelper yang merupakan instance dari kelas DatabaseHelper. Objek ini akan digunakan untuk mengakses dan memanipulasi data pada database.\n\nList&lt;Map&lt;String, dynamic&gt;&gt; _items = [];\n\nMembuat variabel _items yang merupakan daftar item mahasiswa dalam bentuk List of Maps. Setiap item direpresentasikan sebagai Map yang memiliki tipe data String sebagai kunci dan dynamic sebagai nilai. Variabel ini akan digunakan untuk menyimpan hasil query dari database.\n\nvoid refreshItemList() async {...}\n\nFungsi refreshItemList digunakan untuk memperbarui daftar item dengan memanggil metode getAllMahasiswa dari objek dbHelper. Fungsi ini menggunakan kata kunci await untuk menunggu hasil query dari database sebelum memperbarui nilai variabel _items. Setelah nilai _items diperbarui, fungsi setState dipanggil untuk memberi tahu framework Flutter bahwa state telah berubah dan perlu diperbarui tampilan UI.\n\nvoid searchItems() async {...}\n\nFungsi searchItems digunakan untuk mencari item mahasiswa berdasarkan kata kunci yang diinputkan. Pertama, kata kunci diambil dari controller teks _searchController dan di-trim untuk menghapus spasi di awal dan akhir. Jika kata kunci tidak kosong, fungsi ini akan memanggil metode searchMahasiswa dari objek dbHelper dengan kata kunci sebagai argumen. Hasil query kemudian disimpan dalam variabel items, dan nilai _items diperbarui dengan nilai items tersebut. Jika kata kunci kosong, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid addItem() async {...}\n\nFungsi addItem digunakan untuk menambahkan item mahasiswa baru ke database. Item baru didefinisikan sebagai Map dengan kunci ‘name’ dan ‘nim’, dan nilai yang sesuai. Fungsi ini memanggil metode addMahasiswa dari objek dbHelper dengan item sebagai argumen. Setelah penambahan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid updateItem(int id, String name, String nim) async {...}\n\nFungsi updateItem digunakan untuk memperbarui item mahasiswa dengan ID, nama, dan NIM yang baru. Item yang akan diperbarui didefinisikan sebagai Map dengan kunci ‘id’, ‘name’, dan ‘nim’, dan nilai yang sesuai. Fungsi ini memanggil metode updateMahasiswa dari objek dbHelper dengan item sebagai argumen. Setelah pembaruan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid deleteItem(int id) async {...}\n\nFungsi deleteItem digunakan untuk menghapus item mahasiswa berdasarkan ID-nya. Fungsi ini memanggil metode deleteMahasiswa dari objek dbHelper dengan ID sebagai argumen. Setelah penghapusan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\n\n\n\nLalu agar ketika pertama kali dibuka data dari database langsung ditampilkan panggil method refreshItemList() pada initState()\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  @override\n  void initState() {\n    super.initState();\n    refreshItemList();\n  } \n\n  // ...\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nDalam kode tersebut, @override menandakan bahwa metode initState() di bawahnya menggantikan atau mendapatkan ulang perilaku dari metode initState() yang ada dalam kelas induk. Dalam hal ini, kelas induk tersebut adalah StatefulWidget.\nMetode super.initState() dipanggil untuk menjalankan implementasi dari metode initState() dalam kelas induk. Ini memungkinkan kelas induk melakukan inisialisasi yang diperlukan sebelum melakukan inisialisasi khusus pada kelas turunan.\nKemudian, refreshItemList() dipanggil setelah super.initState() untuk memperbarui daftar item. Ini mungkin adalah metode khusus yang ditentukan di dalam kelas tersebut untuk memperbarui daftar item yang akan ditampilkan di widget.\n\n\nlangkah terakhir adalah dengan memanggil method method tersebut dengan widget dalam aplikasi seperti tombol, text field, dan listview.\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('CRUD App'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) =&gt; searchItems(),\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _items.length,\n              itemBuilder: (context, index) {\n                final item = _items[index];\n                return ListTile(\n                  title: Text(item['name']),\n                  subtitle: Text(item['nim']),\n                  trailing: IconButton(\n                    icon: Icon(Icons.delete),\n                    onPressed: () =&gt; deleteItem(item['id']),\n                  ),\n                  onTap: () =&gt; showDialog(\n                    context: context,\n                    builder: (context) =&gt; AlertDialog(\n                      title: Text('Edit Item'),\n                      content: Column(\n                        mainAxisSize: MainAxisSize.min,\n                        children: [\n                          TextField(\n                            decoration: InputDecoration(\n                              labelText: 'Nama',\n                            ),\n                            controller:\n                                TextEditingController(\n                                    text: item['name'],\n                                ),\n                            onChanged: (value) =&gt; \n                            item['name'] = value,\n                          ),\n                          TextField(\n                            decoration: InputDecoration(\n                              labelText: 'NIM',\n                            ),\n                            controller:\n                             TextEditingController(\n                                text: item['nim'],\n                             ),\n                            onChanged: (value) =&gt; \n                            item['nim'] = value,\n                          ),\n                        ],\n                      ),\n                      actions: [\n                        ElevatedButton(\n                          onPressed: () {\n                            updateItem(\n                                item['id'], \n                                item['name'], \n                                item['nim'],\n                                );\n                            Navigator.pop(context);\n                          },\n                          child: Text('Save'),\n                        ),\n                      ],\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: addItem,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nAppBar: Ini adalah bilah aplikasi yang menampilkan judul “CRUD App”. Digunakan sebagai bagian atas aplikasi.\nColumn: Ini adalah widget yang digunakan untuk mengatur tata letak secara vertikal. Di dalam Column, terdapat beberapa widget lain yang ditampilkan secara berurutan.\nTextField: Ini adalah input teks yang digunakan untuk melakukan pencarian item. TextField menerima kontroler _searchController yang digunakan untuk mengontrol isian dan onChanged dipanggil ketika teks berubah untuk memicu fungsi searchItems().\nExpanded: Ini adalah widget yang digunakan untuk memperluas widget anak ke ruang yang tersedia. Di dalam Expanded, terdapat ListView.builder yang digunakan untuk menampilkan daftar item.\nListView.builder: Ini adalah widget yang digunakan untuk membuat daftar yang dapat digulir secara dinamis. ListView.builder mengambil itemCount dari _items.length dan membangun item pada indeks tertentu menggunakan fungsi itemBuilder.\nListTile: Ini adalah widget yang digunakan untuk menampilkan setiap item dalam daftar. Setiap ListTile berisi judul item (Text(item['name'])), subjudul item (Text(item['nim'])), dan ikon tombol hapus (Icon(Icons.delete)). Ketika ikon hapus diklik, fungsi deleteItem(item['id']) dipanggil.\nonTap: Ini adalah fungsi yang dipicu ketika ListTile ditekan. Fungsi ini menampilkan dialog AlertDialog yang memungkinkan pengguna untuk mengedit item. Di dalam AlertDialog, terdapat dua TextField untuk mengedit nama dan NIM item. Ketika tombol “Save” diklik, fungsi updateItem(item['id'], item['name'], item['nim']) dipanggil dan dialog ditutup dengan Navigator.pop(context).\nfloatingActionButton: Ini adalah tombol tindakan mengambang yang ditempatkan di sudut kanan bawah. Ketika tombol ini ditekan, fungsi addItem() dipanggil."
  },
  {
    "objectID": "9_akses_data_api.html",
    "href": "9_akses_data_api.html",
    "title": "8  Akses Data Melalui API",
    "section": "",
    "text": "Akses Data Melalui API"
  },
  {
    "objectID": "9_akses_data_api.html#konsep-dasar-rest-api",
    "href": "9_akses_data_api.html#konsep-dasar-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.1 Konsep Dasar REST API",
    "text": "7.1 Konsep Dasar REST API"
  },
  {
    "objectID": "9_akses_data_api.html#menggunakan-package-http",
    "href": "9_akses_data_api.html#menggunakan-package-http",
    "title": "7  Akses Data Melalui API",
    "section": "7.2 Menggunakan Package HTTP",
    "text": "7.2 Menggunakan Package HTTP"
  },
  {
    "objectID": "9_akses_data_api.html#mengambil-data-dari-rest-api",
    "href": "9_akses_data_api.html#mengambil-data-dari-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.3 Mengambil Data dari REST API",
    "text": "7.3 Mengambil Data dari REST API"
  },
  {
    "objectID": "9_akses_data_api.html#menampilkan-data-pada-widget",
    "href": "9_akses_data_api.html#menampilkan-data-pada-widget",
    "title": "7  Akses Data Melalui API",
    "section": "7.4 Menampilkan Data pada Widget",
    "text": "7.4 Menampilkan Data pada Widget"
  },
  {
    "objectID": "10_integrasi_baas.html",
    "href": "10_integrasi_baas.html",
    "title": "10  Integrasi dengan BAaS",
    "section": "",
    "text": "Integrasi dengan BAaS"
  },
  {
    "objectID": "10_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "href": "10_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.1 Konsep BAaS dan Serverless Application",
    "text": "8.1 Konsep BAaS dan Serverless Application"
  },
  {
    "objectID": "10_integrasi_baas.html#pengenalan-supabase",
    "href": "10_integrasi_baas.html#pengenalan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.2 Pengenalan Supabase",
    "text": "8.2 Pengenalan Supabase"
  },
  {
    "objectID": "10_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "href": "10_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.3 Integrasi Supabase dengan Flutter",
    "text": "8.3 Integrasi Supabase dengan Flutter"
  },
  {
    "objectID": "10_integrasi_baas.html#otentikasi-dengan-supabase",
    "href": "10_integrasi_baas.html#otentikasi-dengan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.4 Otentikasi dengan Supabase",
    "text": "8.4 Otentikasi dengan Supabase"
  },
  {
    "objectID": "10_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "href": "10_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.5 Pengunaan Supabase untuk Penyimpanan Data",
    "text": "8.5 Pengunaan Supabase untuk Penyimpanan Data"
  },
  {
    "objectID": "11_layanan_berbasis_lokasi.html",
    "href": "11_layanan_berbasis_lokasi.html",
    "title": "11  Layanan Berbasis Lokasi",
    "section": "",
    "text": "Layanan Berbasis Lokasi"
  },
  {
    "objectID": "11_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "href": "11_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.1 Menggunakan Package Location",
    "text": "9.1 Menggunakan Package Location"
  },
  {
    "objectID": "11_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "href": "11_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.2 Mengunakan Widget Geolocator",
    "text": "9.2 Mengunakan Widget Geolocator"
  },
  {
    "objectID": "11_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "href": "11_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.3 Menampilkan OpenStreetMap API pada Aplikasi",
    "text": "9.3 Menampilkan OpenStreetMap API pada Aplikasi"
  },
  {
    "objectID": "12_pengamanan_aplikasi.html",
    "href": "12_pengamanan_aplikasi.html",
    "title": "12  Pengamanan Aplikasi",
    "section": "",
    "text": "Pengamanan Aplikasi"
  },
  {
    "objectID": "12_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "href": "12_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS",
    "text": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS"
  },
  {
    "objectID": "12_pengamanan_aplikasi.html#autentikasi-pengguna",
    "href": "12_pengamanan_aplikasi.html#autentikasi-pengguna",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.2 Autentikasi Pengguna",
    "text": "10.2 Autentikasi Pengguna"
  },
  {
    "objectID": "12_pengamanan_aplikasi.html#obfuscating-dart-code",
    "href": "12_pengamanan_aplikasi.html#obfuscating-dart-code",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.3 Obfuscating Dart Code",
    "text": "10.3 Obfuscating Dart Code"
  },
  {
    "objectID": "13_proyek_3.html",
    "href": "13_proyek_3.html",
    "title": "14  Proyek Lapor Book",
    "section": "",
    "text": "Proyek Lapor Book"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kursus Flutter",
    "section": "",
    "text": "Pengantar\nIni adalah buku yang membahas tentang Flutter. Susunan original dari buku ini adalah sebagai berikut."
  },
  {
    "objectID": "index.html#flutter-dasar",
    "href": "index.html#flutter-dasar",
    "title": "Kursus Flutter",
    "section": "Flutter Dasar",
    "text": "Flutter Dasar\n\nPengenalan Flutter\n\nApa itu Flutter\nInstalasi Flutter\nMembuat proyek Flutter pertama\n\nDasar Pemrograman Dart\n\nVariabel dan Tipe Data\nStruktur Kontrol\nFungsi dan Kelas\nPenggunaan Pustaka\n\nUser Interface\n\nWidget\nLayout\nStyling\nInput Handling (Stateless & Statefull)\n\nProyek Pertama: Aplikasi Kalkulator\nRouting dan Navigasi\n\nNavigasi antar halaman\nWidget navigator\nMengirim data antar halaman\nState Management\n\nPengujian dan Debugging\n\nDebugging di Flutter\nMenggunakan widget test untuk uji widget\nMenggunakan unit test untuk uji logika\n\nAkses Data Lokal\n\nPenyimpanan dengan SharedPrefence\nPenyimpanan dengan SQLite\n\nKonfigurasi dan pengaturan awal\nCRUD data dengan SQLite\nQuery pencarian database lokal\n\nStudi Kasus\n\nProyek Kedua: Aplikasi Catatan"
  },
  {
    "objectID": "index.html#flutter-client-server",
    "href": "index.html#flutter-client-server",
    "title": "Kursus Flutter",
    "section": "Flutter Client Server",
    "text": "Flutter Client Server\n\nAkses Data Melalui API\n\nKonsep dasar REST API\nMenggunakan package HTTP\nMengambil data dari API\nMenampilkan data pada widget\n\nIntegrasi dengan Firebase/Supabase\n\nPengenalan Firebase/Supabase\nIntegrasi Firebase/Supabase dengan Flutter\nPenggunaan Firestore untuk penyimpanan data\n\nLayanan Berbasis Lokasi\n\nMenggunakan package Location\nMenggunakan widget Geolocator\nMenampilkan openstreetmap API pada aplikasi\n\nPengamanan Aplikasi\n\nPenggunaan protokol jaringan aman dengan HTTPS\nAutentikasi pengguna\nObfuscating Dart code\n\nProyek Ketiga: Lapor Book\n\nNamun akan dikelompokkan menjadi 2 kelompok :\n\nKonsep\nStudi Kasus dan Proyek"
  },
  {
    "objectID": "studi_kasus.html",
    "href": "studi_kasus.html",
    "title": "Studi Kasus dan Proyek",
    "section": "",
    "text": "Studi Kasus dan Proyek :\n\nProyek 1 : Kalkulator\nProyek 2 : Password Vault\nProyek 3 : Lapor Book"
  },
  {
    "objectID": "konsep.html",
    "href": "konsep.html",
    "title": "Konsep",
    "section": "",
    "text": "Learning path :\n\nPengenalan Flutter\nDasar Pemrograman Dart\nAntarmuka Pengguna\nRouting dan Navigasi\nPengujian dan Debugging\nAkses Data Lokal\nAkses Data melalui API\nIntegrasi Dengan BAas\nLayanan Berbasis Lokasi\nPengamanan Aplikasi"
  },
  {
    "objectID": "studi_kasus_1.html",
    "href": "studi_kasus_1.html",
    "title": "11  Studi Kasus 1 : Program Pengelola Data Karyawan",
    "section": "",
    "text": "Tips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 1 dan 2\n\n\nMisalkan kita ingin membuat sebuah program sederhana untuk mengelola data karyawan pada sebuah perusahaan. Kita akan membuat sebuah class Karyawan sebagai superclass, dan dua subclass yaitu KaryawanTetap dan KaryawanKontrak, yang akan mewarisi sifat-sifat dari Karyawan. Kita juga akan menggunakan control flow seperti if-else dan penggunaan fungsi untuk melakukan perhitungan gaji karyawan.\nBerikut adalah implementasi programnya:\nclass Karyawan {\n  String nama;\n  int umur;\n  String alamat;\n\n  Karyawan(this.nama, this.umur, this.alamat);\n\n  double hitungGaji() {\n    return 0;\n  }\n}\n\nclass KaryawanTetap extends Karyawan {\n  double gajiPokok;\n  double tunjangan;\n\n  KaryawanTetap(String nama, \n                int umur, \n                String alamat, \n                this.gajiPokok, \n                this.tunjangan) : \n                super(nama, umur, alamat);\n\n  @override\n  double hitungGaji() {\n    return gajiPokok + tunjangan;\n  }\n}\n\nclass KaryawanKontrak extends Karyawan {\n  int durasiKontrak;\n  double gajiPerBulan;\n\n  KaryawanKontrak(String nama, \n                  int umur, \n                  String alamat, \n                  this.durasiKontrak, \n                  this.gajiPerBulan) : \n                  super(nama, umur, alamat);\n\n  @override\n  double hitungGaji() {\n    return durasiKontrak * gajiPerBulan;\n  }\n}\n\nvoid main() {\n  KaryawanTetap karyawanTetap = KaryawanTetap('John Doe', 28, \n  'Jl. Sudirman No. 123', 5000000, 1000000);\n  KaryawanKontrak karyawanKontrak = KaryawanKontrak('Jane Doe', 25, \n  'Jl. Thamrin No. 456', 12, 3000000);\n\n  if (karyawanTetap.hitungGaji() &gt; karyawanKontrak.hitungGaji()) {\n    print('Gaji ${karyawanTetap.nama} &gt; gaji ${karyawanKontrak.nama}');\n  } else {\n    print('Gaji ${karyawanKontrak.nama} &gt; gaji ${karyawanTetap.nama}');\n  }\n}\nOutput\n\n\n\nOutput Studi Kasus\n\n\n\n\n\n\n\n\nPenjelasan Kode\n\n\n\nMendefinisikan kelas Karyawan dengan properti nama, umur, dan alamat. Kelas ini juga memiliki konstruktor yang menerima tiga parameter untuk menginisialisasi properti-propertinya. Selain itu, kelas ini memiliki metode hitungGaji() yang mengembalikan nilai 0. Metode ini akan digantikan (override) di kelas-kelas turunannya.\nMendefinisikan kelas KaryawanTetap yang merupakan turunan dari kelas Karyawan. Kelas ini memiliki properti tambahan gajiPokok dan tunjangan. Konstruktor kelas ini menerima enam parameter, termasuk dua parameter yang digunakan untuk menginisialisasi properti tambahan. Kelas ini juga menggantikan metode hitungGaji() yang menghitung total gaji dengan menjumlahkan gajiPokok dan tunjangan.\nMendefinisikan kelas KaryawanKontrak yang juga merupakan turunan dari kelas Karyawan. Kelas ini memiliki properti tambahan durasiKontrak dan gajiPerBulan. Konstruktor kelas ini menerima enam parameter, termasuk dua parameter yang digunakan untuk menginisialisasi properti tambahan. Kelas ini juga menggantikan metode hitungGaji() yang menghitung total gaji dengan mengalikan durasiKontrak dan gajiPerBulan.\nDi dalam fungsi main(), program membuat objek karyawanTetap dari kelas KaryawanTetap dan objek karyawanKontrak dari kelas KaryawanKontrak. Setiap objek diinisialisasi dengan nilai-nilai yang sesuai.\nProgram membandingkan gaji yang diterima oleh karyawanTetap dan karyawanKontrak menggunakan metode hitungGaji(). Jika gaji yang diterima oleh karyawanTetap lebih besar daripada karyawanKontrak, program mencetak pesan “${karyawanTetap.nama} mendapatkan gaji lebih besar daripada \\({karyawanKontrak.nama}\". Jika tidak, program mencetak pesan \"\\){karyawanKontrak.nama} mendapatkan gaji lebih besar daripada ${karyawanTetap.nama}”.\nDengan demikian, program ini mengilustrasikan penggunaan pewarisan dan overriding dalam konteks penggajian karyawan. Output yang dihasilkan akan mencetak perbandingan gaji antara karyawan tetap dan karyawan kontrak berdasarkan perhitungan gaji yang dilakukan pada masing-masing kelas."
  },
  {
    "objectID": "studi_kasus_dan_proyek.html",
    "href": "studi_kasus_dan_proyek.html",
    "title": "Studi Kasus dan Proyek",
    "section": "",
    "text": "Studi Kasus dan Proyek :\n\nStudi Kasus 1\nStudi Kasus 2\nStudi Kasus 3\nProyek 1 : Kalkulator\nProyek 2 : Password Vault\nProyek 3 : Lapor Book"
  },
  {
    "objectID": "studi_kasus_2.html",
    "href": "studi_kasus_2.html",
    "title": "12  Studi Kasus 2 : List Kuliner",
    "section": "",
    "text": "Tips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 1 hingga 3\n\n\nDalam studi kasus ini, kita akan membuat sebuah aplikasi satu halaman yang menampilkan daftar makanan dalam bentuk daftar yang terlihat di layar. Berikut adalah tampilan aplikasi yang dihasilkan dari studi kasus ini.\n\n\n\nHasil\n\n\nTahap-tahap pembuatan studi kasus adalah sebagai berikut:\n\nBuatlah projek flutter baru.\nBuka file main.dart dan hapus kode template yang ada di dalamnya, kemudian gantikan dengan kode berikut ini:\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MainApp());\n}\n\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n\n\n\nTampilan langkah ke 2\n\n\n\nBuatlah sebuah file baru dengan nama “home_page.dart” di dalam direktori “lib”. Pada file ini, tampilan utama dari aplikasi akan disimpan, sehingga membuat kode menjadi lebih mudah dibaca dan dikelola.\n\n\n\n\nTampilan langkah ke 3\n\n\n\nSelanjutnya buat sebuah class baru bernama HomePage pada file home_page.dart dengan tipe StatelessWidget.\n\nimport 'package:flutter/material.dart';\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\n\nSetelah itu kembali ke dalam file “main.dart”, ubah kode pada bagian “body” menjadi “HomePage()”. Dengan melakukan perubahan tersebut, tampilan di emulator akan mengikuti konten yang ada di halaman utama (HomePage). Selain itu, tambahkan judul pada aplikasi dengan menggunakan komponen AppBar.\n\nScaffold(\n    appBar: AppBar(\n        title: Text(\"List Kuliner\"),\n    ),\n    body: HomePage(),\n),\n\n\n\nLangkah ke 5\n\n\n\nBuka file “home_page.dart” dan gantilah placeholder dengan widget ListView. Selanjutnya, tambahkan widget Container di dalam ListView tersebut. Sesuaikan gaya tampilan (styling) pada ListView dan Container sesuai dengan preferensi Anda. Tampilan ini akan menjadi dasar dari aplikasi studi kasus yang sedang dibangun.\n\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        Container(\n            margin: EdgeInsets.symmetric(vertical: 5),\n            decoration: BoxDecoration(\n                color: Colors.blueAccent,\n                borderRadius: \n                BorderRadius.all(Radius.circular(10)),\n                boxShadow: [\n                BoxShadow(\n                    color: Colors.black,\n                    offset: Offset(3.0, 5.0),\n                    blurRadius: 2.0,\n                ),\n                ],\n            ),\n            height: 100,\n            padding: EdgeInsets.symmetric(\n                horizontal: 10,\n                vertical: 15,\n            ),\n        ),\n    ],\n),\n\n\n\nLangkah ke 6\n\n\n\nBuatlah beberapa widget di dalam sebuah container, menggunakan widget Column atau Row, untuk mengubah tampilan container menjadi sebuah kartu (card) yang dapat digunakan untuk menyimpan data makanan. Sesuaikan juga gaya (styling) seperti margin, padding, dan warna.\n\nContainer(\n    //...\n    \n    child: Row(\n        crossAxisAlignment: CrossAxisAlignment.center,\n        children: [\n        Container(\n            width: 75,\n            height: 75,\n            color: Colors.black,\n        ),\n        SizedBox(\n            width: 10,\n        ),\n        Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n            Text(\n                \"Title\",\n                style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n                ),\n            ),\n            Text(\n                \"Sub Title\",\n                style: TextStyle(\n                fontWeight: FontWeight.w500,\n                ),\n            ),\n            ],\n        )\n        ],\n    ),\n),\n\n\n\nLangkah ke 7\n\n\n\nUntuk mempermudah pembacaan kode, buatlah sebuah file baru bernama “list_item.dart”. Di dalam file tersebut, buatlah sebuah class baru dengan nama “ListItem” yang merupakan turunan dari StatelessWidget. Kemudian, pindahkan seluruh kode yang berada di dalam container ke dalam class ListItem tersebut.\n\n\n\n\nLangkah ke 8\n\n\nimport 'package:flutter/material.dart';\n\nclass ListItem extends StatelessWidget {\n  const ListItem({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      //...\n    );\n  }\n}\nPastikan untuk menyertakan Widget ListItem() di dalam ListView pada file home_page.dart agar kontainer dapat ditampilkan dengan benar.\nListView(\n    padding: EdgeInsets.all(10),\n    children: [\n        ListItem(),\n    ],\n),\n\nSamapai pada tahap ke 8 tampilan statis dari aplikasi telah selesai. Langkah selanjutnya adalah membuat data dan menampilkannya dalam aplikasi.\n\nPertama-tama Anda perlu membuat file baru bernama makanan.dart untuk menyimpan kelas makanan beserta atribut-atributnya.\n\n\n\nLangkah ke 9\n\n\nclass Makanan {\n  final String nama;\n  final String deskripsi;\n  final String gambar;\n\n  Makanan({\n    required this.nama, \n    required this.deskripsi, \n    required this.gambar,\n  });\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nKode tersebut adalah definisi dari sebuah kelas (class) yang disebut “Makanan”. Kelas ini memiliki tiga properti (properties) yaitu “nama”, “deskripsi”, dan “gambar”, yang semuanya memiliki tipe data String. Properti-properti tersebut ditandai dengan kata kunci “final” yang menunjukkan bahwa setelah objek Makanan dibuat, nilai-nilai properti tersebut tidak dapat diubah.\nSelain itu, kelas Makanan juga memiliki sebuah constructor dengan sintaksis yang sedikit berbeda. Constructor ini menggunakan named parameters (parameter yang diberi nama) dengan menggunakan kurung kurawal {}. Constructor ini memiliki tiga parameter yaitu “nama”, “deskripsi”, dan “gambar”, dan ketiga parameter tersebut ditandai dengan kata kunci “required” yang menunjukkan bahwa nilai-nilai parameter tersebut harus disediakan saat membuat objek Makanan.\n\n\n\nSebelum membuat daftar makanan yang akan ditampilkan, langkah pertama adalah mengunduh gambar-gambar yang akan digunakan. Untuk itu, buatlah folder khusus bernama “assets” di dalam proyek Anda dan simpan gambar-gambar tersebut di dalam folder tersebut.\n\n\n\n\nLangkah ke 10\n\n\nSelanjutnya, Anda perlu menambahkan folder “assets” pada file pubspec.yaml agar gambar yang terdapat di dalamnya dapat diakses oleh aplikasi.\n\n\n\nLangkah ke 10\n\n\n\nBuatlah sebuah file bernama “makanan.dart” yang berisi sebuah list array untuk menyimpan data makanan yang akan di-load dalam aplikasi.\n\nList&lt;Makanan&gt; list_makanan = [\n  Makanan(\n    nama: 'Bubur',\n    deskripsi: 'Nasi Lembek',\n    gambar: 'assets/bubur.jpg',\n  ),\n  Makanan(\n    nama: 'Soto',\n    deskripsi: 'Makanan berkuah',\n    gambar: 'assets/soto.jpg',\n  ),\n  Makanan(\n    nama: 'Pecel',\n    deskripsi: 'Sayuran dengan bumbu kacang',\n    gambar: 'assets/pecel.jpg',\n  ),\n];\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi List: List&lt;Makanan&gt; list_makanan = [...]\n\nList&lt;Makanan&gt; mengindikasikan bahwa list_makanan adalah sebuah List yang berisi objek-objek bertipe Makanan.\n[] menandakan bahwa List tersebut akan diinisialisasi dengan sejumlah elemen objek Makanan.\n\nInisialisasi elemen-elemen List:\n\nSetiap elemen dalam List adalah sebuah objek Makanan yang diinisialisasi dengan menggunakan sintaksis Makanan(...).\nObjek Makanan memiliki tiga atribut: nama, deskripsi, dan gambar. Nilai-nilai atribut tersebut diberikan melalui parameter nama-nama yang sesuai dalam sintaksis inisialisasi objek.\n\n\n\n\n\nSilakan tambahkan atribut yang sesuai dalam ListItem() sesuai dengan atribut yang ada dalam kelas makanan. Gantikan widget container yang berada di dalam row dengan Image.asset(). Kemudian, ubah data dalam teks agar menggunakan atribut yang telah ditambahkan sebelumnya.\n\nfinal String nama;\nfinal String deskripsi;\nfinal String gambar;\nconst ListItem(\n    {super.key,\n    required this.nama,\n    required this.deskripsi,\n    required this.gambar,\n    });\nRow(\n    crossAxisAlignment: CrossAxisAlignment.center,\n    children: [\n        // widget untuk menampilkan gambar lokal\n        Image.asset(\n            gambar,\n            height: 75,\n            width: 75,\n        ),\n        SizedBox(\n        width: 10,\n        ),\n        Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n            Text(\n            nama,\n            style: TextStyle(\n                fontSize: 30,\n                fontWeight: FontWeight.bold,\n            ),\n            ),\n            Text(\n            deskripsi,\n            style: TextStyle(\n                fontWeight: FontWeight.w500,\n            ),\n            ),\n        ],\n        )\n    ],\n),\n\nSilakan buka kembali file home_page.dart dan ubah bagian yang menampilkan ListView menjadi menggunakan ListView.builder.\n\nListView.builder(\n    // mengatur panjang / jumlah item dalam list\n    itemCount: list_makanan.length,\n    padding: EdgeInsets.all(10),\n    itemBuilder: (context, index) {\n        return ListItem(\n        nama: list_makanan[index].nama,\n        deskripsi: list_makanan[index].deskripsi,\n        gambar: list_makanan[index].gambar,\n        );\n    },\n),\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nitemCount: list_makanan.length,: Ini mengatur jumlah item dalam daftar, yang diambil dari panjang (length) dari daftar list_makanan. Jadi, jumlah item dalam daftar akan sesuai dengan jumlah elemen dalam list_makanan.\nitemBuilder: (context, index) { ... },: Ini adalah fungsi yang digunakan untuk membangun tampilan item dalam daftar. Fungsi ini akan dipanggil secara berulang untuk setiap item dalam daftar.\n\ncontext: Objek context yang memberikan informasi tentang lingkungan tampilan saat ini.\nindex: Indeks item saat ini dalam daftar.\n\nreturn ListItem(...);: Di dalam itemBuilder, setiap item dalam daftar dibangun dengan menggunakan widget ListItem. Nilai-nilai yang diperlukan untuk membangun ListItem diambil dari list_makanan dengan menggunakan index saat ini. Ini berarti setiap item dalam daftar akan memiliki nama, deskripsi, dan gambar yang sesuai dengan elemen dalam list_makanan\n\n\n\nSetelah melalui beberapa tahapan, aplikasi studi kasus akhirnya selesai dan siap digunakan. Anda memiliki kebebasan untuk menambahkan data baru atau mengubah tampilan sesuai dengan preferensi Anda."
  },
  {
    "objectID": "studi_kasus_3.html",
    "href": "studi_kasus_3.html",
    "title": "13  Studi Kasus 3 : Detail Kuliner",
    "section": "",
    "text": "Tips\n\n\n\nPada studi kasus ini disarankan sudah membaca Bab 1 hingga 4\n\n\nPada studi kasus kali ini kita akan melanjutkan studi kasus 2. Jadi silahkan ikuti dulu studi kasus 2 lalu lanjut ke studi kasus ini. Hasil dari studi ini adalah aplikasi dengan dua halaman, yaitu halaman list makanan dan halaman detail makanan.\nUntuk membuat aplikasi nya dapat berpindah ke halaman selanjutnya pertama-tama kita harus membuat container / setiap item dalam list di berinteraksi dengan disentuh. Hal ini bisa dilakukan dengan cara membungkus Container dengan InkWell atau GestureDetector. Pada studi kasus ini kita akan menggunakan InkWell. Silahkan buka file list_item.dart dan tambahkan kode berikut.\n@override\nWidget build(BuildContext context) {\nreturn InkWell(\n        onTap: () {},\n        child: Container(\n        // ....\n        ),\n    );\n}\nSetelah dibungkus dengan InkWell item dalam list dapat di berinteraksi dengan sentuhan. Selanjutnya adalah menyiapkan halaman baru yang akan dibuka ketika item dalam list di sentuh. Buat file baru dengan nama detail_page.dart dan buat stateless widget didalamnya.\n\n\n\nLangkah 2\n\n\nclass DetailPage extends StatelessWidget {\n  const DetailPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Placeholder();\n  }\n}\nSelanjutnya silahkan desain halaman baru sesuai dengan preferensi. Berikut adalah contoh desain untuk halaman detail.\nWidget build(BuildContext context) {\nreturn Scaffold(\n    body: Column(\n    crossAxisAlignment: CrossAxisAlignment.start,\n    children: [\n        Image.asset(\n        'assets/pecel.jpg',\n        scale: 0.5,\n        ),\n        Container(\n        margin: EdgeInsets.all(10),\n        padding: EdgeInsets.all(5),\n        width: double.infinity,\n        decoration: BoxDecoration(\n            border: Border.all(\n            width: 2,\n            ),\n        ),\n        child: Column(\n            children: [\n            Text(\n                \"Pecel\",\n                style: TextStyle(\n                fontSize: 40,\n                fontWeight: FontWeight.bold,\n                ),\n            ),\n            Divider(\n                thickness: 4,\n                color: Colors.black87,\n            ),\n            Text(\n                \"deskripsi\",\n                style: TextStyle(\n                fontSize: 15,\n                fontStyle: FontStyle.italic,\n                ),\n            ),\n            ],\n        ),\n        )\n    ],\n    ),\n);\n}\n\n\n\nContoh Desain\n\n\nSetelah desainnya jadi halaman detail masih belum bisa diakses. Untuk bisa diakses buka file list_item.dart dan tambahkan Navigator pada onTap.\nInkWell(\n    onTap: () {\n    Navigator.push(\n        context, MaterialPageRoute(builder: (context) =&gt; DetailPage()));\n    },\n),\nSekarang setiap item dalam list dapat membuka halaman detail, namun data yang ditampilkan dalam halaman detail masih statis. Maka dari itu kita perlu menambahkan beberapa kode pada DetailPage agar data yang ditampikan menjadi dinamis. Buka kembali detail_page.dart dan tambahkan kode berikut.\nclass DetailPage extends StatelessWidget {\n  final String nama;\n  final String gambar;\n  final String deskripsi;\n  const DetailPage(\n      {super.key,\n      required this.nama,\n      required this.gambar,\n      required this.deskripsi});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        // ...\n        children: [\n          Image.asset(\n            gambar,\n            // ...\n          ),\n          Container(\n            // ...\n            child: Column(\n              children: [\n                Text(\n                  nama,\n                  // ...\n                ),\n                // ...\n                Text(\n                  deskripsi,\n                  // ...\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\nLalu kembali pada file list_item.dart dan sesuaikan sesuaikan Navigator pada onTap\nInkWell(\n    onTap: () {\n    Navigator.push(\n        context,\n        MaterialPageRoute(\n        builder: (context) =&gt; DetailPage(\n            nama: nama,\n            gambar: gambar,\n            deskripsi: deskripsi,\n        ),\n        ),\n    );\n    },\n),\nSetelah melalui beberapa tahapan maka studi kasus ini pun selesai. Berikut gambaran akhir halaman detail.\n\n\n\nHasil"
  },
  {
    "objectID": "4_routing_navigasi.html#widget-navigator",
    "href": "4_routing_navigasi.html#widget-navigator",
    "title": "4  Routing dan Navigasi",
    "section": "4.1 Widget Navigator",
    "text": "4.1 Widget Navigator\nFlutter menyediakan kelas Navigator yang bertanggung jawab untuk mengelola tumpukan tampilan. Setiap kali pengguna berpindah ke tampilan baru, Navigator menambahkannya ke tumpukan dan menampilkan tampilan tersebut di layar. Ketika pengguna menekan tombol “kembali” atau melakukan tindakan kembali lainnya, Navigator akan menghapus tampilan teratas dari tumpukan dan menampilkan tampilan sebelumnya.\nAda beberapa jenis navigator yang dapat digunakan dalam Flutter, di antaranya:\n\n4.1.1 MaterialPageRoute\nMaterialPageRoute: Ini adalah jenis navigator yang umum digunakan dalam aplikasi Flutter yang mengikuti desain material dari Flutter. MaterialPageRoute menampilkan transisi animasi bawaan saat tampilan baru ditampilkan atau ditutup.\n\n\n4.1.2 CupertinoPageRoute\nCupertinoPageRoute: Ini adalah jenis navigator yang mengikuti desain iOS dengan menggunakan transisi animasi khas iOS. Jika Anda ingin aplikasi Anda memiliki tampilan yang mirip dengan aplikasi iOS, Anda dapat menggunakan CupertinoPageRoute."
  },
  {
    "objectID": "4_routing_navigasi.html#navigasi-antar-halaman",
    "href": "4_routing_navigasi.html#navigasi-antar-halaman",
    "title": "4  Routing dan Navigasi",
    "section": "4.2 Navigasi Antar Halaman",
    "text": "4.2 Navigasi Antar Halaman\nAda beberapa metode navigasi yang umum digunakan dalam Flutter:\n\n4.2.1 push\npush: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru. Contoh kode navigator membawa pengguna dari halaman pertama ke halaman kedua.\nElevatedButton(\n    child: const Text('Go to Second Screen'),\n    onPressed: () {\n        Navigator.push(context,\n            MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),\n\n\n4.2.2 pop\npop: Metode ini menghapus rute saat ini dari tumpukan dan membawa pengguna kembali ke halaman sebelumnya. Contoh navigator menghapus halaman kedua dan membawa pengguna kembali ke halaman pertama.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pop(context);\n    },\n),\n\n\n4.2.3 pushReplacement\npushReplacement: Metode ini mengganti rute saat ini dengan rute baru. Ini berguna ketika Anda ingin mengganti halaman tetapi tidak ingin menjaga halaman sebelumnya di tumpukan. Contoh navigator menggantikan halaman saat ini dengan halaman baru.\nElevatedButton(\n    child: const Text('Back to First Screen'),\n    onPressed: () {\n        Navigator.pushReplacement(context, MaterialPageRoute(builder: (context) =&gt; MySecondPage()));\n    },\n),"
  },
  {
    "objectID": "4_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "href": "4_routing_navigasi.html#navigasi-antar-halaman-dengan-nama-route",
    "title": "4  Routing dan Navigasi",
    "section": "4.3 Navigasi antar halaman dengan nama route",
    "text": "4.3 Navigasi antar halaman dengan nama route\nAda beberapa metode navigasi dengan nama route yang digunakan dalam Flutter:\n\n4.3.1 pushNamed\npushNamed: Metode ini menambahkan rute baru ke tumpukan dan membawa pengguna ke halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.pushNamed() di dalam Flutter untuk melakukan navigasi dengan nama routes:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk melakukan navigasi ke halaman dengan nama route, gunakan method Navigator.pushNamed() dan berikan nama route yang ingin dituju:\nNavigator.pushNamed(context, '/detail');\n\n\n4.3.2 popAndPushNamed\npopAndPushNamed: Metode ini digunakan untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route.\nBerikut adalah contoh penggunaan Navigator.popAndPushNamed() di dalam Flutter untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route:\nPertama, tentukan nama routes di dalam MaterialApp:\nMaterialApp(\n  title: 'MyApp',\n  initialRoute: '/',\n  routes: {\n    '/': (context) =&gt; HomePage(),\n    '/detail': (context) =&gt; DetailPage(),\n  },\n);\nKemudian, untuk menghapus halaman saat ini dari tumpukan dan menambahkan halaman baru dengan nama route, gunakan method Navigator.popAndPushNamed() dan berikan nama route yang ingin dituju:\nNavigator.popAndPushNamed(context, '/result');"
  },
  {
    "objectID": "4_routing_navigasi.html#berbagi-data-antar-halaman",
    "href": "4_routing_navigasi.html#berbagi-data-antar-halaman",
    "title": "4  Routing dan Navigasi",
    "section": "4.4 Berbagi Data Antar Halaman",
    "text": "4.4 Berbagi Data Antar Halaman\nDalam Flutter, terdapat beberapa cara untuk berbagi data antara halaman atau layar dalam aplikasi:\n\n4.4.1 Menggunakan Konstruktor\nMenggunakan Konstruktor: Mengirim data menggunakan konstruktor dilakukan dengan cara menginisialisasi data yang ingin dikirim pada konstruktor halaman yang ingin dituju.\n// Halaman Sumber\nNavigator.push(\n    context,\n    MaterialPageRoute(\n    builder: (context) =&gt; HalamanTujuan(\n        data: dataYangDibagikan,\n        ),\n    ),\n);\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    final String data;\n\n    HalamanTujuan({required this.data});\n\n    // ...\n}\n\n\n4.4.2 Menggunakan ModalRoute\nMenggunakan ModalRoute: Untuk mengambil data kembali dari halaman tujuan ke halaman sumber setelah halaman tujuan ditutup, dapat menggunakan ModalRoute dalam kombinasi dengan metode pop.\n// Halaman Sumber\nfinal data = await Navigator.push(\n    context,\n    MaterialPageRoute(builder: (context) =&gt; HalamanTujuan()),\n);\n// Proses data yang dikembalikan dari Halaman Tujuan\n\n// Halaman Tujuan\nclass HalamanTujuan extends StatelessWidget {\n    // ...\n    // Pada saat ingin mengirimkan data kembali ke halaman sumber\n    Navigator.pop(context, dataYangDikirimkanKembali);\n    // ...\n}\n\n\n4.4.3 Menggunakan State Management\nMenggunakan State Management: Jika data yang perlu dibagikan di seluruh aplikasi berjumlah banyak, dapat menggunakan paket state management seperti provider, riverpod, maupun bloc untuk mengelola state aplikasi secara global."
  },
  {
    "objectID": "4_routing_navigasi.html#state-management",
    "href": "4_routing_navigasi.html#state-management",
    "title": "4  Routing dan Navigasi",
    "section": "4.5 State Management",
    "text": "4.5 State Management\nSeperti yang sudah dijelaskan sebelumnya jika memiliki data yang banyak keberadaan state management menjadi diperlukan. Ada banyak jenis state management namun pada dasarnya mereka semua sama yaitu untuk membantu perpindahan data dalam flutter.\nPada modul ini state management yang akan digunakan merupakan flutter_riverpod. Flutter Riverpod merupakan pustaka dalam Flutter yang digunakan untuk manajemen state dan dependency injection. Riverpod didasarkan pada konsep “provider” dan memberikan solusi yang lebih sederhana dan fleksibel untuk manajemen state dibandingkan dengan paket Flutter lainnya seperti Provider atau GetX.\nUntuk menggunakan flutter_riverpod terlebih dahulu tambahkan pustakanya didalam pubspec.yaml lalu ketik perintah flutter pub get di terminal atau dengan menggunakan perintah flutter pub add flutter_riverpod. Lalu setelah itu deklarasikan scope dari provider dengan cara sebagai berikut :\nvoid main() {\n    runApp(const ProviderScope(child: MainApp()));\n}\nPaket flutter_provider menyediakan berbagai macam provider yang digunakan untuk manajemen state dan dependency injection dalam aplikasi Flutter. Berikut adalah provider-provider yang umum digunakan dalam flutter_provider:\n\nProvider: Provider ini digunakan untuk menyediakan objek tanpa adanya state yang dapat berubah. Berguna untuk menyediakan ketergantungan yang tidak memerlukan pembaruan atau perubahan state.\nStateProvider: Provider ini digunakan untuk menyediakan objek yang nilainya dapat dimodifikasi dari luar. Berguna dalam kondisi sederhana seperti melakukan fiter atau memberikan data yang bisa diakses dan diperbarui dari berbagai halaman.\nFutureProvider: Provider ini digunakan untuk mengelola hasil dari Future. Ini memungkinkan Anda untuk melakukan pemrosesan asinkron dan mengubah UI ketika future selesai atau mengalami perubahan.\nStateNotifierProvider: Provider ini merupakan provider khusus yang harus digunakan bersama dengan state notifier. State notifer merupakan sebuah kelas yang menyimpan satu tipe data untuk dan dapat diamati setiap aktvitasnya oleh StateNotifierProvider. Provider beserta kelas tersebut dapat digunakan untuk memanipulasi state tingkat lanjut, yang akan sulit direpresentasikan dengan provider yang lebih sederhana seperti [Provider] atau [FutureProvider]."
  },
  {
    "objectID": "5_pengujian_debugging.html#debugging-di-flutter",
    "href": "5_pengujian_debugging.html#debugging-di-flutter",
    "title": "5  Pengujian dan Debugging",
    "section": "5.1 Debugging di Flutter",
    "text": "5.1 Debugging di Flutter\nProses debugging dalam Flutter melibatkan pencarian dan perbaikan kesalahan atau bug yang ada dalam aplikasi. Ada beberapa metode yang dapat digunakan dalam proses debugging pada Flutter:\n\n5.1.1 Print\nMencetak pesan kesalahan pada terminal menggunakan pernyataan ‘print’: Saat aplikasi mengalami kegagalan atau kesalahan, pernyataan “print” dapat ditambahkan di berbagai bagian kode untuk mencetak nilai variabel atau pesan di konsol. Pencetakan pesan kesalahan ini dapat memberikan petunjuk tentang lokasi masalah, seperti baris kode yang menyebabkan kesalahan tersebut.\nContoh penggunaan pernyataan ‘print’:\nprint('Nilai dari variabel x: $x');\n\n\n5.1.2 Breakpoint\nBreakpoint: Breakpoint dapat ditempatkan dalam kode untuk memberhentikan eksekusi program sehingga nilai variabel, status aplikasi, dan alur eksekusi dapat diperiksa.\n\n\n5.1.3 Debugger\nMenjalankan Aplikasi dalam Mode Debug atau menggunakan debugger: Aplikasi dapat dijalankan dalam mode debug dengan membuka terminal dan menjalankan perintah “flutter run –debug”. Debugger adalah alat yang disediakan dalam Flutter yang memungkinkan untuk melihat kode secara rinci dan melakukan pemecahan masalah dengan lebih efisien. Debugger dapat membantu melacak nilai variabel, melihat tumpukan panggilan (stack trace), dan memperbaiki bug secara interaktif.\n\n\n5.1.4 Logging\nLogging: Logging merupakan proses pencatatan aktivitas di dalam aplikasi. Pernyataan logging dapat membantu dalam memahami alur eksekusi dan memeriksa nilai variabel.\nContoh penggunaan logging:\nimport 'package:logger/logger.dart';\n\nvar logger = Logger();\n\nlogger.d('Pesan debug');\nlogger.i('Pesan info');\nlogger.w('Pesan peringatan');\nlogger.e('Pesan error');\nlogger.f('Pesan fatal');\n\n\n5.1.5 Inspector Flutter\nInspector Flutter: Flutter menyediakan Inspector, yaitu alat visual yang membantu menganalisis widget dan properti dalam aplikasi. Inspector dapat membantu dalam memahami struktur widget dan melacak masalah dengan widget tertentu. Inspector dapat diaktifkan dengan menekan tombol “Toggle Inspector” pada toolbar dalam mode debug.\n\n\n5.1.6 Exception Handling\nException Handling: Exception Handling adalah cara untuk menangani kesalahan atau pengecualian yang terjadi selama eksekusi kode. Dengan menangani pengecualian, crash pada aplikasi dapat dihindari.\nContoh penggunaan Exception Handling:\ntry {\n  // beberapa kode yang dapat menimbulkan pengecualian\n} catch (e) {\n  // menangani pengecualian\n}\n\n\n5.1.7 Dokumentasi dan Komunitas\nMembaca Dokumentasi dan Menggunakan Komunitas: Dokumentasi resmi Flutter menyediakan informasi yang lengkap dan bermanfaat. Jika Anda mengalami kesulitan dalam proses debugging, Anda dapat merujuk pada dokumentasi Flutter yang dapat memberikan informasi yang berguna. Selain itu, komunitas pengembang Flutter juga merupakan sumber daya yang berharga, di mana Anda dapat mencari bantuan dan berdiskusi dengan pengembang lainnya."
  },
  {
    "objectID": "5_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "href": "5_pengujian_debugging.html#menggunakan-unit-test-untuk-uji-logika",
    "title": "5  Pengujian dan Debugging",
    "section": "5.2 Menggunakan Unit Test untuk Uji Logika",
    "text": "5.2 Menggunakan Unit Test untuk Uji Logika\nUnit testing adalah proses pengujian perangkat lunak yang dilakukan pada tingkat terkecil, yaitu pada unit-unit kode yang independen dan dapat diuji secara terpisah. Dalam konteks Flutter, unit testing digunakan untuk menguji fungsi-fungsi individual dalam aplikasi Flutter. Tujuan dari unit testing adalah untuk memastikan bahwa setiap unit kode berfungsi sesuai dengan harapan, dan untuk menghindari bug atau kesalahan yang mungkin terjadi pada aplikasi.\nBerikut adalah langkah-langkah umum untuk melakukan unit testing pada Flutter:\nLangkah 1: Menyiapkan Proyek - Buat proyek Flutter baru atau buka proyek Flutter yang sudah ada. - Impor package “flutter_test” ke dependencies dalam file pubspec.yaml dan jalankan perintah ‘flutter pub get’ untuk menginstalnya.\nLangkah 2: Membuat File Test - Buat file baru dengan ekstensi .dart di dalam direktori test dengan nama yang diakhiri dengan “_test.dart” untuk menyimpan tes unit. - Impor paket flutter_test dan file yang ingin Anda uji, contohnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:nama_aplikasi/file_yang_di_uji.dart';\nLangkah 3: Menulis Tes Unit Buat test case dengan menambahkan fungsi yang menguji fungsi atau metode tertentu. Contoh:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/utils.dart';\n\nvoid main() {\n  test('Test add function', () {\n    expect(add(1, 2), equals(3));\n    expect(add(0, 0), equals(0));\n    expect(add(-1, 1), equals(0));\n  });\n\n  test('Test subtract function', () {\n    expect(subtract(3, 1), equals(2));\n    expect(subtract(0, 0), equals(0));\n    expect(subtract(-1, 1), equals(-2));\n  });\n}\nLangkah 4: Menjalankan Tes Unit - Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus unit testing."
  },
  {
    "objectID": "5_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "href": "5_pengujian_debugging.html#menggunakan-widget-test-untuk-uji-widget",
    "title": "5  Pengujian dan Debugging",
    "section": "5.3 Menggunakan Widget Test untuk Uji Widget",
    "text": "5.3 Menggunakan Widget Test untuk Uji Widget\nWidget testing adalah metode pengujian yang digunakan untuk memastikan bahwa widget-widget dalam aplikasi Flutter berfungsi seperti yang diharapkan. Tujuan dari widget testing adalah untuk memastikan bahwa widget berfungsi dengan benar dan sesuai dengan harapan pada saat runtime.\nBerikut adalah langkah-langkah dasar dalam melakukan widget testing pada Flutter:\n\nMenyiapkan Dependensi: Pastikan bahwa dependensi yang diperlukan dalam file pubspec.yaml proyek Flutter sudah tersedia. Jika belum ada, dependensi dapat ditambahkan sebagai berikut:\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\nMembuat File Test: Buat file test baru dengan ekstensi .dart dan nama yang diakhiri dengan “_test.dart” di direktori “test” pada proyek Flutter dalam direktori test proyek. Misalnya, widget_test.dart.\nMengimpor Paket dan Widget yang Dibutuhkan: Dalam file widget_test.dart, impor paket-paket dan widget-widget yang akan diuji. Misalnya:\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:flutter/material.dart';\nimport 'package:my_app/my_widget.dart';\nMenulis Test Case: Buat test case dengan menambahkan fungsi yang menguji widget tertentu. Contoh:\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('Test MyButton widget', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    final button = find.byType(MyButton);\n    expect(button, findsOneWidget);\n\n    await tester.tap(button);\n    await tester.pump();\n\n    final text = find.text('Button clicked');\n    expect(text, findsOneWidget);\n  });\n}\n\nMenjalankan Test: Jalankan test case dengan menekan tombol “Run” di samping nama test case atau dengan menjalankan perintah “flutter test” di terminal. Jika semua test case berhasil berjalan, maka aplikasi dianggap berhasil lulus widget testing."
  },
  {
    "objectID": "6_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "href": "6_akses_data_lokal.html#penyimpanan-dengan-shared-preferences",
    "title": "6  Akses Data Lokal",
    "section": "6.1 Penyimpanan dengan Shared Preferences",
    "text": "6.1 Penyimpanan dengan Shared Preferences\nShared Preferences adalah sebuah mekanisme penyimpanan data sederhana yang digunakan untuk menyimpan dan mengambil nilai-nilai (data) secara persisten di aplikasi. Hal ini berarti data yang disimpan dengan menggunakan Shared Preferences akan tetap ada meskipun aplikasi ditutup dan dijalankan kembali.\nDalam penggunaan sehari-hari, Shared Preferences sering digunakan untuk menyimpan preferensi pengguna seperti pengaturan, preferensi tema, atau data lain yang perlu dipertahankan antar-sesi aplikasi.\nBerikut ini adalah langkah-langkah sederhana untuk menggunakan Shared Preferences dalam Flutter:\n\nPertama, tambahkan dependensi SharedPreferences ke file pubspec.yaml di proyek Flutter Anda:\n\ndependencies:\n  shared_preferences: ^x.x.x\n\nKemudian, impor package shared_preferences:\n\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSelanjutnya, Anda dapat menggunakan Shared Preferences untuk menyimpan dan mengambil data. Misalnya, untuk menyimpan sebuah nilai (contohnya, preferensi pengguna), Anda dapat melakukannya sebagai berikut:\n\n// Membuat sebuah instance dari SharedPreferences\nSharedPreferences prefs = await SharedPreferences.getInstance();\n\n// Menyimpan nilai dengan menggunakan key 'nama'\nprefs.setString('nama', 'udinus');\n\nUntuk mengambil nilai yang telah disimpan sebelumnya, Anda dapat menggunakan kode berikut:\n\n// Mengambil nilai dengan menggunakan key 'nama'\nString? nama = prefs.getString('nama');\nDalam contoh di atas, variabel nama akan berisi nilai yang telah disimpan sebelumnya (‘udinus’) jika ada, atau null jika tidak ada nilai yang disimpan dengan key ‘nama’."
  },
  {
    "objectID": "6_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "href": "6_akses_data_lokal.html#penyimpanan-dengan-sqlite",
    "title": "6  Akses Data Lokal",
    "section": "6.2 Penyimpanan dengan Sqlite",
    "text": "6.2 Penyimpanan dengan Sqlite\nSQLite adalah sebuah database relasional ringan yang sering digunakan dalam pengembangan aplikasi mobile, termasuk Flutter. SQLite dapat bekerja dengan database yang disimpan secara lokal di perangkat pengguna.\nSQLite pada Flutter memungkinkan Anda menyimpan, mengelola, dan mengakses data secara efisien. Dalam konteks Flutter, Anda dapat menggunakan paket sqflite untuk berinteraksi dengan SQLite.\n\n6.2.1 Konfigurasi dan Pengaturan Awal\nUntuk menghubungkan aplikasi dengan sqlite diperlukan beberapa konfigurasi. Berikut adalah langkah langkah konfigurasi agar dapat terhubung dengan sqlite:\n\nMengimpor dependensi\n\nimpor dependensi sqflite, path, dan path_provider pada file pubspec.yaml:\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nJalankan perintah flutter pub get untuk mengunduh dependensi tersebut. Untuk menghubungkan aplikasi dengan sqlite sebenernya hanya memerlukan dependesi sqflite. Namun sebagai pembantu dalam membuat database diperlukan dua dependesi pembantu yaitu path, dan path_provider.\n\nMembuat Database Helper\n\nSetelah ditambahkan dependeciesnya aplikasi tidak langsung dapat mengakses sqlite. Terlebih dahulu dibuat sebuah class khusus untuk menghubungkan aplikasi dengan sqlite. Dalam class tersebut database akan di inisialisasi ketika belum dibuat.\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._();\n  static Database? _database;\n\n  DatabaseHelper._();\n\n  Future&lt;Database&gt; get database async {\n    if (_database != null) return _database!;\n    _database = await _initDatabase();\n    return _database!;\n  }\n\n  Future&lt;Database&gt; _initDatabase() async {\n    Directory directory = await getApplicationDocumentsDirectory();\n    String path = join(\n        directory.path, \n        'my_database.db',\n    );\n    return await openDatabase(\n        path, \n        version: 1, \n        onCreate: _createDb,\n    );\n  }\n\n  Future&lt;void&gt; _createDb(Database db, int version) async {\n    await db.execute('''\n      CREATE TABLE IF NOT EXISTS my_table (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT,\n        age INTEGER\n      )\n    '''\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nDeklarasi dan inisialisasi variabel instance sebagai instance tunggal dari kelas DatabaseHelper. Variabel ini bertipe DatabaseHelper dan dideklarasikan sebagai static final, sehingga hanya ada satu instance dari kelas ini yang dapat digunakan.\nDeklarasi variabel _database sebagai variabel database yang digunakan dalam kelas. Variabel ini ditandai dengan tanda tanya (?) yang menandakan bahwa nilainya bisa null. Variabel ini bersifat private karena diawali dengan underscore (_).\nKonstruktor _DatabaseHelper._() merupakan konstruktor private yang tidak bisa diakses dari luar kelas. Ini dilakukan agar kelas ini tidak dapat diinisialisasi dari luar.\nFungsi database merupakan getter yang mengembalikan Future&lt;Database&gt;. Fungsi ini digunakan untuk mendapatkan akses ke database. Pada awalnya, fungsi ini mengecek apakah _database sudah terinisialisasi, jika sudah, maka langsung mengembalikan _database yang sudah ada. Jika belum, maka fungsi _initDatabase() dipanggil untuk menginisialisasi database dan mengembalikan nilainya.\nFungsi _initDatabase() merupakan fungsi yang digunakan untuk menginisialisasi database. Pada fungsi ini, direktori aplikasi diakses menggunakan getApplicationDocumentsDirectory() dan path untuk database dibentuk dengan menggabungkan path direktori aplikasi dengan nama file database. Kemudian, fungsi openDatabase() dipanggil dengan menggunakan path tersebut, dan versi database serta callback _createDb untuk aksi pembuatan tabel.\nFungsi _createDb() merupakan callback yang dipanggil saat database dibuat. Pada fungsi ini, tabel my_table akan dibuat jika belum ada. Tabel tersebut memiliki tiga kolom yaitu id sebagai kunci utama yang diatur untuk otomatis bertambah nilainya (AUTOINCREMENT), name sebagai teks, dan age sebagai bilangan bulat.\n\n\n\n\n\n6.2.2 CRUD Data dengan SQLite\n\nImplementasi CRUD\n\nSelanjutnya, agar aplikasi dapat melakukan interaksi dengan database seperti menambah, mengupdate, menghapus, dan mendapatkan data diperlukan method tambahan di dalam class DatabaseHelper. Method tersebut mengembalikan nilai Future karena memerlukan proses pengambilan data terlebih dahulu yang biasanya sedikit memakan waktu.\nclass DatabaseHelper {\n  // ...\n  \n  Future&lt;int&gt; insert(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    return await db.insert('my_table', row);\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; queryAll() async {\n    Database db = await instance.database;\n    return await db.query('my_table');\n  }\n\n  Future&lt;int&gt; update(Map&lt;String, dynamic&gt; row) async {\n    Database db = await instance.database;\n    int id = row['id'];\n    return await db.update(\n        'my_table', \n        row, \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n\n  Future&lt;int&gt; delete(int id) async {\n    Database db = await instance.database;\n    return await db.delete(\n        'my_table', \n        where: 'id = ?', \n        whereArgs: [id],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nMetode insert:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan dimasukkan ke dalam tabel database.\nPertama, kita mendapatkan instance objek Database dengan menggunakan await instance.database. instance adalah sebuah objek yang memiliki method database yang mengembalikan objek Database.\nKemudian, menggunakan objek db, kita menggunakan metode insert untuk memasukkan data ke dalam tabel dengan nama ‘my_table’. Metode insert mengembalikan nilai int yang merupakan id dari row yang baru saja dimasukkan.\nMetode insert mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode queryAll:\n\nMetode ini tidak menerima parameter.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode query untuk melakukan kueri terhadap tabel dengan nama ‘my_table’.\nMetode query mengembalikan objek Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya berupa List dari Map yang berisi data dari tabel.\n\nMetode update:\n\nMetode ini menerima parameter row yang merupakan sebuah Map yang berisi data yang akan diperbarui pada tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nKita mengambil nilai id dari row dengan menggunakan int id = row['id'].\nMenggunakan objek db, kita menggunakan metode update untuk memperbarui data pada tabel ‘my_table’. Metode update mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh perubahan.\nMetode update mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\nMetode delete:\n\nMetode ini menerima parameter id yang merupakan nilai id yang akan dihapus dari tabel.\nKembali, kita mendapatkan instance objek Database dengan menggunakan await instance.database.\nMenggunakan objek db, kita menggunakan metode delete untuk menghapus baris dengan kondisi ‘id = ?’ dari tabel ‘my_table’. whereArgs: [id] digunakan untuk menggantikan ? dengan nilai id.\nMetode delete mengembalikan nilai int yang merupakan jumlah baris yang terpengaruh oleh penghapusan.\nMetode delete mengembalikan objek Future&lt;int&gt;, yang berarti metode ini akan menunggu operasi asinkron selesai dan kemudian mengembalikan hasilnya.\n\n\n\n\n\n\n6.2.3 Query Pencarian Database Lokal\n\nImplementasi query search\n\nSetelah menambahkan method-method diatas aplikasi sudah mampu berinteraksi dengan database. Namun sebagai tambahan akan lebih seru jika aplikasi dapat mencari data didalam database. Maka dari itu selanjutnya, dalam DatabaseHelper, tambahkan metode untuk melakukan operasi query search:\nclass DatabaseHelper {\n  // ...\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {\n    Database? db = await database;\n    return await db!.query(\n        'your_table', \n        where: 'name LIKE ?', \n        whereArgs: ['%$query%'],\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nFuture&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; querySearch(String query) async {:\n\nMembuka definisi fungsi querySearch yang menerima string query sebagai argumen dan mengembalikan Future yang berisi daftar hasil pencarian.\n\nDatabase? db = await database;:\n\nMembuat variabel db yang bertipe Database? (nullable) dan menginisialisasinya dengan hasil pemanggilan await database.\nKata kunci await digunakan untuk menunggu hingga database selesai di-load sebelum melanjutkan eksekusi kode.\n\nreturn await db!.query('your_table', where: 'name LIKE ?', whereArgs: ['%$query%']);:\n\nMengembalikan hasil dari pemanggilan metode query pada objek db.\nMetode query digunakan untuk melakukan kueri pada tabel database.\nParameter pertama 'your_table' adalah nama tabel yang ingin dikueri.\nParameter where digunakan untuk menentukan kondisi pencarian yang diterapkan pada kueri. Dalam hal ini, kondisi adalah 'name LIKE ?', yang berarti kolom ‘name’ harus mirip dengan nilai yang diberikan.\nParameter whereArgs berisi daftar argumen yang akan menggantikan tanda tanya (?) dalam kondisi pencarian. Dalam hal ini, argumen yang digunakan adalah ['%$query%'], yang akan mencocokkan nilai dengan string yang mengandung query di mana pun dalam nilainya."
  },
  {
    "objectID": "6_akses_data_lokal.html#studi-kasus",
    "href": "6_akses_data_lokal.html#studi-kasus",
    "title": "6  Akses Data Lokal",
    "section": "6.3 Studi Kasus",
    "text": "6.3 Studi Kasus\nSetelah mengetahui cara menghubungkan dan berinteraksi dengan database sqlite pada aplikasi flutter tahap selanjutnya adalah membuat studi kasus. Pada studi kasus bab ini kita akan mencoba membuat aplikasi yang dapat melakukan crud data mahasiswa dengan menggunakan sqlite pada flutter. Pertama-tama silahkan buat projek flutter baru. Lalu setelah itu tambahkan dependencies database_helper.dart masukan sqflite, path_provider dan path pada pubspec.yaml.\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^x.x.x\n  path: ^x.x.x\n  path_provider: ^x.x.x\nSetelah itu buat file database_helper.dart. Didalam file ini kita akan membuat class DatabaseHelper sama seperti penjelasan diatas namun dengan beberapa perubahan menyesuaikan dengan studi kasus crud data mahasiswa.\n\n\n\nStudi Kasus Details\n\n\nimport 'dart:async';\nimport 'dart:io' as io;\nimport 'package:path/path.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'package:path_provider/path_provider.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper _instance = DatabaseHelper.internal();\n\n  factory DatabaseHelper() =&gt; _instance;\n\n  static Database? _db;\n\n  Future&lt;Database?&gt; get db async {\n    if (_db != null) return _db;\n    _db = await initDb();\n    return _db;\n  }\n\n  DatabaseHelper.internal();\n\n  Future&lt;Database&gt; initDb() async {\n    io.Directory documentsDirectory = await \n    getApplicationDocumentsDirectory();\n    String path = join(\n        documentsDirectory.path, \n        'database.db',\n    );\n    var theDb = await openDatabase(\n        path, \n        version: 1, \n        onCreate: _onCreate,\n    );\n    return theDb;\n  }\n\n  void _onCreate(Database db, int version) async {\n    await db.execute(\n        '''\n        CREATE TABLE \n        IF NOT EXISTS mahasiswa \n        (id INTEGER PRIMARY KEY, name TEXT, nim TEXT)\n        '''\n    );\n  }\n\n  Future&lt;int&gt; addMahasiswa(Map&lt;String, dynamic&gt; mahasiswa) \n  async {\n    var dbClient = await db;\n    return await dbClient!.insert('mahasiswa', mahasiswa);\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; getAllMahasiswa() \n  async {\n    var dbClient = await db;\n    return await dbClient!.query('mahasiswa');\n  }\n\n  Future&lt;int&gt; updateMahasiswa(Map&lt;String, dynamic&gt; mahasiswa) \n  async {\n    var dbClient = await db;\n    return await dbClient!.update('mahasiswa', mahasiswa,\n        where: 'id = ?', whereArgs: [mahasiswa['id']]);\n  }\n\n  Future&lt;int&gt; deleteMahasiswa(int id) async {\n    var dbClient = await db;\n    return await dbClient!\n        .delete(\n            'mahasiswa', \n            where: 'id = ?', \n            whereArgs: [id],\n        );\n  }\n\n  Future&lt;List&lt;Map&lt;String, dynamic&gt;&gt;&gt; searchMahasiswa(String keyword) \n  async {\n    var dbClient = await db;\n    return await dbClient!\n        .query(\n            'mahasiswa', \n            where: 'name LIKE ?', \n            whereArgs: ['%$keyword%'],\n        );\n  }\n}\nSelanjutnya buatlah satu tampilan sederhana untuk menampung data dari database, menambah data, menghapus data, mengupdate data, dan melakukan pencarian data. Tampilan akan ditampung dalam StatefullWidget dikarenakan data yang digunakan dalam tampilan tersebut akan berubah menyesuaikan dengan isi database. Berikut adalah contoh dari tampilannya.\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'CRUD App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  final TextEditingController _searchController = \n  TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('CRUD App'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) {},\n            ),\n          ),\n          Expanded(\n            child: ListTile(\n              title: Text(\"Nama\"),\n              subtitle: Text(\"NIM\"),\n              trailing: IconButton(\n                icon: Icon(Icons.delete),\n                onPressed: () {},\n              ),\n              onTap: () =&gt; showDialog(\n                context: context,\n                builder: (context) =&gt; AlertDialog(\n                  title: Text('Edit Data'),\n                  content: Column(\n                    mainAxisSize: MainAxisSize.min,\n                    children: [\n                      TextField(\n                        decoration: InputDecoration(\n                          labelText: 'Nama',\n                        ),\n                        controller: \n                        TextEditingController(text: \"Nama\"),\n                        onChanged: (value) {},\n                      ),\n                      TextField(\n                        decoration: InputDecoration(\n                          labelText: 'NIM',\n                        ),\n                        controller: \n                        TextEditingController(text: \"NIM\"),\n                        onChanged: (value) {},\n                      ),\n                    ],\n                  ),\n                  actions: [\n                    ElevatedButton(\n                      onPressed: () {\n                        Navigator.pop(context);\n                      },\n                      child: Text('Save'),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\n\nStudi Kasus Details\n\n\nSetelah itu tambahkan beberapa atribut dan method dalam HomePage supaya dapat terhubung dengan database melalui DatabaseHelper\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  final dbHelper = DatabaseHelper();\n  List&lt;Map&lt;String, dynamic&gt;&gt; _items = [];\n\n  void refreshItemList() async {\n    final items = await dbHelper.getAllMahasiswa();\n    setState(() {\n      _items = items;\n    });\n  }\n\n  void searchItems() async {\n    final keyword = _searchController.text.trim();\n    if (keyword.isNotEmpty) {\n      final items = await dbHelper.searchMahasiswa(keyword);\n      setState(() {\n        _items = items;\n      });\n    } else {\n      refreshItemList();\n    }\n  }\n\n  void addItem() async {\n    final item = {\n      'name': 'udinus',\n      'nim': 'a11.2020.12345',\n    };\n    await dbHelper.addMahasiswa(item);\n    refreshItemList();\n  }\n\n  void updateItem(int id, String name, String nim) async {\n    final item = {\n      'id': id,\n      'name': name,\n      'nim': nim,\n    };\n    await dbHelper.updateMahasiswa(item);\n    refreshItemList();\n  }\n\n  void deleteItem(int id) async {\n    await dbHelper.deleteMahasiswa(id);\n    refreshItemList();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nfinal dbHelper = DatabaseHelper();\n\nMembuat objek dbHelper yang merupakan instance dari kelas DatabaseHelper. Objek ini akan digunakan untuk mengakses dan memanipulasi data pada database.\n\nList&lt;Map&lt;String, dynamic&gt;&gt; _items = [];\n\nMembuat variabel _items yang merupakan daftar item mahasiswa dalam bentuk List of Maps. Setiap item direpresentasikan sebagai Map yang memiliki tipe data String sebagai kunci dan dynamic sebagai nilai. Variabel ini akan digunakan untuk menyimpan hasil query dari database.\n\nvoid refreshItemList() async {...}\n\nFungsi refreshItemList digunakan untuk memperbarui daftar item dengan memanggil metode getAllMahasiswa dari objek dbHelper. Fungsi ini menggunakan kata kunci await untuk menunggu hasil query dari database sebelum memperbarui nilai variabel _items. Setelah nilai _items diperbarui, fungsi setState dipanggil untuk memberi tahu framework Flutter bahwa state telah berubah dan perlu diperbarui tampilan UI.\n\nvoid searchItems() async {...}\n\nFungsi searchItems digunakan untuk mencari item mahasiswa berdasarkan kata kunci yang diinputkan. Pertama, kata kunci diambil dari controller teks _searchController dan di-trim untuk menghapus spasi di awal dan akhir. Jika kata kunci tidak kosong, fungsi ini akan memanggil metode searchMahasiswa dari objek dbHelper dengan kata kunci sebagai argumen. Hasil query kemudian disimpan dalam variabel items, dan nilai _items diperbarui dengan nilai items tersebut. Jika kata kunci kosong, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid addItem() async {...}\n\nFungsi addItem digunakan untuk menambahkan item mahasiswa baru ke database. Item baru didefinisikan sebagai Map dengan kunci ‘name’ dan ‘nim’, dan nilai yang sesuai. Fungsi ini memanggil metode addMahasiswa dari objek dbHelper dengan item sebagai argumen. Setelah penambahan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid updateItem(int id, String name, String nim) async {...}\n\nFungsi updateItem digunakan untuk memperbarui item mahasiswa dengan ID, nama, dan NIM yang baru. Item yang akan diperbarui didefinisikan sebagai Map dengan kunci ‘id’, ‘name’, dan ‘nim’, dan nilai yang sesuai. Fungsi ini memanggil metode updateMahasiswa dari objek dbHelper dengan item sebagai argumen. Setelah pembaruan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\nvoid deleteItem(int id) async {...}\n\nFungsi deleteItem digunakan untuk menghapus item mahasiswa berdasarkan ID-nya. Fungsi ini memanggil metode deleteMahasiswa dari objek dbHelper dengan ID sebagai argumen. Setelah penghapusan item selesai, fungsi refreshItemList dipanggil untuk memperbarui daftar item.\n\n\n\n\nLalu agar ketika pertama kali dibuka data dari database langsung ditampilkan panggil method refreshItemList() pada initState()\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  @override\n  void initState() {\n    super.initState();\n    refreshItemList();\n  } \n\n  // ...\n\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\nDalam kode tersebut, @override menandakan bahwa metode initState() di bawahnya menggantikan atau mendapatkan ulang perilaku dari metode initState() yang ada dalam kelas induk. Dalam hal ini, kelas induk tersebut adalah StatefulWidget.\nMetode super.initState() dipanggil untuk menjalankan implementasi dari metode initState() dalam kelas induk. Ini memungkinkan kelas induk melakukan inisialisasi yang diperlukan sebelum melakukan inisialisasi khusus pada kelas turunan.\nKemudian, refreshItemList() dipanggil setelah super.initState() untuk memperbarui daftar item. Ini mungkin adalah metode khusus yang ditentukan di dalam kelas tersebut untuk memperbarui daftar item yang akan ditampilkan di widget.\n\n\nlangkah terakhir adalah dengan memanggil method method tersebut dengan widget dalam aplikasi seperti tombol, text field, dan listview.\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =&gt; _HomePageState();\n}\n\nclass _HomePageState extends State&lt;HomePage&gt; {\n  // ...\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('CRUD App'),\n      ),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _searchController,\n              decoration: InputDecoration(\n                labelText: 'Search',\n                prefixIcon: Icon(Icons.search),\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (_) =&gt; searchItems(),\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _items.length,\n              itemBuilder: (context, index) {\n                final item = _items[index];\n                return ListTile(\n                  title: Text(item['name']),\n                  subtitle: Text(item['nim']),\n                  trailing: IconButton(\n                    icon: Icon(Icons.delete),\n                    onPressed: () =&gt; deleteItem(item['id']),\n                  ),\n                  onTap: () =&gt; showDialog(\n                    context: context,\n                    builder: (context) =&gt; AlertDialog(\n                      title: Text('Edit Item'),\n                      content: Column(\n                        mainAxisSize: MainAxisSize.min,\n                        children: [\n                          TextField(\n                            decoration: InputDecoration(\n                              labelText: 'Nama',\n                            ),\n                            controller:\n                                TextEditingController(\n                                    text: item['name'],\n                                ),\n                            onChanged: (value) =&gt; \n                            item['name'] = value,\n                          ),\n                          TextField(\n                            decoration: InputDecoration(\n                              labelText: 'NIM',\n                            ),\n                            controller:\n                             TextEditingController(\n                                text: item['nim'],\n                             ),\n                            onChanged: (value) =&gt; \n                            item['nim'] = value,\n                          ),\n                        ],\n                      ),\n                      actions: [\n                        ElevatedButton(\n                          onPressed: () {\n                            updateItem(\n                                item['id'], \n                                item['name'], \n                                item['nim'],\n                                );\n                            Navigator.pop(context);\n                          },\n                          child: Text('Save'),\n                        ),\n                      ],\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: addItem,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\n\n\n\n\nPenjelasan\n\n\n\n\nAppBar: Ini adalah bilah aplikasi yang menampilkan judul “CRUD App”. Digunakan sebagai bagian atas aplikasi.\nColumn: Ini adalah widget yang digunakan untuk mengatur tata letak secara vertikal. Di dalam Column, terdapat beberapa widget lain yang ditampilkan secara berurutan.\nTextField: Ini adalah input teks yang digunakan untuk melakukan pencarian item. TextField menerima kontroler _searchController yang digunakan untuk mengontrol isian dan onChanged dipanggil ketika teks berubah untuk memicu fungsi searchItems().\nExpanded: Ini adalah widget yang digunakan untuk memperluas widget anak ke ruang yang tersedia. Di dalam Expanded, terdapat ListView.builder yang digunakan untuk menampilkan daftar item.\nListView.builder: Ini adalah widget yang digunakan untuk membuat daftar yang dapat digulir secara dinamis. ListView.builder mengambil itemCount dari _items.length dan membangun item pada indeks tertentu menggunakan fungsi itemBuilder.\nListTile: Ini adalah widget yang digunakan untuk menampilkan setiap item dalam daftar. Setiap ListTile berisi judul item (Text(item['name'])), subjudul item (Text(item['nim'])), dan ikon tombol hapus (Icon(Icons.delete)). Ketika ikon hapus diklik, fungsi deleteItem(item['id']) dipanggil.\nonTap: Ini adalah fungsi yang dipicu ketika ListTile ditekan. Fungsi ini menampilkan dialog AlertDialog yang memungkinkan pengguna untuk mengedit item. Di dalam AlertDialog, terdapat dua TextField untuk mengedit nama dan NIM item. Ketika tombol “Save” diklik, fungsi updateItem(item['id'], item['name'], item['nim']) dipanggil dan dialog ditutup dengan Navigator.pop(context).\nfloatingActionButton: Ini adalah tombol tindakan mengambang yang ditempatkan di sudut kanan bawah. Ketika tombol ini ditekan, fungsi addItem() dipanggil."
  },
  {
    "objectID": "7_akses_data_api.html#konsep-dasar-rest-api",
    "href": "7_akses_data_api.html#konsep-dasar-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.1 Konsep Dasar REST API",
    "text": "7.1 Konsep Dasar REST API"
  },
  {
    "objectID": "7_akses_data_api.html#menggunakan-package-http",
    "href": "7_akses_data_api.html#menggunakan-package-http",
    "title": "7  Akses Data Melalui API",
    "section": "7.2 Menggunakan Package HTTP",
    "text": "7.2 Menggunakan Package HTTP"
  },
  {
    "objectID": "7_akses_data_api.html#mengambil-data-dari-rest-api",
    "href": "7_akses_data_api.html#mengambil-data-dari-rest-api",
    "title": "7  Akses Data Melalui API",
    "section": "7.3 Mengambil Data dari REST API",
    "text": "7.3 Mengambil Data dari REST API"
  },
  {
    "objectID": "7_akses_data_api.html#menampilkan-data-pada-widget",
    "href": "7_akses_data_api.html#menampilkan-data-pada-widget",
    "title": "7  Akses Data Melalui API",
    "section": "7.4 Menampilkan Data pada Widget",
    "text": "7.4 Menampilkan Data pada Widget"
  },
  {
    "objectID": "8_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "href": "8_integrasi_baas.html#konsep-baas-dan-serverless-application",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.1 Konsep BAaS dan Serverless Application",
    "text": "8.1 Konsep BAaS dan Serverless Application"
  },
  {
    "objectID": "8_integrasi_baas.html#pengenalan-supabase",
    "href": "8_integrasi_baas.html#pengenalan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.2 Pengenalan Supabase",
    "text": "8.2 Pengenalan Supabase"
  },
  {
    "objectID": "8_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "href": "8_integrasi_baas.html#integrasi-supabase-dengan-flutter",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.3 Integrasi Supabase dengan Flutter",
    "text": "8.3 Integrasi Supabase dengan Flutter"
  },
  {
    "objectID": "8_integrasi_baas.html#otentikasi-dengan-supabase",
    "href": "8_integrasi_baas.html#otentikasi-dengan-supabase",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.4 Otentikasi dengan Supabase",
    "text": "8.4 Otentikasi dengan Supabase"
  },
  {
    "objectID": "8_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "href": "8_integrasi_baas.html#pengunaan-supabase-untuk-penyimpanan-data",
    "title": "8  Integrasi dengan BAaS",
    "section": "8.5 Pengunaan Supabase untuk Penyimpanan Data",
    "text": "8.5 Pengunaan Supabase untuk Penyimpanan Data"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "href": "9_layanan_berbasis_lokasi.html#menggunakan-package-location",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.1 Menggunakan Package Location",
    "text": "9.1 Menggunakan Package Location"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "href": "9_layanan_berbasis_lokasi.html#mengunakan-widget-geolocator",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.2 Mengunakan Widget Geolocator",
    "text": "9.2 Mengunakan Widget Geolocator"
  },
  {
    "objectID": "9_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "href": "9_layanan_berbasis_lokasi.html#menampilkan-openstreetmap-api-pada-aplikasi",
    "title": "9  Layanan Berbasis Lokasi",
    "section": "9.3 Menampilkan OpenStreetMap API pada Aplikasi",
    "text": "9.3 Menampilkan OpenStreetMap API pada Aplikasi"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "href": "10_pengamanan_aplikasi.html#konsep-protokol-jaringan-aman-dengan-https",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS",
    "text": "10.1 Konsep Protokol Jaringan Aman dengan HTTPS"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#autentikasi-pengguna",
    "href": "10_pengamanan_aplikasi.html#autentikasi-pengguna",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.2 Autentikasi Pengguna",
    "text": "10.2 Autentikasi Pengguna"
  },
  {
    "objectID": "10_pengamanan_aplikasi.html#obfuscating-dart-code",
    "href": "10_pengamanan_aplikasi.html#obfuscating-dart-code",
    "title": "10  Pengamanan Aplikasi",
    "section": "10.3 Obfuscating Dart Code",
    "text": "10.3 Obfuscating Dart Code"
  },
  {
    "objectID": "proyek_1.html#fitur-utama",
    "href": "proyek_1.html#fitur-utama",
    "title": "14  Proyek Kalkulator",
    "section": "14.1 Fitur Utama",
    "text": "14.1 Fitur Utama\n\nTampilan Antarmuka Pengguna:\n\nAplikasi akan memiliki tampilan antarmuka pengguna yang terdiri dari tombol-tombol angka, operator, dan fungsi matematika seperti tambah, kurang, kali, bagi, dan sebagainya.\nTampilan akan dirancang agar mudah digunakan dan memberikan pengalaman pengguna yang intuitif.\n\nPerhitungan Matematika:\n\nPengguna dapat melakukan perhitungan matematika dasar seperti penjumlahan, pengurangan, perkalian, dan pembagian.\nAplikasi akan memiliki logika yang memungkinkan pengguna melakukan perhitungan secara berurutan, menggabungkan beberapa operasi, dan menghasilkan hasil yang akurat.\n\nDesain Responsif:\n\nAplikasi akan memiliki desain yang responsif dan bisa diakses dengan baik di berbagai perangkat dengan ukuran layar yang berbeda."
  },
  {
    "objectID": "proyek_1.html#teknologi-yang-digunakan",
    "href": "proyek_1.html#teknologi-yang-digunakan",
    "title": "14  Proyek Kalkulator",
    "section": "14.2 Teknologi yang Digunakan",
    "text": "14.2 Teknologi yang Digunakan\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nDart sebagai bahasa pemrograman untuk mengembangkan logika aplikasi.\nWidget dan State Management dari Flutter untuk mengatur tampilan dan interaksi pengguna.\nMatematika dasar menggunakan operator dan fungsi bawaan dari Dart.\n\nTujuan dari proyek ini adalah memberikan pengguna sebuah kalkulator yang dapat digunakan dengan mudah, memiliki performa yang baik, dan memberikan hasil perhitungan yang akurat. Aplikasi Kalkulator ini akan menjadi alat yang berguna untuk keperluan perhitungan sehari-hari, baik untuk kebutuhan pribadi maupun profesional.\nSelama mengembangkan aplikasi Kalkulator, penting untuk memastikan bahwa logika perhitungan matematika benar, antarmuka pengguna responsif dan intuitif, serta mengikuti pedoman desain terbaik dari Flutter."
  },
  {
    "objectID": "proyek_1.html#contoh-tampilan-aplikasi",
    "href": "proyek_1.html#contoh-tampilan-aplikasi",
    "title": "14  Proyek Kalkulator",
    "section": "14.3 Contoh tampilan aplikasi",
    "text": "14.3 Contoh tampilan aplikasi\nAplikasi kalkulator hanya memiliki satu halaman saja dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nContoh tampilan kalkulator"
  },
  {
    "objectID": "proyek_2.html#fitur-utama",
    "href": "proyek_2.html#fitur-utama",
    "title": "15  Proyek Password Vault",
    "section": "15.1 Fitur Utama:",
    "text": "15.1 Fitur Utama:\n\nRegistrasi dan Login Pengguna:\n\nPengguna dapat membuat akun baru dengan menyediakan email dan kata sandi.\nPengguna dapat masuk ke akun mereka dengan mengautentikasi email dan kata sandi.\n\nPenyimpanan Data Kata Sandi:\n\nPengguna dapat menyimpan data kata sandi mereka dengan memasukkan judul, username, dan kata sandi untuk setiap entri.\nData kata sandi akan disimpan secara aman dalam penyimpanan lokal dengan menggunakan enkripsi.\n\nManajemen Data Kata Sandi:\n\nPengguna dapat melihat daftar entri kata sandi yang disimpan.\nPengguna dapat menambahkan, mengedit, atau menghapus entri kata sandi.\nPengguna dapat mencari entri kata sandi berdasarkan judul atau username.\n\nKeamanan dan Enkripsi:\n\nData kata sandi disimpan dalam penyimpanan lokal dengan menggunakan teknik enkripsi yang aman.\nPengguna akan diminta memasukkan kata sandi master saat masuk ke aplikasi untuk membuka akses ke data kata sandi.\n\nUI yang Responsif:\n\nAplikasi akan memiliki antarmuka pengguna yang responsif dan menarik, memungkinkan pengguna untuk dengan mudah menavigasi dan menggunakan fitur-fitur yang ada."
  },
  {
    "objectID": "proyek_2.html#teknologi-yang-digunakan",
    "href": "proyek_2.html#teknologi-yang-digunakan",
    "title": "15  Proyek Password Vault",
    "section": "15.2 Teknologi yang Digunakan:",
    "text": "15.2 Teknologi yang Digunakan:\n\nFlutter sebagai kerangka kerja untuk pengembangan aplikasi mobile lintas platform.\nPackage sqflite untuk mengakses dan menyimpan data dalam penyimpanan lokal SQLite.\nPackage encrypt untuk melakukan enkripsi dan dekripsi data kata sandi.\nPackage flutter_secure_storage untuk menyimpan kata sandi master dengan aman.\n\nTujuan dari proyek ini adalah memberikan pengguna aplikasi sebuah solusi yang aman dan mudah digunakan untuk mengelola kata sandi mereka. Aplikasi Password Vault ini akan memberikan perlindungan terhadap pencurian kata sandi dan memberikan akses cepat ke informasi penting yang dibutuhkan oleh pengguna dalam kehidupan digital mereka.\nCatatan: Penting untuk selalu mengutamakan keamanan dalam pengembangan aplikasi semacam ini. Pastikan untuk menggunakan praktik terbaik dalam hal pengamanan dan enkripsi data yang sensitif."
  },
  {
    "objectID": "proyek_2.html#contoh-tampilan-aplikasi",
    "href": "proyek_2.html#contoh-tampilan-aplikasi",
    "title": "15  Proyek Password Vault",
    "section": "15.3 Contoh tampilan aplikasi:",
    "text": "15.3 Contoh tampilan aplikasi:\nAplikasi Password Vault memiliki beberapa halaman dengan tampilan kurang lebih seperti di bawah ini.\n\n\n\nRancangan tampilan password vault"
  },
  {
    "objectID": "proyek_3.html",
    "href": "proyek_3.html",
    "title": "16  Proyek 3 : Lapor Book",
    "section": "",
    "text": "Tips\n\n\n\nPada proyek ini disarankan sudah membaca Bab 1 hingga 10"
  },
  {
    "objectID": "proyek_1.html",
    "href": "proyek_1.html",
    "title": "14  Proyek Kalkulator",
    "section": "",
    "text": "Proyek Kalkulator\nAplikasi Kalkulator adalah proyek Flutter yang bertujuan untuk membuat sebuah kalkulator fungsional yang dapat digunakan untuk melakukan operasi matematika dasar. Aplikasi ini akan menyediakan antarmuka pengguna yang intuitif dan responsif untuk memudahkan pengguna dalam melakukan perhitungan."
  },
  {
    "objectID": "proyek_1.html#langkah-pembuatan-aplikasi-aplikasi",
    "href": "proyek_1.html#langkah-pembuatan-aplikasi-aplikasi",
    "title": "14  Proyek Kalkulator",
    "section": "14.4 Langkah Pembuatan Aplikasi aplikasi",
    "text": "14.4 Langkah Pembuatan Aplikasi aplikasi\n\nPersiapan Awal\n\nPastikan Komputer Anda masih terinstal Flutter dan Dart.\nBuat proyek baru menggunakan perintah flutter create nama_proyek.\nPastikan Anda telah membuat file ‘custom_button.dart’ dan ‘custom_number_button.dart’ untuk tombol yang akan digunakan\n\nDesain Tampilan Antarmuka\n\nBuka file ‘lib/main.dart’ dan rancang tampilan kalkulator menggunakan widget seperti ‘Column’, ‘Row’, atau ‘FlatButton’ untuk tombol-tombol angka, operator, dan fungsi matematika.\nDalam hal ini gunakan Scaffold dengan AppBar untuk memasukkan widget kita.\nSesuaikan gaya dan desain tampilan sesuai dengan contoh yang Anda berikan.\n‘MaterialApp’ digunakan untuk mengatur tema aplikasi dan menentukan halaman utama (MyHomePage).\n\nLogika Perhitungan\n\nBuat kelas atau fungsi yang mengelola logika perhitungan matematika.\nAnda bisa menggunakan variabel untuk menyimpan angka-angka dan operator yang dimasukkan oleh pengguna.\nBuat fungsi-fungsi untuk menjalankan operasi matematika seperti penjumlahan, pengurangan, perkalian, dan pembagian.\nPada bagian _MyHomePageState, telah ditentukan beberapa metode yang mengatur logika perhitungan. Metode ini akan memproses input dari tombol-tombol yang ditekan oleh pengguna dan memperbarui tampilan sesuai.\n\nInteraksi Pengguna\n\nHubungkan tombol-tombol dengan logika perhitungan yang telah Anda buat.\nKetika pengguna menekan tombol angka atau operator, perbarui tampilan dan logika perhitungan sesuai.\nTombol operasi dan angka dengan menggunakan widget CustomOperationButton dan CustomNumberButton. Implementasi widget-widget ini dalam file yang telah dibuat dalam file external (‘custom_button.dart’ dan ‘custom_number_button.dart’).\n\nMenampilkan Hasil\n\nBuat widget untuk menampilkan hasil perhitungan.\nKetika pengguna menekan tombol “=” atau selesai menginput operasi, tampilkan hasil perhitungan pada widget ini.\nPada tampilan, gunakan Text widget untuk menampilkan field1, operator, dan field2. Ini adalah hasil dari logika perhitungan yang telah di definisikan sebelumnya.\nGunakan widget Column, Row, dan GridView untuk mengatur tata letak tombol-tombol. Atur properti seperti crossAxisCount dan shrinkWrap sesuai kebutuhan.\nSetiap kali tombol operasi atau angka ditekan, aplikasi memanggil metode yang telah di tentukan sebelumnya. Misalnya, saat tombol “1” ditekan, Anda memanggil inputField(“1”).\n‘setState’ untuk memperbarui state ketika ada perubahan dalam logika perhitungan atau tampilan.\n\nJalankan Aplikasi\n\nPada main function, jalankan aplikasi dengan runApp(MyApp()).\n\nTesting dan Debugging\n\nUji aplikasi secara menyeluruh untuk memastikan semua operasi matematika berjalan dengan benar sesuai alur logika pada aplikasi kalkulator yang anda dibuat"
  },
  {
    "objectID": "proyek_2.html",
    "href": "proyek_2.html",
    "title": "15  Proyek Password Vault",
    "section": "",
    "text": "Proyek Password Vault\nAplikasi Password Vault adalah sebuah proyek Flutter yang bertujuan untuk menyediakan tempat aman untuk menyimpan dan mengelola kata sandi (password) pengguna. Aplikasi ini akan menggunakan penyimpanan lokal untuk menyimpan data pengguna dan kata sandi yang dienkripsi."
  },
  {
    "objectID": "proyek_2.html#langkah-pengerjaan",
    "href": "proyek_2.html#langkah-pengerjaan",
    "title": "15  Proyek Password Vault",
    "section": "15.4 Langkah Pengerjaan",
    "text": "15.4 Langkah Pengerjaan\n\n15.4.1 Persiapan & Perancangan Antar Muka\n\nMembuat proyek flutter baru (dengan VS Code)\nMenambahkan library yang diperlukan, serta penjelasan kegunaan library tersebut\nMembuat Halaman Login (tanpa logika dulu):\n\nMembuat komponen yang diperlukan\nMenambahkan komponen ke halaman login\nMenambahkan style komponen yang diperlukan\nMemanggil halaman login di main page\n\nMembuat halaman register (tanpa logika juga):\n\nMembuat komponen yang diperlukan\nMenambahkan komponen ke halaman register\nMemanggil halaman register dari halaman login\n\nMembuat halaman home page (Tanpa list kategori dulu):\n\nMembuat halaman home page kosongan\nMembuat halaman Add Category (tanpa logika)\nMenambahkan floatActionButton untuk manggil halaman add category dari halaman homepage\n\nMenambahkan list category pada home page:\n\nMembuat beberapa array of object dummy dulu\nMembuat list kategory dengan ListView (on pressed masih kosongan dulu)\n\nMembuat halaman list_password (tanpa data list password dulu):\n\nMembuat halaman list_password kosongan\nMembuat halaman Add Password (tanpa logika)\nMenambahkan floatActionButton untuk memanggil halaman add Password dari halaman list password\n\nMenambahkan List password pada halaman List password:\n\nMembuat beberapa array of object dummy dulu\nMembuat list password dengan ListView (on pressed masih kosongan dulu)\n\nMembuat halaman detail password:\n\nMembuat komponen custom username box\nMembuat komponen custom password box (tanpa fitur copy dan reveal password dulu)\nMembuat halaman detail password\nMenambahkan pemanggilan halaman detail password pada on pressed list password\n\n\n\n\n15.4.2 Local Storage untuk Register & Login\n\n\n\n15.4.3 Akses Basis Data Lokal"
  }
]